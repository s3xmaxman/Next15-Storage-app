1
00:00:00,000 --> 00:00:05,760
皆さん、このチャンネルにまた素晴らしいプロジェクトのチュートリアルが加わりました。今日はこの

2
00:00:05,760 --> 00:00:11,920
Zazzアプリケーションを構築します。Zazzというのは、Stripeを実装するという意味です、

3
00:00:11,920 --> 00:00:16,880
これにより、ユーザはさまざまなサブスクリプションを購入し、実際のSaaSのように追加機能をアンロックすることができます。

4
00:00:16,880 --> 00:00:23,040
サービスとしてのソフトウェアのようなものです。それでは、私たちが構築するものと、すべての機能を見てみましょう。

5
00:00:23,040 --> 00:00:28,880
これはフロントページで、レジュメのプレビューが表示されます。をクリックすると

6
00:00:28,880 --> 00:00:34,960
「Get Started
"をクリックすると、アプリが起動します。ここにはすでに履歴書が1つあります。この履歴書は

7
00:00:34,960 --> 00:00:40,960
編集することができます。また、このボタンで一から新しい履歴書を作成することもできます。ここで

8
00:00:40,960 --> 00:00:47,200
同じエディターですが、すべてが空です。そして、このマルチステップフォームができました。最初のステップは

9
00:00:47,200 --> 00:00:53,360
一般情報。これはこのプロジェクトの名前と説明です。例えば、「私のクールな履歴書」。

10
00:00:53,360 --> 00:00:58,320
ここで入力をやめると、右下に「保存」と表示されます。これは

11
00:00:58,320 --> 00:01:04,560
これは入力をやめてから2秒後に自動的に保存されます。つまり、タイピングしている間は

12
00:01:04,560 --> 00:01:12,000
は保存されません。しかし、もし私がちょっと入力を止めても、何か変更を加える必要があれば、自動的に保存されます。

13
00:01:12,000 --> 00:01:21,280
自動的に保存される。クールでしょ？というわけで、「私のクールな履歴書」。これは将来の仕事のための履歴書なんだ、

14
00:01:21,280 --> 00:01:26,560
何でもいいよ。これは履歴書の概要ページに表示される名前と内容です。

15
00:01:26,560 --> 00:01:32,480
の概要ページに表示されます。しかし、実際に履歴書に何かを記入するためには、以下の項目も記入しなければなりません。

16
00:01:32,480 --> 00:01:38,560
ここで他のステップに進む。次のステップ」をクリックするか、このパンくずをクリックします。

17
00:01:38,560 --> 00:01:46,480
をクリックすることもできます。同じ効果があります。もちろんこのアプリにはダークモードとライトモードがある。なぜって？

18
00:01:46,480 --> 00:01:52,000
最近のアプリには必ずダークモードとライトモードがある。システムテーマに設定することもできる。

19
00:01:52,000 --> 00:01:57,360
に設定することもできる。そして今、個人情報フォームにいる。

20
00:01:57,360 --> 00:02:03,840
姓と名を入力すると履歴書に入力されます。ここでも自動保存されます。また

21
00:02:03,840 --> 00:02:10,320
写真をアップロードすることもできます。私の写真があれば見てみましょう。このUSBメモリにあると思います。これだ。

22
00:02:10,320 --> 00:02:16,000
これを取ってみましょう。これだ。自動的にブロブ・ストレージにアップロードされ

23
00:02:16,000 --> 00:02:23,120
保存されます。だから今ページを更新しても、すべてがそのまま残っている。画像も名前も、

24
00:02:23,120 --> 00:02:29,440
同じタブ、同じフォームにいる。これは、関連する

25
00:02:29,440 --> 00:02:34,960
これは一般的に良い方法です。ここで

26
00:02:34,960 --> 00:02:42,480
レジュメのアイデアをURLに入れていることにお気づきでしょう。ページを更新しても同じ履歴書が編集されるのはこのためです。

27
00:02:42,480 --> 00:02:48,080
を編集していることになります。また、URLには現在のステップも書いてあります、

28
00:02:48,080 --> 00:02:53,520
個人情報 職歴に切り替えると、職歴に変わります。これが

29
00:02:53,520 --> 00:02:59,360
ページを更新するたびに、以前と同じステップ、同じフォームにたどり着くわけです。

30
00:02:59,360 --> 00:03:05,680
本当にプロフェッショナルだ。では、記入を続けましょう。では、私たちがフルスタック開発者だとしましょう。

31
00:03:05,680 --> 00:03:14,160
このテキストは自動的にここに置かれます。都市、空軍、国、ドイツ。そして自動的に

32
00:03:14,160 --> 00:03:21,600
コンマが追加されます。電話番号を追加すると、この弾丸アイコンも追加されます。

33
00:03:21,600 --> 00:03:28,720
これですべてがうまくいく。そしてメールアドレスはflorian@codingandflow.com。

34
00:03:28,720 --> 00:03:35,360
これで完了です。これが個人情報です。次のステップ、職歴に進みましょう。

35
00:03:35,360 --> 00:03:38,960
もちろん、このレイアウトはモバイルにも対応しています。見てみましょう。

36
00:03:38,960 --> 00:03:44,640
画面が小さくなると、この履歴書のプレビューは小さくなります。そして

37
00:03:44,640 --> 00:03:51,120
中のコンテンツ（テキストと画像）がコンテナのサイズに比例して大きくなったり小さくなったりすることにお気づきでしょう。

38
00:03:51,120 --> 00:03:56,160
コンテナのサイズに比例して大きくなったり小さくなったりします。これは理にかなっています。

39
00:03:56,160 --> 00:04:03,600
後でA4用紙に印刷したい履歴書のプレビューだからです。一枚の紙に。ということは、文字サイズもすべて

40
00:04:03,600 --> 00:04:09,200
はコンテナのサイズに合わせて拡大縮小しなければならないので、比率は変わりません。通常は

41
00:04:09,200 --> 00:04:15,440
divの場合、テキストのサイズはまったく同じで、コンテナだけが小さくなります。

42
00:04:15,440 --> 00:04:20,400
しかし、私たちはコンテナの中のコンテンツを拡大縮小します。最終的に画面が十分に小さくなれば

43
00:04:20,400 --> 00:04:27,040
そうなると、フォームとプレビューの両方に十分なスペースがなくなります。そうなったら

44
00:04:27,040 --> 00:04:31,920
デフォルトではプレビューを非表示にしていますが、このボタンの上に表示することもできます。

45
00:04:31,920 --> 00:04:37,760
これでレジュメのプレビューが表示され、フォームが表示されるようになりました。このエディターはモバイルでも使えます。

46
00:04:37,760 --> 00:04:44,800
クールでしょう？大きな画面では、両方の部分を見ることができます。さて、フォームのこのステップに

47
00:04:44,800 --> 00:04:50,640
仕事の経験。これは本当に素晴らしいことだ。つの仕事経験と別の仕事経験を

48
00:04:50,640 --> 00:04:56,640
そしてもうひとつ。記入を始めると、右側にこのデータが表示されます。

49
00:04:56,640 --> 00:05:02,160
右側にあります。開始日と終了日を指定できます。終了日を指定しない場合は

50
00:05:02,160 --> 00:05:09,200
現在と説明が表示されます。しかし、素晴らしいことに、私たちはAIも実装します。

51
00:05:09,200 --> 00:05:16,160
チャットGPT
APIを使ってAIを実装します。このボタンをクリックするとダイアログが開きます。そしてここに

52
00:05:16,160 --> 00:05:21,680
何をしたのか、いつからなのか。ここでは本当にぞんざいにできる。正しい文法とか

53
00:05:21,680 --> 00:05:29,440
文法も何も気にしなくていい。本当にぞんざいでいいんです。例えば、2016年からとか、例えば

54
00:05:29,440 --> 00:05:44,400
2016年11月から2018年10月まで、私はマクドナルドでハンバーガーを揚げる仕事をしていました。時にはトイレ掃除もしました。

55
00:05:45,120 --> 00:05:52,480
トイレ掃除もしました。そしてこれを提出すると、AIがプロフェッショナルな職務経歴書を作成してくれる。

56
00:05:52,480 --> 00:05:57,680
を生成してくれる。試してみよう。生成する。3秒くらいしかかからない。

57
00:05:57,680 --> 00:06:05,040
これで完了です。これらの項目をすべて埋めて、本当にプロっぽく聞こえるように書いてくれました。

58
00:06:05,040 --> 00:06:10,880
ハンバーガーを焼くためにフライヤーを操作し、清潔で安全な厨房環境を確保する。でも

59
00:06:10,880 --> 00:06:17,600
私たちの意見をガイドラインにした。私たちは2016年11月から10月までと言った。

60
00:06:17,600 --> 00:06:25,760
2018年マクドナルドのバーガーフライヤー。クールだと思いませんか？そして、さらに仕事の経験を追加することもできる。例えば

61
00:06:25,760 --> 00:06:35,600
2017年から今まで私はCEOでした。ただ、この言葉はとても歯がゆい。だから私はこの言葉を使う

62
00:06:36,480 --> 00:06:43,280
コーディングとフローの。AIがこの綴りを知っているように、この綴りを正しく書こう。

63
00:06:43,280 --> 00:06:54,240
React.jsとNext.jsの最高のプログラミングチュートリアルを作る場所

64
00:06:58,000 --> 00:07:06,960
たぶん、このままにしておこう。生成する。そして2017年を追加。終了日はありません。

65
00:07:06,960 --> 00:07:12,720
現在。コーディングとフローのCEO。そしてまた、このプロフェッショナルな響きを持つ説明が追加された。

66
00:07:12,720 --> 00:07:18,480
もちろん、これらの職歴を削除することもできるし、並べ替えることもできる。

67
00:07:18,480 --> 00:07:23,920
最新のものを一番上にしたいからです。そこでできることは、この小さなハンドルをドラッグすることだ。

68
00:07:23,920 --> 00:07:30,480
をドラッグして、これを上に移動させ、ここにドロップします。このフォームにはReact.hook.form

69
00:07:30,480 --> 00:07:35,680
を使ってフォームを作成します。

70
00:07:35,680 --> 00:07:41,440
を追加する方法、ドラッグ・アンド・ドロップを追加する方法、そしてすべてが適切に機能するようにする方法を学ぶのは、とても興味深いことでしょう。

71
00:07:41,440 --> 00:07:47,040
を追加する方法を学ぶことができます。このような作業体験は、好きなだけ追加することができます。次のタブは

72
00:07:47,040 --> 00:07:53,120
職歴タブとよく似ていますが、ここでは会社ではなく、学校です。

73
00:07:53,120 --> 00:07:58,080
会社、学校、そして説明はありません。ですからここでは、例えば次のように書くことができます。

74
00:07:58,080 --> 00:08:07,600
例えば、「Master of science whatever」（科学修士）と書いて、学校名を
「University of blah blah」（大学名）と入力します。ここでは

75
00:08:07,600 --> 00:08:12,480
AI機能は必要ないと思ったからです。

76
00:08:12,480 --> 00:08:17,840
しかしもちろん、職務経験タブで使っているのと同じコードを使って、教育タブにもAIを実装することができます。

77
00:08:17,840 --> 00:08:28,400
AIを実装することができます。開始日は2020年で、ランダムに選んでください。

78
00:08:28,400 --> 00:08:35,120
この変更も自動的に保存されるので、いつでもレジュメの概要ページに戻ることができます。

79
00:08:35,120 --> 00:08:41,040
このレジュメはいつでも元の状態で見ることができます。保存ボタンをクリックする必要はありません。

80
00:08:41,040 --> 00:08:49,680
自動的に保存されます。さらに学歴を追加することもできます。次にスキルタブです。ここでは

81
00:08:49,680 --> 00:08:58,160
をコンマで区切って追加することができる。

82
00:08:58,160 --> 00:09:03,600
と入力すると、すべてのスキルがこの小さなタグとして追加されます。

83
00:09:03,600 --> 00:09:09,280
区切り線も自動的に追加されます。この2つのボタンにお気づきでしょうか？

84
00:09:09,280 --> 00:09:15,600
レジュメをさらにカスタマイズできます。例えば、ここで主要なテキストの色を変えることができます。例えば

85
00:09:15,600 --> 00:09:22,800
また、このボタンで枠線の半径を切り替えることができます。

86
00:09:22,800 --> 00:09:28,560
を切り替えることができます。そしてこのボタンで境界線の半径を切り替えることができます。

87
00:09:28,560 --> 00:09:35,120
この画像だけでなく、この下にあるスキルタグにも適用されます。

88
00:09:35,120 --> 00:09:41,360
ボタンで変更できます。今は長方形で、スキルも長方形です。

89
00:09:41,360 --> 00:09:47,760
この2つはプレミアム機能です。

90
00:09:47,760 --> 00:09:53,920
この2つはプレミアム機能なので、Stripeのサブスクリプションを購入してアンロックする必要があります。私たちは

91
00:09:53,920 --> 00:09:59,040
AI機能もサブスクリプションの後ろにあります。

92
00:09:59,040 --> 00:10:05,840
Stripeを導入することで、様々な機能をロックしたり解除したりする方法をご紹介します。フォームの最後のステップはサマリーです。

93
00:10:05,840 --> 00:10:10,800
というのも、このプロフェッショナル・サマリーは、私たち自身が書いたものだからです。

94
00:10:10,800 --> 00:10:16,080
しかし、フォームの最後のステップとしたのは、AIを使ってこれを生成することもできるからです。

95
00:10:16,080 --> 00:10:21,840
を使えば、自動的に他の入力も考慮に入れてくれるからです。これまで追加したものすべて

96
00:10:21,840 --> 00:10:27,120
このボタンをクリックすると、これまで追加したすべてが考慮されます。生成すると

97
00:10:27,120 --> 00:10:31,840
このプロフェッショナル・サマリーが生成され、私がフルスタック開発者であることがわかります。

98
00:10:31,840 --> 00:10:37,680
ということがわかります。私がCoding & Flowで働いていることも、私が

99
00:10:37,680 --> 00:10:43,200
マクドナルドで働いたことも知っている。実にクールな機能だ。

100
00:10:43,200 --> 00:10:49,200
この履歴書を印刷することもできます。履歴書の概要ページでは、もちろん履歴書を削除することもできます。

101
00:10:49,200 --> 00:10:56,000
印刷することもできます。履歴書は

102
00:10:56,000 --> 00:11:02,480
エディターのプレビューとまったく同じです。

103
00:11:02,480 --> 00:11:09,920
自動的にスマートな改行が追加されます。例えば、これは2ページを超える大きな履歴書です。

104
00:11:09,920 --> 00:11:15,840
しかし、デフォルトではこのページにスキルのテキストが配置されます。

105
00:11:15,840 --> 00:11:21,360
次のページにスキルのテキストを配置することになり、見た目が悪くなります。改行を入れたくない場所があります。

106
00:11:21,360 --> 00:11:26,640
改行を入れたくない場所があります。これが

107
00:11:26,640 --> 00:11:32,640
この見出しスキルは、スキルテキストと同じページに配置されます。また、例えば次のような改行もしません。

108
00:11:32,640 --> 00:11:37,840
仕事体験を真ん中に置く。そうすることで、仕事体験全体が常に同じページになる。

109
00:11:37,840 --> 00:11:43,200
例えば、ハンバーガーを揚げているところを1ページにして、次のページにその説明を書くようなことはできません。

110
00:11:43,200 --> 00:11:49,440
とはなりません。ですから、私たちはプロフェッショナルな方法でこれを実施します。課金ページでは

111
00:11:49,440 --> 00:11:55,600
現在のStripeのサブスクリプションを見ることができます。このアカウントでは、履歴書ビルダーAI
Pro Plusの月額プランを契約しています。

112
00:11:55,600 --> 00:12:01,600
の月額プランを利用しています。そのため、カスタマイズ機能やAI機能を利用することができます。私たちは

113
00:12:01,600 --> 00:12:08,320
このボタンをクリックすると、Stripeカスタマーポータルに移動します。ここで

114
00:12:08,320 --> 00:12:16,080
ここで様々なことができます。例えば、月額Pro Plusから月額Pro
Plusに変更することができます。

115
00:12:16,080 --> 00:12:22,640
monthlyに変更することができます。試してみましょう。

116
00:12:22,640 --> 00:12:29,680
このボタンをクリックします。

117
00:12:29,680 --> 00:12:35,920
Stripeに実際のお金を支払う必要はありません。Stripeが提供する偽のカードを使うことができます。

118
00:12:35,920 --> 00:12:43,200
4242番号を使って、支払いをシミュレートできます。ここで支払いを行うと、実際には支払いは行われず

119
00:12:43,200 --> 00:12:51,520
偽の決済を行うだけです。この確認ボタンをクリックして、アプリケーションに戻りましょう。

120
00:12:51,520 --> 00:12:59,120
アプリケーションに戻り、請求ページに戻ります。

121
00:12:59,120 --> 00:13:05,600
からPro
monthlyに変わりました。Proアカウントでは、さまざまなオプションが利用できます。例えば通常の

122
00:13:05,600 --> 00:13:12,880
例えば通常のProアカウントでは、履歴書は3つまでしか作成できません。3つ目のレジュメを作成するときは

123
00:13:12,880 --> 00:13:20,640
というのも、3つ以上のリザルトを作成するにはプレミアム・プラス契約が必要だからです。

124
00:13:20,640 --> 00:13:27,280
なぜなら、3つ以上の履歴書を作成するにはプレミアム・プラスの購読が必要だからです。プレミアム

125
00:13:27,280 --> 00:13:33,120
このようなツールが利用できます。もちろん、購読を変更する代わりに

126
00:13:33,120 --> 00:13:38,960
これらの機能が不要になった場合は、解約することもできます。購読をキャンセルしてください。

127
00:13:39,600 --> 00:13:44,400
これはこの終了日にキャンセルされます。

128
00:13:44,400 --> 00:13:52,080
約1ヶ月間。ここでは特に理由はつけません。もう一度アプリケーションに戻ると、今度はこう表示される。

129
00:13:52,080 --> 00:13:57,680
サブスクリプションは12月7日にキャンセルされます。

130
00:13:57,680 --> 00:14:05,920
と表示されます。もし必要であれば、また更新することができます。だから、私は気持ちを切り替えることができる。キャンセルしたくない。

131
00:14:05,920 --> 00:14:13,280
定期購読を更新したい。アプリに戻って、このテキストが消えます。

132
00:14:13,280 --> 00:14:19,600
の文字が消えます。今、私は別のアカウントにいる。

133
00:14:19,600 --> 00:14:24,240
購読は有効ではありません。現在は無料プランです。このように表示されます。

134
00:14:24,240 --> 00:14:30,800
プレミアム購読ボタンをクリックします。プレミアムダイアログと無料アカウントは同じです。

135
00:14:30,800 --> 00:14:36,320
つのレジュメしか作成できません。このボタンをクリックすると、このようなダイアログが表示されます。

136
00:14:36,320 --> 00:14:43,520
カスタマイズやAI機能も使えません。また、カスタマイズやAI機能も使えません。

137
00:14:43,520 --> 00:14:49,280
サブスクリプションを購入することができます。もしサブスクリプションを購入したい場合は、プレミアムかプレミアムのどちらかを選びます。

138
00:14:49,280 --> 00:14:55,600
をプラスする。このボタンをクリックしてください。チェックアウトのページにリダイレクトされました。完全なチェックアウトを試してみましょう。このアカウントの

139
00:14:55,600 --> 00:15:01,920
このアカウントのメールアドレスが自動的に入力されます。これがこの偽ストライプカードです。そして

140
00:15:01,920 --> 00:15:07,680
このボックスにチェックを入れてください。これは変更できます。削除することもできます。でもこれはわざと設定したんだ。

141
00:15:07,680 --> 00:15:16,240
詳しくは後ほど。支払い義務付きで申し込む。それから処理する。このカードは

142
00:15:16,240 --> 00:15:22,080
このカードは保存しない。そして数秒後、自動的に私たちの

143
00:15:22,080 --> 00:15:27,440
ウェブサイトに戻ります。そして、このアカウントもアクティブなサブスクリプションになります。これで完了です。この

144
00:15:27,440 --> 00:15:35,120
チェックマーク。チェックアウトは成功しました。レジュメに進みます。これでプレミアム機能がすべて揃いました

145
00:15:35,120 --> 00:15:41,440
利用できるようになりました。新しい履歴書を作成できます。AI機能も使えます。また、請求ページでは

146
00:15:41,440 --> 00:15:46,240
現在のサブスクリプションが表示されます。変更も可能です。つまり、すべてが機能するのです。すべてが本当に

147
00:15:46,240 --> 00:15:51,840
プロフェッショナルです。認証には、Next.jsや他のフレームワークでよく使われている決済プロバイダ、Clarkを使います。

148
00:15:51,840 --> 00:15:57,840
Next.jsやその他のフレームワークでよく使われている決済プロバイダーです。実装がとても簡単で、たくさんの機能が使えるからです。

149
00:15:57,840 --> 00:16:03,680
が使えるからです。たとえば、ここでアカウントを管理できます。アバターをアップロードできます。アバターをアップロードできる。

150
00:16:03,680 --> 00:16:09,440
二要素認証 ソーシャルアカウント あらゆることができる。クールなのは、すべてが

151
00:16:09,440 --> 00:16:14,880
箱から出してすぐに使えることです。この種のプロジェクトでは、クラークが本当に気に入っている。そして、彼らはまた

152
00:16:14,880 --> 00:16:22,960
このビデオのスポンサーにもなっている。クラークは月間アクティブユーザー数10,000人までは無料です。これはSaaSに最適です。

153
00:16:22,960 --> 00:16:28,640
アプリケーションのようなものだ。なぜなら、多くのユーザーを獲得すれば、通常は多くのお金も稼げるからです。

154
00:16:28,640 --> 00:16:34,240
そして、有料ティアにお金を払うことができる。この有料ティアもかなり安い。だから

155
00:16:34,240 --> 00:16:40,480
月間アクティブユーザーが10,000人を超えると。つまり、登録したばかりのユーザーではありません。彼らは実際に

156
00:16:40,480 --> 00:16:45,760
アプリを積極的に利用しなければならない。そうして初めてカウントされる。そして、有料ティアを獲得しなければならない。しかし、これは

157
00:16:45,760 --> 00:16:52,240
超安い。そしてまた、あなたは箱から出してトン機能を得る。これが私の意見だ。

158
00:16:52,240 --> 00:17:00,720
SaaSアプリに最適な認証ソリューションだと思います。このプロジェクトでは、Next.js
15とClark v6を使用します。

159
00:17:00,720 --> 00:17:06,720
これが現在の最新バージョンです。そしていくつかの変更がありました。というのも、Next.js
15には

160
00:17:06,720 --> 00:17:13,760
というのも、Next.js
15にはいくつかの変更点があったからです。そのため、最新バージョンのClerを実装する方法を学びます。もちろん

161
00:17:13,760 --> 00:17:18,720
もちろんサインアウトできます。フロントページに戻ります。このボタンをクリックすると

162
00:17:18,720 --> 00:17:23,840
アカウントにログインしなければなりません。様々なソーシャル・ログイン・プロバイダーを使うことができる。必要であれば、さらに追加することができます。

163
00:17:23,840 --> 00:17:29,600
あるいは、昔ながらのEメールとパスワードでログインすることもできる。これらはすべて機能する。そして、これらはすべて

164
00:17:29,600 --> 00:17:38,720
実装はとても簡単だ。見てみよう。キャプスロック。履歴書ビルダー15。これが私のパスワードです。

165
00:17:38,720 --> 00:17:47,280
よし。これでよし。アカウントに戻りました。これはかなりクールなプロジェクトだと思います。そして最後に

166
00:17:47,280 --> 00:17:51,760
最後に、私たちのウェブサイトを本番環境で使えるように、すべてを本番環境にデプロイします。

167
00:17:51,760 --> 00:17:58,880
をインターネット上で使えるようにします。まとめとして。テクノロジーとしては、最新の安定版であるNext.js
15を使います。

168
00:17:58,880 --> 00:18:05,600
バージョンを使用します。データベースにはPostgresを使い、ORMにはPrismaを使います。なぜなら

169
00:18:05,600 --> 00:18:11,600
Prismaが好きだからです。プロフィールの画像はZalbLobストレージに保存します。

170
00:18:11,600 --> 00:18:17,680
に保存します。もちろん、Stripeを実装し、Webhooksを使った自動フルフィルメント処理も学びます。

171
00:18:17,680 --> 00:18:22,800
もちろんStripeを導入し、Webhooksを使った自動配信の処理方法も学びます。

172
00:18:22,800 --> 00:18:30,000
購読を管理できるようにします。AI機能にはOpenAIのchat-gbt
APIを使います。スタイリングには

173
00:18:30,000 --> 00:18:37,760
Tewin
CSSとchat-cn-uiコンポーネントを使います。また、React-hookフォームも使います。そして、この並び替え機能には

174
00:18:37,760 --> 00:18:43,920
機能には、ドラッグ・アンド・ドロップ・ライブラリのdndkitを使います。そして、グローバルダイアログには

175
00:18:43,920 --> 00:18:49,600
プレミアム購読を購入できるようにするために、状態管理ライブラリのZustandを使います。

176
00:18:49,600 --> 00:18:55,440
を使います。このプロジェクトではZustandはあまり使いませんが、このグローバル・ダイアログでは使います。

177
00:18:55,440 --> 00:19:00,400
のために使います。その他にもたくさんのライブラリがあります。

178
00:19:00,400 --> 00:19:05,600
ここで使います。BSのコードも一緒にセットアップして、異なるライブラリーを効率的に使えるようにします。

179
00:19:05,600 --> 00:19:10,800
BSコードのセットアップも一緒に行います。例えば、Pridiaをインストールします。

180
00:19:10,800 --> 00:19:16,560
Prismaなどの作業を容易にする拡張機能の数々をインストールします。これらすべてを

181
00:19:16,560 --> 00:19:22,800
をセットアップします。このチュートリアルの唯一の前提条件は、Next.jsの基本を理解していることです。

182
00:19:22,800 --> 00:19:29,360
とアプリルーターの基本を知っていることです。Next.js
13の初心者向けチュートリアルがありますので、そちらをご覧ください。

183
00:19:29,360 --> 00:19:36,640
今すぐNext.jsに必要な基本的なことがすべてわかります。13と15の間には、いくつかの小さな変更があります。

184
00:19:36,640 --> 00:19:41,920
と15で少し変更がありますが、大部分は同じです。このビデオの右上に、このチュートリアルへのリンクを貼っておきます。

185
00:19:41,920 --> 00:19:47,280
にリンクを貼っておきます。Next.jsの経験がない場合は、まずこのチュートリアルをご覧ください。

186
00:19:47,280 --> 00:19:52,800
を見てから、このチュートリアルに戻ってください。しかし、Reactの基本的なことしか知らないのであれば、このチュートリアルに従うだけでも十分でしょう。

187
00:19:52,800 --> 00:19:58,800
このチュートリアルでは、Next.jsの基本をすべて説明しません。

188
00:19:58,800 --> 00:20:03,760
このチュートリアルではNext.jsの基本的なことは説明しません。チュートリアルを始める前に、もうひとつ説明しておきたいことがあります。

189
00:20:03,760 --> 00:20:11,120
codingandflow.com/reactbestpracticesに無料のReactベストプラクティスコースがあります。

190
00:20:11,120 --> 00:20:15,760
これは私の購読者のために作った無料のビデオコースで、このビデオコースを手に入れると

191
00:20:15,760 --> 00:20:21,600
を手に入れると、私のメールマガジンにも登録されます。このニュースレターに参加することをお勧めします。

192
00:20:21,600 --> 00:20:27,280
このメールマガジンでは、2週間に1回、私が学んだ新しいことをメールに書いています。通常、トピックは

193
00:20:27,280 --> 00:20:32,960
ReactやNext.jsが好きなら、このニュースレターも気に入ると思います。

194
00:20:32,960 --> 00:20:37,840
スパムを送ることはありませんし、もちろんいつでも購読を解除することができます。繰り返しになりますが

195
00:20:37,840 --> 00:20:45,920
codingandflow.com/reactbestpracticesにアクセスして、このニュースレターに参加し、無料のReactベストプラクティス・コースを入手してください。

196
00:20:45,920 --> 00:20:50,320
リンクは下のビデオの説明にもあります。参加していただけると本当に嬉しいです。

197
00:20:50,320 --> 00:20:56,960
それでは、このチュートリアルを始めましょう。さて、パーティーの皆さん。まず最初に

198
00:20:56,960 --> 00:21:02,800
少なくともNode.js
20が必要なコードもあるので、少なくともNode20がインストールされている必要がある。

199
00:21:02,800 --> 00:21:08,560
Node.js
20以上が必要なコードがあるからだ。WindowsでPowerShellのターミナルを開き、node-vでバージョンを確認することができます。

200
00:21:08,560 --> 00:21:18,640
node-vでバージョンを確認すると、20.17がインストールされている。少なくとも

201
00:21:18,640 --> 00:21:26,320
20でなければならない。もしこれより低かったら、nodejs.orgに行って最新のLTSバージョンをインストールしてください。

202
00:21:26,320 --> 00:21:34,160
今は22のようですが、私は怠け者なので20のままにしています。それからいつものように

203
00:21:34,160 --> 00:21:40,000
このチュートリアルのスタートコードを提供します。スターティング・コードの利点は、私がすでにすべてのパッケージをインストールしていることだ。

204
00:21:40,000 --> 00:21:47,280
で使っているのと同じバージョン番号を使うことができるということです。

205
00:21:47,280 --> 00:21:53,120
このチュートリアルと同じバージョン番号を使うことができます。これは便利です。

206
00:21:53,120 --> 00:21:59,280
このチュートリアルを見ている人が1年後、2年後にバージョン番号が変わっていて

207
00:21:59,280 --> 00:22:04,000
というのも、このチュートリアルを1年後、2年後に見たときに、バージョン番号が変わっていて、そのバージョン番号の変更によって動作が変わっていることがあるからです。

208
00:22:04,000 --> 00:22:08,880
涙を呑むことになる。だから、私のスタートコードをダウンロードし、パッケージをインストールすれば、あなたは私と同じバージョン番号を持つことになる。

209
00:22:08,880 --> 00:22:14,480
同じバージョン番号になる。スタート

210
00:22:14,480 --> 00:22:19,600
コードには、あなたが始めるために必要な他のすべてが含まれています。例えば

211
00:22:19,600 --> 00:22:25,600
例えば、私が作成したレジュメビルダーのロゴなどです。この

212
00:22:25,600 --> 00:22:30,800
を使う必要はありません。また、ゼロからすべてをセットアップする方法も紹介します。

213
00:22:30,800 --> 00:22:35,120
あなたが必要とするこれらの異なるファイル。しかし、開始コードを使用することで、同じバージョン番号を使用することができます。

214
00:22:35,120 --> 00:22:40,320
同じバージョン番号を使うことになる。スターティング・コードのリポジトリへのリンクは、以下のビデオの説明にあります。

215
00:22:40,320 --> 00:22:46,480
にあります。このリポジトリではありません。それは私がすぐに設定する新しいものです。あなたは

216
00:22:46,480 --> 00:22:51,040
リンクはビデオの説明にあります。

217
00:22:51,040 --> 00:22:57,360
原始人のようにzip形式でダウンロードすることもできます。お好きな方をどうぞ。それを

218
00:22:57,360 --> 00:23:04,960
をコンピューターに取り込み、VS Codeで開いてください。メインのブランチが開始コードになり、私が

219
00:23:04,960 --> 00:23:10,160
このチュートリアルのさまざまな部分のために追加のブランチを追加します。そしてその中に

220
00:23:10,160 --> 00:23:15,600
package.jsonに、さまざまな依存関係、さまざまなパッケージがあります。しかし

221
00:23:15,600 --> 00:23:22,160
インストールしなければなりません。ターミナルを開いてインストールします。ターミナルを表示するか、このショートカットを使う。

222
00:23:22,160 --> 00:23:29,040
npmiでパッケージをインストールする。そして

223
00:23:29,040 --> 00:23:38,000
legacy-peer-devsというフラグを追加する。スペルを間違えないように。それから次のコマンドを実行する

224
00:23:38,000 --> 00:23:44,320
これですべてのパッケージがインストールされる。レガシー・ピアデバイスが必要なのは、Next.js
15

225
00:23:44,320 --> 00:23:49,360
は他のいくつかのパッケージとまだ完全な互換性がないので、このフラグが必要なのです。

226
00:23:49,360 --> 00:23:55,920
が正しく動作するようにします。このステップに従えば、私と同じパッケージがインストールされ

227
00:23:55,920 --> 00:24:00,800
すべてまったく同じように動作するはずです。しかし、勇気のある方は、Next.js
15の開始パッケージである

228
00:24:00,800 --> 00:24:05,840
コード このプロジェクトをゼロからセットアップする方法も紹介しよう。しかし、もし

229
00:24:05,840 --> 00:24:11,200
しかし、もしこれらのパッケージの変更があった場合、その変更をどのように実装するかは自分で考えなければならない。

230
00:24:11,200 --> 00:24:17,920
を自分で考えなければならない。しかし、あなたは大きな男の子か女の子なので、あなたならそれができると信じています。どの道を選ぶかは

231
00:24:17,920 --> 00:24:24,560
を取るかはあなた次第です。同じプロジェクトをゼロからセットアップする方法をお見せしよう。もし

232
00:24:24,560 --> 00:24:30,560
開始コードをダウンロードしていない場合は、新しいプロジェクトを置くフォルダに移動します。

233
00:24:30,560 --> 00:24:37,280
ここでは、このvs code
projectsフォルダに入れます。それからターミナルを開く。ウィンドウズの場合は

234
00:24:37,280 --> 00:24:43,600
シフトを押しながら右クリックする。そしてpowershellウィンドウを開くをクリックします。

235
00:24:43,600 --> 00:24:50,560
ウィンドウズの設定によっては、ここでコマンドラインを開くこともできます。しかし、ここでは

236
00:24:50,560 --> 00:25:02,800
コマンドラインを開きます。そしてnpx create -next -app
@latestと入力する。

237
00:25:02,800 --> 00:25:09,600
next.jsアプリが生成される。wireで確認し、いくつかの質問に答えなければならない。

238
00:25:09,600 --> 00:25:19,680
プロジェクト名は？例えばnext.js 15 AI resume builderとしよう。もちろん

239
00:25:19,680 --> 00:25:26,800
を好きなように呼んでください。入力してください。typescriptを使いますか？もちろんです。

240
00:25:26,800 --> 00:25:34,640
のユーザーは狂人ですから。eslintとtaewindcssも使いたい。そして、このsrz

241
00:25:34,640 --> 00:25:40,960
ディレクトリを使いたい。そしてとても重要なのがアプリ・ルーターだ。そうだ。TurboPack......いや、これは使ったことがない。

242
00:25:40,960 --> 00:25:46,560
を使ったことがない。まだ実験段階だと思う。そして、絶望と絶望を避けるために、私は次のことをしたい。

243
00:25:46,560 --> 00:25:53,520
ターボパックは使用せず、安定するまで待ちましょう。また

244
00:25:53,520 --> 00:26:00,880
インポートエイリアスをカスタマイズしたくない。だから「いいえ」を選択する。数秒後、新しいnext.jsプロジェクトがセットアップされる。

245
00:26:00,880 --> 00:26:08,880
新しいnext.jsプロジェクトが立ち上がる。完了したら、ターミナルを閉じよう。

246
00:26:08,880 --> 00:26:17,040
このプロジェクトを開くことができる。プロジェクトはここにあります。VS
Codeで開く。匂いを嗅いでみてください。

247
00:26:17,040 --> 00:26:23,760
この匂い？新しいnext.jsプロジェクトの匂いだ。そして、これは箱から出してすぐに使える。そして、これはすぐに使える。

248
00:26:23,760 --> 00:26:33,600
npm run dev. そして、localhost
3000でこの不良少年を開くことができる。すると

249
00:26:33,600 --> 00:26:39,760
とても印象的なフロントページが表示される。基本的にはこれで終わり。後で、ここにウェブサイトを設置する。

250
00:26:40,880 --> 00:26:49,360
ctrl+zでこのlocalhostを停止しよう。これは新しいプロジェクトなので

251
00:26:49,360 --> 00:26:54,080
をインストールしなければならない。それでは

252
00:26:54,080 --> 00:26:59,760
をひとつずつ手動でインストールしなければならない。もう一度ターミナルで npm i
と入力する。そして

253
00:26:59,760 --> 00:27:04,880
これらの異なるパッケージを追加する。スペルを間違えないように。たくさんのパッケージがあります。

254
00:27:04,880 --> 00:27:12,880
ORMとしてprismaを使いたい。そこでprisma spaceと入力し、prisma slash
clientを追加する。

255
00:27:12,880 --> 00:27:19,840
ZBlobを追加する。これはファイルの保存に使うブロブ・ストレージだ。

256
00:27:19,840 --> 00:27:30,560
OpenAIはチャットgpt apiのパッケージだ。次に、add t3 minus ossを使う。

257
00:27:31,280 --> 00:27:37,760
スラッシュenvマイナスnextjs。ここでもスペルを間違えないように。このパッケージについては後で詳しく説明する。

258
00:27:37,760 --> 00:27:46,000
日付のフォーマットにはdate fnsも使います。ダークモードとライトモードにはnext
themesを使います。

259
00:27:46,000 --> 00:27:52,560
React minus colorは、履歴書をカスタマイズするためのカラーピッカーです。

260
00:27:52,560 --> 00:28:00,560
React to printは印刷ライブラリです。それから、dndマイナスキットを追加します。

261
00:28:01,520 --> 00:28:08,720
スラッシュコアのdnd kitはドラッグ＆ドロップによる並べ替えに使います。それから、dnd

262
00:28:08,720 --> 00:28:19,920
minus kit slash sortableを追加します。そしてもういくつか。dnd minus
kit slash modifiersを追加します。

263
00:28:19,920 --> 00:28:27,920
次はストライプライブラリ。グローバルダイアログ用のZustand。それから

264
00:28:27,920 --> 00:28:38,560
clerk。clerk slash nextjsを追加する。そして最後にclerk slash
themesを追加する。スペル

265
00:28:38,560 --> 00:28:45,440
のスペルが正しいことを確認してください。そして重要なのは、このダッシュ・ダッシュ・レガシー・マイナス・ピア（dash
dash legacy minus peer）を追加することだ。

266
00:28:45,440 --> 00:28:52,320
マイナスdepthフラグ。そうしないとインストールに失敗するかもしれない。ただし、この

267
00:28:52,320 --> 00:28:57,280
にもよります。まずはlegacy peer
depthなしで試してみてください。そして、すべてがうまくいったら

268
00:28:57,280 --> 00:29:03,280
必要なくなります。しかし、現時点ではnextjs
15はまだ新しいので、このフラグを追加しなければなりません。

269
00:29:03,280 --> 00:29:08,560
そして、私はそれが害にならないと思う。だから、たとえそれが必要なくても、それを追加することができる。

270
00:29:08,560 --> 00:29:14,240
同じように動くはずです。では、すべてのスペルが正しいことを確認してください。

271
00:29:14,240 --> 00:29:19,360
Enterキーで確定します。そして数秒後に、これらすべての

272
00:29:19,360 --> 00:29:27,280
パッケージがpackage.jsonファイルにインストールされます。インストールが完了したら、依存関係ブロックにこれらのパッケージが表示されます。

273
00:29:27,280 --> 00:29:33,440
依存関係ブロックに表示されているはずだ。いくつかのdev依存パッケージも必要です。

274
00:29:33,440 --> 00:29:39,280
開発でのみ使用され、本番では使用されないパッケージです。そのため、ここに別のブロックがあります。ではもう一度

275
00:29:39,280 --> 00:29:48,720
ターミナルを開く。Npmiから大文字のdを引いて、dev dependenciesを表す。そして

276
00:29:48,720 --> 00:29:58,560
さらにいくつかのパッケージがある。tailwindcssスラッシュ組版を追加する。

277
00:29:58,560 --> 00:30:06,560
reactからcolorを引いたtypesスラッシュを追加。

278
00:30:06,560 --> 00:30:17,360
次にprettierを追加する。prettierマイナスpluginマイナスtailwindcss。詳しくは後述する。

279
00:30:18,320 --> 00:30:24,000
そしてeslintからconfigを引いてprettierを引く。これで全部だ。そしてまた

280
00:30:24,000 --> 00:30:31,120
legacy_peer_devsフラグが必要です。ここでもスペルが正しいことを確認してください。エンターキーを押して

281
00:30:31,120 --> 00:30:38,880
インストールされるまで待つ。そして、このdev
dependenciesブロックの中にある。オーケー。

282
00:30:38,880 --> 00:30:44,480
ウェブサイトのデザインにはshadzyとUIコンポーネントを使うことにします。

283
00:30:44,480 --> 00:30:51,040
私のようなデザイン・スキルがゼロでも、shadzy-nは箱から出してすぐに素敵に見えるからです。

284
00:30:51,040 --> 00:30:57,680
というのも、私はデザインがとても苦手だからです。Shadzy-nは、reactとnextjsのための最も人気のあるコンポーネントライブラリの一つです。

285
00:30:57,680 --> 00:31:02,720
このライブラリのクールなところは、パッケージとしてインストールしないことだ。その代わり

286
00:31:02,720 --> 00:31:08,720
基本的に、必要なコンポーネントをプロジェクトにコピーペーストする。

287
00:31:08,720 --> 00:31:14,080
もちろん、これによってコードを完全にコントロールできる。

288
00:31:14,080 --> 00:31:19,520
他のコンポーネント・パッケージでは、パッケージをアップデートしたら、突然ウェブサイトの見た目が変わってしまったという問題がよくあります。

289
00:31:19,520 --> 00:31:25,040
例えば、デフォルトのボーダーの半径が変更されてしまうからです。

290
00:31:25,040 --> 00:31:32,800
なぜなら、これらのコンポーネントのコードはあなたのプロジェクトの中にあり、あなたがそれを変更したい場合だけだからです。

291
00:31:32,800 --> 00:31:39,760
を実際に変更してみましょう。それではshadzy-n
UIをインストールして、必要なコンポーネントを追加してみよう。

292
00:31:39,760 --> 00:31:45,520
すでにすべてのコンポーネントをスタート・コードに追加してあるので、スタート・プロジェクトをダウンロードした人はこの手順を踏む必要はない。

293
00:31:45,520 --> 00:31:51,200
をダウンロードした場合は、この手順を踏む必要はない。

294
00:31:51,200 --> 00:32:00,160
ターミナルでnpx shadzy-nと入力する。

295
00:32:00,160 --> 00:32:12,640
このように 「at latest init 」と入力する。

296
00:32:12,640 --> 00:32:17,680
ニューヨークスタイルを使いたいが、デフォルトでも構わない。

297
00:32:17,680 --> 00:32:24,560
どの色をベースカラーとしてニュートラルにするか？

298
00:32:24,560 --> 00:32:31,680
ここで「はい」を選択し、ここで「レガシーpdfを使用する」を選択しなければなりません。

299
00:32:31,680 --> 00:32:37,360
を選択すると、新しいファイルが追加されます。

300
00:32:37,360 --> 00:32:47,440
すると新しいファイルやパッケージが追加されます。

301
00:32:47,440 --> 00:32:55,120
これは基本的にshadzy-nの設定ファイルです。

302
00:32:55,120 --> 00:33:02,480
コンポーネントはまだないので、ボタンやダイアログなどはまだありません。

303
00:33:02,480 --> 00:33:08,400
shadzy-nのウェブサイトから直接コピーペーストするか、あるいは

304
00:33:08,400 --> 00:33:17,440
別のコマンドで追加することもできる。

305
00:33:17,440 --> 00:33:22,640
追加したいコンポーネントの名前をすべて追加する。

306
00:33:22,640 --> 00:33:28,800
を正しく綴るために、そして念のため、これらすべての異なるコンポーネントをここで見つけることができます。

307
00:33:28,800 --> 00:33:34,480
shadzy-nのドキュメントにある。例えば、ボタンをインストールしたいとしよう。

308
00:33:34,480 --> 00:33:47,600
コマンド shadzy-n add button すべてを追加してみよう。

309
00:33:47,600 --> 00:33:59,840
ボタンが必要 カードダイアログのドロップダウンメニューが必要

310
00:34:01,600 --> 00:34:09,680
フォーム入力ラベルとポップオーバーとあと2つのテキストエリアが必要だ。

311
00:34:09,680 --> 00:34:20,560
とトーストをここに追加し、Enterで確定する。

312
00:34:20,560 --> 00:34:29,680
プロジェクトにこれらのコンポーネントと必要なパッケージが追加されます。

313
00:34:29,680 --> 00:34:36,880
レガシーピアdebsを選択する必要があります。

314
00:34:36,880 --> 00:34:44,000
srzフォルダーの中にあるcomponentsフォルダーと、uiフォルダー、そしてここにあるさまざまな

315
00:34:44,000 --> 00:34:50,640
インストールしたばかりのshadzy-nコンポーネントがあります。

316
00:34:50,640 --> 00:34:58,160
コードに変更を加えることができ、後でアップデートに驚かされることもない。

317
00:34:58,160 --> 00:35:05,120
reddixパッケージのような新しいパッケージもたくさんインストールされた。

318
00:35:05,120 --> 00:35:12,320
また、shadzy-nの見た目をカスタマイズすることもできる。

319
00:35:12,320 --> 00:35:19,520
メニュー・オプションがあり、ここでカスタマイズをクリックすると、原色を変更できる。

320
00:35:19,520 --> 00:35:26,400
ダークモードとライトモードでの見え方を見ることができます。

321
00:35:26,400 --> 00:35:32,320
テーマを設定したら、コピーコードをクリックして、この部分をコピーしてください。

322
00:35:32,320 --> 00:35:40,720
デフォルトのテーマはこれをすべてコピーし、これをグローバルCSSファイルに入れるだけだ。

323
00:35:40,720 --> 00:35:46,640
そして、この部分をレイヤーベースに置き換える。

324
00:35:46,640 --> 00:35:53,280
このダーク・ブロックの部分だけコピーしたものに置き換えれば、カスタム・カラーが完成する。

325
00:35:53,280 --> 00:35:59,120
しかし、このチュートリアルのために、私はすでにテーマを用意しました。

326
00:35:59,120 --> 00:36:05,360
自分のテーマを設定してもいいし、私のテーマを使ってもいいし、デフォルトのテーマのままでもいい。

327
00:36:05,360 --> 00:36:13,120
そして、私はすでにこれを開始コードに追加しました。

328
00:36:13,120 --> 00:36:18,960
次に、shadzy-n経由でインストールした入力コンポーネントに入ると、エラーが発生します。

329
00:36:18,960 --> 00:36:23,680
現時点では、将来的にはこのエラーは表示されなくなるでしょう。

330
00:36:23,680 --> 00:36:30,080
next.jsの最新バージョンと現在のshadzy-nのバージョンには互換性の問題があります。

331
00:36:30,080 --> 00:36:38,960
この行の警告を無効にすることで修正できます。

332
00:36:38,960 --> 00:36:47,600
この行の警告を無効にすることで、この問題を解決することができます。

333
00:36:47,600 --> 00:36:51,440
ここでも警告を無効にしたい

334
00:36:51,440 --> 00:36:59,200
タンジェント設定ファイルにもう一つ警告があります。

335
00:36:59,200 --> 00:37:05,120
この警告は将来修正されるかもしれないが、もしまた現れたら、この行の警告を無効にしなければならない。

336
00:37:06,080 --> 00:37:13,680
そしてエクスプローラーでs-codeのsrzフォルダに移動し、ここで

337
00:37:13,680 --> 00:37:20,320
assetsという新しいフォルダーを作り、プロジェクトで必要な画像を入れる。

338
00:37:20,320 --> 00:37:28,000
このロゴと履歴書のプレビューの2つのファイルをフロントページに置きたい。

339
00:37:28,000 --> 00:37:33,600
プロジェクトをゼロからセットアップする場合、この2つのファイルへのリンクを

340
00:37:33,600 --> 00:37:40,000
ダウンロード・ボタンからダウンロードしてください。

341
00:37:40,000 --> 00:37:45,520
この2つのファイルを切り取り、assetsフォルダに入れます。

342
00:37:45,520 --> 00:37:53,680
プロジェクトで使えるように、2つ以上のファイルが必要です。

343
00:37:53,680 --> 00:37:59,840
タブやグーグル検索で表示されるアイコンです。

344
00:37:59,840 --> 00:38:05,200
のプレビュー画像です。

345
00:38:05,200 --> 00:38:14,400
この2つのファイルをダウンロードして、プロジェクトに入れます。

346
00:38:14,400 --> 00:38:20,960
assetsフォルダには入れず、appフォルダに入れます。

347
00:38:20,960 --> 00:38:28,480
このファイルを削除し、代わりにこのfufアイコンを直接appフォルダに入れます。

348
00:38:30,080 --> 00:38:34,800
オープングラフの画像も同じようにappフォルダに入れます。

349
00:38:34,800 --> 00:38:40,240
next.jsはこのファイルを

350
00:38:40,240 --> 00:38:46,320
next.jsはこれをオープングラフ画像としてしか認識しないからだ。

351
00:38:46,320 --> 00:38:53,040
次に、このpublicフォルダを削除する。

352
00:38:53,040 --> 00:39:00,000
そしてsrzアプリの中にあるfontsフォルダも同じように削除する。

353
00:39:00,000 --> 00:39:06,720
アプリの中にあるfontsフォルダも同じように削除します。ここではこの2つのフォントは必要ないので、fontsフォルダごと削除します。

354
00:39:06,720 --> 00:39:14,640
そして、appフォルダにあるlayout.tsxファイルを開き、まず、次のように変更します。

355
00:39:14,640 --> 00:39:23,120
このインポートを次のフォントスラッシュgoogleに変更します。

356
00:39:23,120 --> 00:39:30,320
このガイスト・フォントは使いたくないので、この部分を削除します。

357
00:39:30,320 --> 00:39:38,960
そしてimportsの下に小文字のiでconst
interを作成し、このinterコンストラクタを呼び出します。

358
00:39:38,960 --> 00:39:46,240
大文字のiを括弧で囲み、中括弧で囲みます。

359
00:39:46,240 --> 00:39:54,720
latinを配列で囲み、使用する文字を定義します。

360
00:39:54,720 --> 00:40:01,760
このクラス名をインタードットクラス名に置き換えて、このインターフォントを

361
00:40:01,760 --> 00:40:06,880
これで、このインターフォントがウェブサイト全体に適用されたことになる。

362
00:40:07,520 --> 00:40:14,160
このimport文の中にあるのですが、ここではinterを使いたいので、デフォルトのtiを変更することもできます。

363
00:40:14,160 --> 00:40:20,800
ソーシャルメディアに表示されるデフォルトのタイトルと説明を変更することもできます。

364
00:40:20,800 --> 00:40:26,320
タイトルの文字列を削除して、代わりにここにオブジェクトを追加しましょう。

365
00:40:26,320 --> 00:40:33,760
このようなテンプレートを使用することができます。

366
00:40:34,640 --> 00:40:47,680
そして、absoluteをai resume builderに設定します。

367
00:40:47,680 --> 00:40:53,760
フロントページにはこのタイトルが表示されますが、サブページには独自のタイトルが表示されます。

368
00:40:53,760 --> 00:40:59,520
サブページのタイトルがこのプレースホルダーに入ります。

369
00:40:59,520 --> 00:41:05,680
ブラウザのタブでこのように表示されるので、さっそく試してみよう。

370
00:41:05,680 --> 00:41:15,360
npm run devを実行し、localhost
3000でウェブサイトを開くと、このようなタイトルが表示されます。

371
00:41:15,360 --> 00:41:21,440
ai resume
builderと表示され、例えば請求書発行のようなサブページがあると、次のように表示されます。

372
00:41:21,440 --> 00:41:28,320
billing dash ai resume builder と表示されます。

373
00:41:28,320 --> 00:41:39,600
説明文もai resume builderに変更してみましょう。

374
00:41:39,600 --> 00:41:49,440
もちろん、どんなことを書いてもかまいません。

375
00:41:49,440 --> 00:41:58,240
これは単なるマーケティング用のテキストです。

376
00:41:58,240 --> 00:42:03,280
実際にコーディングを始める準備はほぼできている。

377
00:42:03,280 --> 00:42:10,400
をインストールすることをお勧めします。

378
00:42:10,400 --> 00:42:16,720
taewin css intelligence extension を使ってみましょう。

379
00:42:16,720 --> 00:42:21,920
というのも、Taewinのクラスのオートコンプリートを追加してくれるからだ。

380
00:42:21,920 --> 00:42:28,320
Taewinの公式プラグインなので、安全で事故の心配もありません。

381
00:42:28,320 --> 00:42:34,800
うっかりウィルスをインストールしてしまう心配もない。

382
00:42:34,800 --> 00:42:45,520
このプラグインを適切に設定する必要があります。

383
00:42:46,160 --> 00:42:57,040
この設定を選択し、ファイルの関連付けを検索する。

384
00:42:57,040 --> 00:43:04,240
このファイルの関連付けを追加するには、アスタリスクドットのCSSをアクティブに入力するキーの項目を追加]をクリックします。

385
00:43:04,240 --> 00:43:11,920
これはcssファイル用で、値は小文字でtaewin
cssとすると、このtaewin拡張子が有効になります。

386
00:43:11,920 --> 00:43:18,880
cssファイルにこのtaewinエクステンションを有効にすることで、通常では得られないヘルプを得ることができます。

387
00:43:18,880 --> 00:43:27,440
エディタークイック提案と呼ばれるこの設定は、文字列の値が

388
00:43:27,440 --> 00:43:35,040
をオンにして、クラス名の文字列をオートコンプリートできるようにします。

389
00:43:35,040 --> 00:43:40,080
パッケージをインストールしたときに、prettierもインストールした。

390
00:43:40,080 --> 00:43:45,600
を使う心配がなくなるので、とても気に入っている。

391
00:43:45,600 --> 00:43:52,000
一重引用符や二重引用符の使い方、セミコロンの有無、改行位置などを気にする必要がない。

392
00:43:52,000 --> 00:43:57,520
その代わり、重要なことに集中できる。

393
00:43:57,520 --> 00:44:03,120
ボタンにどんな色を使おうかとか、ランチに何を食べようかとか。

394
00:44:03,120 --> 00:44:08,160
をインストール済みだが、デフォルトではprettierをコマンドラインで実行するようになっている。

395
00:44:08,160 --> 00:44:14,320
その代わりに、prettierの拡張機能をインストールすることもできる。

396
00:44:14,320 --> 00:44:20,640
コマンドラインから実行する必要がない。

397
00:44:20,640 --> 00:44:27,200
この拡張機能もインストールすることをお勧めする。

398
00:44:27,200 --> 00:44:35,920
これをデフォルトのフォーマッターにしたい場合は、prettierを選択する。

399
00:44:35,920 --> 00:44:43,920
フォーマットのショートカットは自動的に使用され、フォーマット文書のショートカットはこれです。

400
00:44:43,920 --> 00:44:50,240
私はshift alt fですが、皆さんは違うかもしれません。

401
00:44:50,240 --> 00:44:55,840
をデフォルトに設定すると、自動的にprettierが使用される。

402
00:44:55,840 --> 00:45:02,080
tagwin cssのための特別なprettierプラグインがあります。

403
00:45:02,080 --> 00:45:07,200
この順序は、整理整頓にとても便利です。

404
00:45:07,200 --> 00:45:12,960
というのも、そうしないとクラスがあちこちに存在することになり、非常に混乱してしまうからです。

405
00:45:12,960 --> 00:45:20,320
あとはエクスプローラーでファイルを作成するだけだ。

406
00:45:20,320 --> 00:45:26,080
ルート・フォルダーに直接入れる。

407
00:45:26,880 --> 00:45:34,320
prettierドットconfigドットjsと呼びます。

408
00:45:34,320 --> 00:45:40,800
この正確なコードを、ビデオを見ながら手で入力してください。

409
00:45:40,800 --> 00:45:47,840
eslint rz jsonファイルを開き、ここに3つ目の文字列prettierを追加します。

410
00:45:47,840 --> 00:45:53,840
という文字列を小文字で追加します。

411
00:45:53,840 --> 00:46:00,560
eslintの他のルールとうまく連動するようにします。

412
00:46:00,560 --> 00:46:07,040
prismaエクステンションをインストールすることをお勧めします。

413
00:46:07,040 --> 00:46:12,640
としてprismaを使い、スキーマファイルのようなさまざまなファイルを作成するときに、とても便利だからです。

414
00:46:12,640 --> 00:46:19,040
たとえば、prismaスキーマファイルではシンタックスハイライトや書式設定ができますが、これは

415
00:46:19,040 --> 00:46:23,920
特別な設定は必要ありません。

416
00:46:23,920 --> 00:46:30,400
最後に、eslintエクステンションをインストールすることをお勧めします。

417
00:46:30,400 --> 00:46:36,080
eslintの警告をエディタに直接表示させるために、すべてのプロジェクトでこれを使います。

418
00:46:36,080 --> 00:46:43,040
そして、これは私がgithubにプッシュするスタートコードです。

419
00:46:43,040 --> 00:46:47,920
をダウンロードすれば、これらのコード変更がすべて含まれています。

420
00:46:47,920 --> 00:46:52,320
エクステンションをインストールし、設定する必要があります。

421
00:46:52,320 --> 00:46:57,680
というのも、これは開始コードには含まれていないからです。

422
00:46:57,680 --> 00:47:03,360
このコードをgithubにプッシュする。

423
00:47:03,360 --> 00:47:09,360
だからこれからが本当の楽しみの始まりだ。

424
00:47:09,360 --> 00:47:15,200
もうひとつ、せっかく変更したのだから、ideを再起動することをお勧めする。

425
00:47:15,200 --> 00:47:21,920
をもう一度開くか、ウィンドウの再読み込みコマンドを使って、すべての変更が有効になったことを確認してください。

426
00:47:21,920 --> 00:47:31,200
ターミナルをもう一度開き、npx prisma initを実行する。

427
00:47:31,200 --> 00:47:37,840
新しいprismaフォルダにあるschema dot prismaファイルを作成します。

428
00:47:37,840 --> 00:47:44,080
ここでデータベースに接続し、データベース内のさまざまなテーブルを設定します。

429
00:47:44,080 --> 00:47:50,080
まだデータベースを持っていないので、postgresデータベースを使用します。

430
00:47:50,080 --> 00:47:56,800
というのも、設定が簡単で、後でプロジェクトをここにデプロイするからです。

431
00:47:56,800 --> 00:48:02,480
bezel.comにアクセスしてアカウントを作成してください。

432
00:48:02,480 --> 00:48:09,360
プロジェクトをデプロイするには、ここでストレージをクリックし、無料の

433
00:48:09,360 --> 00:48:16,880
このデータベースはneon.techにあるneonで動いている。

434
00:48:16,880 --> 00:48:23,280
neon.techで見つけることができる。

435
00:48:23,280 --> 00:48:28,800
2つ目は月1ドルかそこらだと思う。

436
00:48:28,800 --> 00:48:36,240
neon.techに別のアカウントを作り、ここに別のデータベースを作ることもできる。

437
00:48:36,240 --> 00:48:43,360
一番簡単なのはZelleで直接設定することだ。

438
00:48:43,360 --> 00:48:49,840
ai履歴書ビルダーDBという名前を付けます。

439
00:48:49,840 --> 00:48:58,000
地域は自分の住んでいる地域に近いものを選びます。

440
00:48:58,000 --> 00:49:03,120
デフォルトのままでもかまいませんが、開発中であれば若干速くなります。

441
00:49:03,120 --> 00:49:10,400
居住地に近い地域を選んだら、createをクリックする。

442
00:49:10,400 --> 00:49:18,000
まずはnth.localをクリックして、環境変数をプロジェクトにコピーします。

443
00:49:18,000 --> 00:49:24,480
をプロジェクトにコピーする。

444
00:49:24,480 --> 00:49:29,680
prismaのinitコマンドでこのファイルが作成されたので、実際にはすでにある。

445
00:49:29,680 --> 00:49:37,600
この.nファイルはデフォルトではgithubにプッシュされません。

446
00:49:37,600 --> 00:49:44,080
というのも、これはgitignoreファイルの一部で、機密性の高い認証情報をリポジトリにプッシュしないようにするためのものだからです。

447
00:49:44,080 --> 00:49:52,400
Zelleに戻ると、prismaの設定も見ることができます。

448
00:49:52,400 --> 00:49:59,760
このスニペットもコピーする必要があります。

449
00:49:59,760 --> 00:50:06,560
スキーマ.prismaファイルにコピーします。

450
00:50:06,560 --> 00:50:14,720
そして、このデータベースをprismaに接続する。

451
00:50:14,720 --> 00:50:20,480
スキーマ.prismaファイルにオートコンプリート、書式設定、シンタックスハイライトがあります。

452
00:50:20,480 --> 00:50:25,840
これをインストールしなければ、ただのプレーンテキストファイルのように見えるだろう。

453
00:50:25,840 --> 00:50:32,080
この拡張機能は本当に便利です。

454
00:50:32,080 --> 00:50:37,680
シンタックスハイライトは本当に便利です。

455
00:50:37,680 --> 00:50:46,880
レジュメと呼ぶモデルを定義します。

456
00:50:46,880 --> 00:50:53,760
大文字のsがついた文字列型で、@ideaアノテーションを追加します。

457
00:50:53,760 --> 00:51:02,720
と@default括弧を追加し、ここでzu_ideaと再び括弧のペアを渡します。

458
00:51:02,720 --> 00:51:10,240
これにより、このフィールドはデータベース内の各行が必要とする一意なアイデアとなり、これを使用します。

459
00:51:10,240 --> 00:51:15,680
自動生成されたアイデアを使用するため、アイデアを渡す必要はありません。

460
00:51:16,800 --> 00:51:23,280
各レジュメには、文字列型のユーザー・アイデアも必要です。

461
00:51:23,280 --> 00:51:32,080
このレジュメがrightに属する場合、タイトルも必要ですが、ここではクエスチョンマークを追加します。

462
00:51:32,080 --> 00:51:37,200
を追加しています。これはタイトルはオプションだからです。

463
00:51:37,200 --> 00:51:43,280
タイトルを設定しない場合、このレジュメのタイトルは「no name」または「no
title」となります。

464
00:51:44,560 --> 00:51:49,920
次に説明文ですが、これもオプションの文字列です。

465
00:51:49,920 --> 00:51:54,400
を押すと、prismaエクステンションが自動的に適切に整列してくれます。

466
00:51:54,400 --> 00:52:01,680
さらに、この履歴書テーブルのカラムを表すフィールドが必要です。

467
00:52:01,680 --> 00:52:10,080
写真をアップロードすると、その写真がファイルストレージに保存されます。

468
00:52:10,080 --> 00:52:16,720
ファイルストレージに保存し、そのファイルへの参照をurlという形で取得します。

469
00:52:16,720 --> 00:52:23,280
写真をアップロードする必要はないので、オプションの文字列である。

470
00:52:23,280 --> 00:52:29,200
これも文字列として保存します。

471
00:52:29,200 --> 00:52:39,200
というのも、ここではデフォルト値を#000000000の黒に設定しているからです。

472
00:52:40,080 --> 00:52:45,680
デフォルト値が設定されているので、これはオプションにはしません。

473
00:52:45,680 --> 00:52:54,240
次にボーダースタイルで、ボーダーの半径を設定します。

474
00:52:54,240 --> 00:53:00,800
を設定することができます。ここでもデフォルト値はsquircleです。

475
00:53:00,800 --> 00:53:08,480
角が丸く、squircleは正方形と円形を混ぜたような形になります。

476
00:53:08,480 --> 00:53:16,560
これもまたオプションの文字列である。

477
00:53:16,560 --> 00:53:30,720
任意文字列 姓 任意文字列 職名 都市 国 電話番号 Eメール

478
00:53:32,800 --> 00:53:38,480
そして、このエントリーを作成したタイムスタンプである created at も必要です。

479
00:53:38,480 --> 00:53:45,120
これはデフォルトの値で、説明不要だと思います。

480
00:53:45,120 --> 00:53:54,400
そしてupdated atも必要で、これもタイムスタンプです。

481
00:53:54,400 --> 00:53:59,920
を設定すると、データベースのこのエントリーを更新したときに、このフィールドが自動的に更新されます。

482
00:53:59,920 --> 00:54:04,880
ビデオを一時停止して、それらをすべて入力することもできますし、ビデオの説明にあるgithubリポジトリを開いて

483
00:54:04,880 --> 00:54:09,600
を開き、そこからコードをコピーすることもできる。

484
00:54:09,600 --> 00:54:18,640
もうひとつ追加しておきたいことがあるんだ。広告の一番下にあるマップと、ここに履歴書を書くんだけど、デフォルトのテーブル名は

485
00:54:18,640 --> 00:54:24,800
テーブルの名前はモデルのresumeに大文字のrをつけて単数形にしたものです。

486
00:54:24,800 --> 00:54:31,440
postgresのテーブルの命名規則は通常小文字で複数形です。

487
00:54:31,440 --> 00:54:37,040
resumeの代わりにresumesとすることができます。

488
00:54:37,040 --> 00:54:42,480
個人的な好みによりますが、小文字にアンダースコアを付けることを好む人もいます。

489
00:54:42,480 --> 00:54:49,440
同様に@mapでマッピングすることもできます。

490
00:54:49,440 --> 00:54:57,440
first_nameなどという名前にすることもできるが、ここではやめておこう。

491
00:54:57,440 --> 00:55:02,400
このファイルに戻ってきて、さらに変更を加えたり、モデルを追加したりすることになるだろう。

492
00:55:02,400 --> 00:55:09,040
これで十分なので、これを保存して、プリズマがデータベースに接続され、モデル

493
00:55:09,040 --> 00:55:14,800
しかし、コード内でプリズマにアクセスする方法はまだ必要である。

494
00:55:14,800 --> 00:55:21,040
フォルダに新しいファイルを作成する。

495
00:55:21,040 --> 00:55:28,800
ここにprisma.tsという新しいファイルを置き、ここにコードをコピー・ペーストします。

496
00:55:28,800 --> 00:55:33,840
このチュートリアルではコピーペーストはあまりしません。

497
00:55:33,840 --> 00:55:40,320
これはprismaをnext.jsで動作させるために必要な定型的なコードなので、コピーするだけです。

498
00:55:40,320 --> 00:55:45,600
ビデオを一時停止してこれを入力するか、ビデオにあるgithubリポジトリからコピーしてください。

499
00:55:45,600 --> 00:55:50,880
このコードは必要だ。

500
00:55:50,880 --> 00:55:56,400
開発中にアプリをリロードしても、新しいprismaクライアントが何度も何度も作成されないようにするためです。

501
00:55:56,400 --> 00:56:02,800
next.jsで再利用するシングルトンを作成します。

502
00:56:02,800 --> 00:56:08,080
prismaのドキュメントでも説明されているので、prisma next.jsでググってみてほしい。

503
00:56:08,080 --> 00:56:15,280
これはnext.jsで必要なことで、prismaのドキュメントにも記載されています。

504
00:56:15,280 --> 00:56:21,600
新しいモデルを新しいデータベーステーブルを通してpostgresデータベースにプッシュして、いわば作成しなければなりません。

505
00:56:21,600 --> 00:56:27,040
まず、schema.prismaファイルのすべての変更を確認してください。

506
00:56:27,040 --> 00:56:34,720
ファイル内のすべての変更が保存されていることを確認してから、コマンドラインでnpx prisma
db pushを実行します。

507
00:56:34,720 --> 00:56:40,880
プロジェクトに接続したpostgresデータベースにプッシュします。

508
00:56:40,880 --> 00:56:48,320
環境変数を設定し、npx prisma db pushでエラーが出ないようにする。

509
00:56:48,320 --> 00:56:53,680
に戻り、すべての手順に従ったことを確認してください。

510
00:56:53,680 --> 00:57:01,360
prismaクライアントを生成しました。

511
00:57:01,360 --> 00:57:07,760
をコードで使えるようにするものです。

512
00:57:07,760 --> 00:57:14,400
libフォルダからprismaをインポートし、このテーブルをデータベースにプッシュします。

513
00:57:14,400 --> 00:57:22,240
履歴書を検索したり、新しい履歴書を作成したり、更新したりすることができます。

514
00:57:22,240 --> 00:57:29,440
このモデルを利用できるのはnpx prisma db pushを実行した後だけです。

515
00:57:29,440 --> 00:57:36,800
次に認証を設定します。clerk.comにアクセスしてアカウントを作成します。

516
00:57:36,800 --> 00:57:43,360
まだの場合は、サインインまたは開始をクリックして、アカウントを作成してください。

517
00:57:43,360 --> 00:57:51,840
既存のアカウントにログインして、すでにプロジェクトがあるのですが、もう一つ作ります。

518
00:57:51,840 --> 00:58:04,560
nextjs15ai履歴書ビルダーという名前を付けます。

519
00:58:04,560 --> 00:58:10,880
nextjs15ai履歴書ビルダーという名前を付けます。

520
00:58:10,880 --> 00:58:18,880
また、facebookやその他のソーシャルログインを有効にすることもできます。

521
00:58:18,880 --> 00:58:25,680
このアプリケーションを作成すると、このページにリダイレクトされます。

522
00:58:25,680 --> 00:58:32,080
のページにリダイレクトされます。ここには、さまざまなフレームワークの説明があります。

523
00:58:32,080 --> 00:58:37,040
このパッケージをインストールした後、コピーしたい新しい環境変数があります。

524
00:58:37,040 --> 00:58:44,720
コピーボタンをクリックしてプロジェクトに戻り、.envファイルを開いて、ここに貼り付けます。

525
00:58:45,520 --> 00:58:51,920
二重引用符をつけてもいいし、つけなくてもいい。

526
00:58:51,920 --> 00:59:00,320
この2つのキーをここに追加して、このファイルを保存する。

527
00:59:00,320 --> 00:59:06,880
ミドルウェアtsファイルを作成します。

528
00:59:06,880 --> 00:59:13,280
ここで認証の主要部分を処理します。

529
00:59:13,840 --> 00:59:22,720
これをコピーしてプロジェクトに移動し、このミドルウェア・ファイルを直接

530
00:59:22,720 --> 00:59:30,720
srzフォルダではなく、appフォルダに直接入れてください。

531
00:59:30,720 --> 00:59:37,520
middleware ts 正しいスペルで正しいフォルダに入れてください。

532
00:59:37,520 --> 00:59:45,440
このコードをコピーすると、基本的にすべてのページで認証が有効になります。

533
00:59:45,440 --> 00:59:51,440
保護する必要のない静的ファイルは除外されるが、保護したくないページもある。

534
00:59:51,440 --> 00:59:57,280
それはフロントページです。

535
00:59:57,280 --> 01:00:04,160
トップページはログインしなくても開くことができる。

536
01:00:04,960 --> 01:00:10,800
ログインしていなくてもこれらのページを開けるように、ホワイトリストに登録する必要があります。

537
01:00:10,800 --> 01:00:16,000
この方法は、店員のドキュメントに記載されています。

538
01:00:16,000 --> 01:00:24,880
is_public_routeというconstを作成し、これをcreateと呼びます。

539
01:00:24,880 --> 01:00:31,280
route_matcher関数は、clerk_nextjs_serverからインポートします。

540
01:00:32,800 --> 01:00:39,520
で、これにホワイトリストにしたいパスの配列を渡します。

541
01:00:39,520 --> 01:00:49,520
スラッシュ、そして2番目のスラッシュ sign
in、さらにその後ろにこのプレースホルダーを追加します。

542
01:00:49,520 --> 01:00:59,440
サブページも含むようにするため、sign inの後ろにプレースホルダーを追加する。

543
01:00:59,440 --> 01:01:08,640
サインアップの場合も同様に、スラッシュ・サイン・マイナス・アップ括弧ドット・アスタリスク閉じ括弧

544
01:01:08,640 --> 01:01:14,640
この3つのページをホワイトリストに登録し、ログインしていなくても開けるようにします。

545
01:01:14,640 --> 01:01:22,320
ログインしていなくても開けるようにしたい。

546
01:01:22,320 --> 01:01:34,240
このエラー関数はofとrequestの引数に渡される。

547
01:01:34,240 --> 01:01:40,640
これはnext request型である。

548
01:01:40,640 --> 01:01:47,280
感嘆符があるかどうかをチェックする。

549
01:01:47,280 --> 01:01:53,120
public routeであるかどうかをチェックする。

550
01:01:53,120 --> 01:02:00,080
ここで渡されたリクエストは、ウェブサイト上でページを開く前にミドルウェアが実行される。

551
01:02:00,080 --> 01:02:06,560
このページがパブリックルートでない場合は、このページで認証を要求します。

552
01:02:06,560 --> 01:02:11,920
このページで認証を要求したいので、ログインしていなければ自動的にログインページにリダイレクトされる。

553
01:02:11,920 --> 01:02:20,800
ログインしていない場合は、自動的にログインページにリダイレクトされる。

554
01:02:20,800 --> 01:02:28,720
こうすることで、このページは保護されるが、このifチェックのおかげで、すべてのページでのみ実行される。

555
01:02:28,720 --> 01:02:34,800
この配列には含まれないので、このページでは認証は必要ない。

556
01:02:34,800 --> 01:02:41,600
書式設定のショートカットを押すと、コードが適切に書式設定されます。

557
01:02:41,600 --> 01:02:48,400
セミコロンを削除したり、間隔を空けたり、二重引用符ではなく一重引用符を使ったりすると

558
01:02:48,400 --> 01:02:52,240
書式設定のショートカットを押すと、prettierが自動的にこれを処理してくれる。

559
01:02:52,240 --> 01:02:57,520
これがprettierが好きな理由だ。

560
01:02:57,520 --> 01:03:02,480
このためprettierは本当に気に入っている。

561
01:03:02,480 --> 01:03:09,280
ミドルウェア・ファイルを用意し、このクラーク・プロバイダをレイアウトに追加します。

562
01:03:09,280 --> 01:03:15,440
プロジェクトに戻って、appフォルダーにあるレイアウトtsxファイルを開きます。

563
01:03:15,440 --> 01:03:23,680
そして、htmlの周りのreturnブロックに、この店員プロバイダを次のように記述します。

564
01:03:23,680 --> 01:03:32,320
自動インポートではうまくいかないので、ここにclerk next
jsからのインポート文を追加し、htmlタグ全体を

565
01:03:32,320 --> 01:03:39,840
htmlタグ全体をこのクロック・プロバイダにラップする。

566
01:03:39,840 --> 01:03:48,800
バージョン6.0以前は、この時計プロバイダにラップされたすべてのページが静的インポートから外れていた。

567
01:03:48,800 --> 01:03:54,960
このクロック・プロバイダにラップしたすべてのページが静的キャッシュから外れるようになりました。

568
01:03:54,960 --> 01:04:00,240
フロントページのようなデータに依存しないページは、デフォルトで静的キャッシュされる。

569
01:04:00,240 --> 01:04:06,480
以前は、これは店員プロバイダーによって無効化されていた。

570
01:04:06,480 --> 01:04:13,040
動的にレンダリングされるため、ページの表示速度が遅くなっていた。

571
01:04:13,040 --> 01:04:18,720
クロック・プロバイダの内部で静的キャッシングを行うことができる。

572
01:04:18,720 --> 01:04:24,720
アプリ全体をこのプロバイダーにラップしても、フロントページは静的にキャッシュされる。

573
01:04:24,720 --> 01:04:30,320
しかし、これはウェブサイトのスピードに影響するだけで、機能的には何も変わらない。

574
01:04:30,320 --> 01:04:37,440
しかし、これはウェブサイトのスピードに影響するだけで、機能的には何も変わらない。

575
01:04:37,440 --> 01:04:45,040
srcフォルダーに入り、appを右クリックし、ここに括弧mainをこのように書きます。

576
01:04:45,920 --> 01:04:55,120
スラッシュ......このようにすると、resumes slashというフォルダができます。

577
01:04:55,120 --> 01:05:01,360
ファイルが作成され、appフォルダ内にmainフォルダとresumesフォルダが作成されます。

578
01:05:01,360 --> 01:05:08,320
括弧で囲まれたフォルダは、next jsのいわゆるルートグループです。

579
01:05:08,320 --> 01:05:14,160
そのため、このページはresumesというスラッシュの下に表示されますが、mainというスラッシュはURLの一部にはなりません。

580
01:05:14,160 --> 01:05:20,720
もし括弧がなければ、urlはslash main slash

581
01:05:20,720 --> 01:05:28,880
resumesになりますが、今はこのページにたどり着くにはスラッシュresumesだけです。

582
01:05:28,880 --> 01:05:36,160
ダミーのページを置くだけにしておきます。

583
01:05:36,160 --> 01:05:47,680
デフォルトの機能ページをエクスポートして、メインタグを返します。

584
01:05:47,680 --> 01:05:53,280
デフォルトで作成されたappフォルダにあるpage.tsxファイルをフロントページに移動します。

585
01:05:53,280 --> 01:06:01,360
そして、ネタバレのプレート・コードをすべて削除して、メイン・タグを返します。

586
01:06:01,360 --> 01:06:10,160
このインポートを削除することもできる。

587
01:06:10,160 --> 01:06:18,480
npm run devでlocalhost 3000を開くと、美しいフロントページが表示されます。

588
01:06:18,480 --> 01:06:25,840
しかし、スラッシュ・レジュメに行こうとすると、ログイン画面にリダイレクトされてしまう。

589
01:06:25,840 --> 01:06:31,120
スラッシュ・レジュメのページはアプリの認証が必要な部分にあるので、このような画面にリダイレクトされます。

590
01:06:31,120 --> 01:06:36,400
認証が必要なので、ここでアカウントを作成しましょう。

591
01:06:36,400 --> 01:06:41,840
facebookでも構いません。

592
01:06:41,840 --> 01:06:50,880
もちろん、サインアップをクリックして新しいアカウントを作成する必要があります。

593
01:06:51,440 --> 01:06:57,680
15 ちなみに、これもパスワードで保護されている。

594
01:06:57,680 --> 01:07:05,520
例えば、このようなパスワードは許可されないと思います。

595
01:07:05,520 --> 01:07:12,160
もちろんこれは便利な機能だ。

596
01:07:12,160 --> 01:07:17,920
認証メールが送られてきます。

597
01:07:17,920 --> 01:07:24,240
自分で設定する必要がないからだ。

598
01:07:24,240 --> 01:07:30,400
ログインが完了しました。

599
01:07:30,400 --> 01:07:37,600
レジュメのページにアクセスすることができます。

600
01:07:37,600 --> 01:07:44,240
にアクセスすると、このようにアクティブユーザーが表示されます。

601
01:07:44,240 --> 01:07:51,120
このconfigureタブで様々な機能を有効にすることができます。

602
01:07:51,120 --> 01:07:57,680
認証 様々な登録オプション 電子メール ユーザー名 お好きな組み合わせ

603
01:07:57,680 --> 01:08:04,400
さまざまなソーシャル・プロバイダーを追加することができます。

604
01:08:04,400 --> 01:08:09,200
様々なカスタマイズが可能です。

605
01:08:09,200 --> 01:08:14,880
ここではデフォルトのテンプレートを使用します。

606
01:08:14,880 --> 01:08:20,880
ログインページの見た目やアバターもカスタマイズできます。

607
01:08:20,880 --> 01:08:27,920
デフォルトでは紫がかった色になっています。

608
01:08:27,920 --> 01:08:35,280
これは私たちのアプリで使っている原色なので、これを保存しておき、後でユーザーがアバターを持っていないときに

609
01:08:35,280 --> 01:08:40,640
アバターがない場合、背景は紫ではなく緑になります。

610
01:08:40,640 --> 01:08:44,800
クラーク・ダッシュボードで利用可能なさまざまなオプションをチェックしてください。

611
01:08:44,800 --> 01:08:50,800
この中のどこかで、ログイン時に表示されるロゴをアップロードすることができます。

612
01:08:50,800 --> 01:08:56,080
ログインページに表示されるロゴをアップロードすることができます。

613
01:08:56,080 --> 01:09:06,720
プロジェクトのロゴを使いたいので、プロジェクトフォルダのsrz
assetsにロゴをアップロードしましょう。

614
01:09:06,720 --> 01:09:13,840
ログインページに表示されるサポートメールもここに設定できます。

615
01:09:13,840 --> 01:09:24,080
ログインページに表示されます。例えば、support@airesumebuilder.com。

616
01:09:24,080 --> 01:09:29,280
もちろんまだ存在しませんが、このメールアドレスを作成し、メッセージを受け取ることができます。

617
01:09:29,280 --> 01:09:37,680
変更を保存するのを忘れないようにしましょう。

618
01:09:37,680 --> 01:09:44,000
インコグニートタブ（ログインしていない状態）にすると、このページの表示が少し変わり、ロゴが表示されます。

619
01:09:44,000 --> 01:09:49,680
この紫の色を変更することもできます。

620
01:09:50,240 --> 01:09:57,680
アカウントポータルのカスタマイズの下のどこかにあるはずです。

621
01:09:57,680 --> 01:10:04,720
黒や緑などお好みの色に変更できます。

622
01:10:04,720 --> 01:10:11,280
ログインボタンの色も変わりました。

623
01:10:11,280 --> 01:10:17,200
ログインページのURLは自動的に生成されたものですが、これが私たち自身のウェブサイトのURLだったらもっと見栄えがよくなるはずです。

624
01:10:17,200 --> 01:10:23,040
開発環境ではlocalhostですが、本番環境では本番環境のURLです。

625
01:10:23,040 --> 01:10:30,320
このログインページを独自ドメインに置くことができます。

626
01:10:30,320 --> 01:10:37,280
ここでもappフォルダを右クリックし、新しいルートグループを作成します。

627
01:10:37,280 --> 01:10:48,400
スラッシュ記号をスラッシュでマイナスして、角括弧を2つ追加します。

628
01:10:48,400 --> 01:10:57,920
ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット

629
01:10:57,920 --> 01:11:07,360
slashページ.tsxと書き、appフォルダの中にこれらのフォルダを作成する。

630
01:11:07,360 --> 01:11:14,640
スラッシュと、このテキストはnext.jsのいわゆるルートグループです。

631
01:11:14,640 --> 01:11:21,440
スラッシュの下にページが作成されます。

632
01:11:21,440 --> 01:11:27,280
この間に、どのページが正確に生成されるかを心配する必要はない。

633
01:11:27,280 --> 01:11:32,320
clarkはこのルートグループを必要とします。

634
01:11:32,320 --> 01:11:36,960
サインインに関連するさまざまなページが生成され、これらすべてのページが動作するためには、このルートグループを追加する必要があるからです。

635
01:11:36,960 --> 01:11:43,840
このフォルダ構造が正しく設定されていることを確認してください。

636
01:11:43,840 --> 01:11:54,240
という関数をエクスポートします。

637
01:11:54,960 --> 01:12:03,120
でスタイルを設定したいメインタグを配置します。

638
01:12:03,120 --> 01:12:08,720
を画面の中央に配置し、パディングを3にして、ここでレンダリングします。

639
01:12:08,720 --> 01:12:15,520
サインインコンポーネントはclark next.jsからのインポートです。

640
01:12:15,520 --> 01:12:22,400
このようなサインアップ用のページをもう1つ作る必要があります。

641
01:12:22,400 --> 01:12:27,040
もう一度右クリックするが、今回はoffにする。

642
01:12:27,040 --> 01:12:36,160
そしてsign up slashと入力し、またこのドット・ドット・ドットsign
upですべてのルートをキャッチする。

643
01:12:36,160 --> 01:12:45,280
を閉じ角括弧スラッシュpage.tsxと入力すると、ここにサインアップページが作成されます。

644
01:12:45,280 --> 01:12:53,280
新規アカウントのエクスポート・デフォルト機能ページもまた同じスタイルで作成できます。

645
01:12:53,280 --> 01:13:01,120
サインインの代わりにサインアップコンポーネントをレンダリングします。

646
01:13:01,120 --> 01:13:08,400
これが唯一の違いですが、これを動作させる前に、dot envファイルを変更する必要があります。

647
01:13:08,400 --> 01:13:15,920
ここにnext public clerk sign in urlという環境変数を追加する。

648
01:13:15,920 --> 01:13:23,440
サインインURLを設定したサインインページにあることを確認し、次のように設定します。

649
01:13:23,440 --> 01:13:30,720
これがサインインページのパスです。

650
01:13:30,720 --> 01:13:38,960
サインアップ用にもうひとつ必要で、これはnext public clerk sign up
urlと呼ばれる。

651
01:13:38,960 --> 01:13:45,680
そうでなければ、この環境変数は機能しません。

652
01:13:45,680 --> 01:13:54,240
この変更を保存し、再びシークレット・タブでスラッシュ・レジュメを開こうとすると、独自ドメインにリダイレクトされます。

653
01:13:54,240 --> 01:14:01,040
サインインコンポーネントがあるので、サインアップをクリックすると

654
01:14:01,040 --> 01:14:10,240
スラッシュ・レジュメのサインアップをクリックすると、スラッシュ・レジュメのサインアップが表示されます。

655
01:14:10,240 --> 01:14:15,120
実装はとても簡単で、すぐにたくさんの機能が利用できます。

656
01:14:15,120 --> 01:14:22,560
月間アクティブユーザー数10,000人までは無料です。

657
01:14:22,560 --> 01:14:28,000
ページ上部のナビバーに、現在ログイン中であることを示すボタンを設置したい。

658
01:14:28,000 --> 01:14:35,280
ログイン中であることを確認できるボタンと、ログアウトボタンを設置します。

659
01:14:35,280 --> 01:14:42,800
メイン・フォルダーに新しいファイルを作成します。

660
01:14:42,800 --> 01:14:49,760
このメイン・グループとオフ・ルート・グループを作った理由は、アプリのこの2つの部分を分けるためです。

661
01:14:49,760 --> 01:14:55,360
このようにすることで、アプリのページであるメインページにのみナビバーを置くことができるからです。

662
01:14:55,360 --> 01:15:00,720
こうすることで、フロントページや認証ページがないアプリのページであるメインページだけにナビバーを設置することができるからです。

663
01:15:00,720 --> 01:15:05,920
ナビバーを表示させますが、ナビバーをレイアウトに配置したときに、これがどのように機能するかがわかるでしょう

664
01:15:05,920 --> 01:15:12,800
とりあえず、このナバー・コンポーネントのエクスポート・デフォルト関数を同じnavbarという名前でセットアップしてみましょう。

665
01:15:14,800 --> 01:15:21,040
ここではヘッダタグを返します。

666
01:15:21,040 --> 01:15:26,560
とりあえず、ここにテキストnavbarを入れて、これをレイアウトに入れましょう。

667
01:15:26,560 --> 01:15:32,480
ルート・レイアウトにこれを入れないのは、ナバーがすべてのページに表示されてしまうからです

668
01:15:32,480 --> 01:15:37,520
フロントページと認証ページを含むすべてのページに表示されるからです。

669
01:15:38,240 --> 01:15:46,080
このレイアウトはこのメイン・フォルダー内の全ページにのみ適用されます。

670
01:15:46,080 --> 01:15:55,360
このレイアウトはこのメインルートグループ内のすべてのページにのみ適用されます。

671
01:15:55,360 --> 01:16:03,040
ここで、このレイアウトに入れるページであるchildrenを渡します。

672
01:16:04,080 --> 01:16:09,440
そして、react.reactnodeのようにtypescriptを使用するため、型を定義する必要があります。

673
01:16:09,440 --> 01:16:13,920
このレイアウトはとてもシンプルなものになります。

674
01:16:13,920 --> 01:16:22,640
この中に先ほど作成したナバーを入れて、その下に子ページをレンダリングします。

675
01:16:22,640 --> 01:16:28,640
ページの上にナビバーを配置し、これを保存してフロントページを開くと

676
01:16:28,640 --> 01:16:33,840
ナバーはメインレイアウトの一部ではないので、フロントページには表示されません。

677
01:16:33,840 --> 01:16:43,440
また、/signinやsignupに行くときにもナビバーは必要ありません。

678
01:16:43,440 --> 01:16:49,920
メインルートグループのすべてのページ、例えば/resumesページにはナビバーがあります。

679
01:16:49,920 --> 01:16:55,360
では、ナビバーのデザインを続けよう。

680
01:16:55,360 --> 01:17:01,600
にクラス名を追加します。

681
01:17:01,600 --> 01:17:07,680
このヘッダーシャドウsmにクラス名を追加すると、オートコンプリートが表示されます。

682
01:17:07,680 --> 01:17:14,640
最初にお見せしたようにtailwindエクステンションを設定したため、オートコンプリートが適用されます。

683
01:17:14,640 --> 01:17:24,800
最大幅7xlのクラスで別の差分を置き、mx autoでこれを画面に送ります。

684
01:17:26,560 --> 01:17:31,520
また、パディングを3つ追加して、ここに少し余分なスペースを追加します。

685
01:17:31,520 --> 01:17:37,440
そして、item centerとjustify betweenでフレックスボックスにします。

686
01:17:37,440 --> 01:17:44,560
さらに、スナッフバー内の要素を適切に配置するために、3つのギャップを追加します。

687
01:17:44,560 --> 01:17:51,200
スナッフバーの左側にはロゴを配置し、右側には店員のユーザーボタンを配置します。

688
01:17:51,200 --> 01:17:59,520
ボタンを配置し、最初の要素であるstiffの中にnextリンクを配置します。

689
01:17:59,520 --> 01:18:08,400
このリンクをクリックすると/resumesにリダイレクトされます。

690
01:18:08,400 --> 01:18:16,000
このリンクの中にロゴとテキストを入れるので、ここに次の画像を入れます。

691
01:18:16,640 --> 01:18:23,840
というわけで、この2つのインポート文を追加する必要があります。

692
01:18:23,840 --> 01:18:33,120
スラッシュアセットを追加して、ここにlogo.pngがある。

693
01:18:33,120 --> 01:18:42,160
この画像のaltテキストをロゴまたは履歴書ビルダーに設定します。

694
01:18:42,160 --> 01:18:48,800
aiロゴなど、お好みのものを選択してください。

695
01:18:48,800 --> 01:18:58,240
そして、丸みを帯びたスタイルにし、この画像タグを閉じます。

696
01:18:58,240 --> 01:19:05,040
ロゴの横にウェブサイトのタイトルを入れたいのですが、まだリンクの中にあります。

697
01:19:05,040 --> 01:19:14,880
その横にai resume builderというスパンを置き、このバンのスタイルを

698
01:19:14,880 --> 01:19:24,320
テキストはXLフォントを太字にし、文字間隔を狭くするトラッキングタイトを使用しています。

699
01:19:24,320 --> 01:19:31,920
これをクリックすると、/resumesにリダイレクトされる。

700
01:19:31,920 --> 01:19:39,440
スナッフバーのdivはフレックスボックスになっています。

701
01:19:39,440 --> 01:19:44,320
つまり、リンクの後に何を配置しても、スナッフバーの右側に配置されます。

702
01:19:44,320 --> 01:19:49,360
このユーザーボタンはclerk next.jsからインポートしたものです。

703
01:19:49,360 --> 01:19:57,120
これを保存すると、このようにユーザーボタンが表示される。

704
01:19:57,120 --> 01:20:03,120
店員アカウントを管理したり、サインアウトしたりすることができる。

705
01:20:03,120 --> 01:20:08,400
この外観の小道具を少しカスタマイズしたい。

706
01:20:08,400 --> 01:20:14,480
この中括弧をもう一組入れて、要素フィールドでスタイルを設定します。

707
01:20:14,480 --> 01:20:20,240
このアバターをもう少し大きくしたい。

708
01:20:20,880 --> 01:20:27,360
このアバターボックスの値のコロン中かっこを使って、このようにすることができます。

709
01:20:27,360 --> 01:20:32,640
幅と高さを設定します。これもロゴと同じように35に設定します。

710
01:20:32,640 --> 01:20:42,480
そして、これを保存すると、少し大きくなり、完璧なスナッフバーになります。

711
01:20:42,480 --> 01:20:48,960
このスナッフバーはこの7xLサイズより大きくなることはなく、常に画面の中央に表示される。

712
01:20:49,760 --> 01:20:55,840
そしてもうひとつ、店員が最近行ったクールな改良は、このドロップダウンメニューに新しいリンクやボタンを追加できることだ。

713
01:20:55,840 --> 01:21:01,200
このドロップダウンメニューに新しいリンクやボタンを追加できる。

714
01:21:01,200 --> 01:21:06,960
例えば、後で使う請求ページへのリンクを追加できます。

715
01:21:06,960 --> 01:21:16,000
このリンクはアプリのメイン部分に属するので、メイン課金スラッシュページ.tsxを右クリックします。

716
01:21:17,040 --> 01:21:23,680
今のところ、これには単純なダミーページのエクスポート・デフォルト機能ページが含まれます。

717
01:21:23,680 --> 01:21:32,240
メイン・タグに「billing save
this」と書いて、この課金ページへのリンクをスナフキンに貼りたい。

718
01:21:32,240 --> 01:21:39,840
へのリンクをスナッフバーのユーザーボタンに貼り付けたい。

719
01:21:39,840 --> 01:21:44,560
ユーザーボタンのタグを通常の閉じタグに変更し、その間に他のタグを入れられるようにする。

720
01:21:45,920 --> 01:21:56,000
そして、ここにユーザーボタンのドット・メニュー・アイテムを入れ、これを閉じ、ここにユーザーボタンのドット・リンクを入れます。

721
01:21:56,000 --> 01:22:04,320
このリンクには自己終了タグを付け、ラベルを付けます。

722
01:22:04,320 --> 01:22:13,280
これはbillingと表示され、アイコンを付けることができます。

723
01:22:13,280 --> 01:22:20,640
というのもchatcnもlucidというアイコンパッケージを使っているからです。

724
01:22:20,640 --> 01:22:28,080
パッケージから様々なアイコンをインポートすることができます。

725
01:22:28,080 --> 01:22:36,240
を追加することで、様々なアイコンをインポートすることができます。

726
01:22:36,240 --> 01:22:43,440
そしてこのリンクのhrefをスラッシュ・ビリングに設定する。

727
01:22:43,440 --> 01:22:50,160
を設定します。スナッフバーを間違った

728
01:22:50,160 --> 01:22:56,080
レジュメフォルダに入れたが、メインフォルダ内の全ページに適用すべきだった。

729
01:22:56,080 --> 01:23:04,160
メインフォルダ内のすべてのページに適用されるはずです。

730
01:23:04,160 --> 01:23:10,160
インポート文が正しく更新されていることを確認してください。

731
01:23:10,160 --> 01:23:16,080
ナフバーをクライアント・コンポーネントにすることで、矢印を消すことができます。

732
01:23:16,080 --> 01:23:22,640
クライアントコンポーネントでしか使えないと思います。

733
01:23:22,640 --> 01:23:29,440
クライアントコンポーネントにしましょう。

734
01:23:29,440 --> 01:23:34,560
ナフバーですでに作業しているので、ダークモードも追加してみよう。

735
01:23:34,560 --> 01:23:40,880
ダークモードの実装方法は

736
01:23:40,880 --> 01:23:46,800
shadcnのドキュメントに記載されています。

737
01:23:46,800 --> 01:23:53,520
レイアウトをテーマ・プロバイダにラップし、トグル・ボタンを作成します。

738
01:23:53,520 --> 01:24:00,880
トグルボタンを作成して、異なるテーマを切り替えられるようにします。

739
01:24:00,880 --> 01:24:07,040
appフォルダにあるlayout.tsxファイルです。

740
01:24:07,040 --> 01:24:13,200
子テーマはアプリのすべてのページで、これをテーマプロバイダーにラップします。

741
01:24:13,200 --> 01:24:23,200
次のテーマから中括弧を手動でインポートする必要があるようです。

742
01:24:23,200 --> 01:24:33,040
このテーマプロバイダーは、すべての子ページをこのテーマプロバイダーにラップします。

743
01:24:33,040 --> 01:24:40,880
属性をclassに設定します。

744
01:24:40,880 --> 01:24:48,080
このhtmlタグにクラスを追加することでテーマを変更します。

745
01:24:48,080 --> 01:24:54,560
テーマをシステムに設定し、デバイス上で選択されているシステムテーマが何であれ、ダークにもライトにもできるようにする

746
01:24:54,560 --> 01:25:02,560
さらに、システム・オプションを有効にして、トランジション・チェンジを無効にすることも追加します。

747
01:25:02,560 --> 01:25:09,680
このオプションを追加すると、テーマが突然変更されます。

748
01:25:09,680 --> 01:25:14,320
ボタンをクリックしたときにテーマが突然変わるので、見た目がよくなります。

749
01:25:14,320 --> 01:25:21,360
ところで、htmlタグのsuppress
hydrationにもうひとつ追加しなければならないことがある。

750
01:25:21,360 --> 01:25:26,480
この警告は次のテーマのドキュメントに記載されています。

751
01:25:26,480 --> 01:25:34,000
水和警告が表示されますが、これは問題ありません。

752
01:25:34,000 --> 01:25:40,240
を無効にするだけで、htmlタグの子タグに対しては無効にしないので、水和警告を完全に無効にするわけではありません。

753
01:25:40,240 --> 01:25:46,880
警告を完全に無効にしているわけではありません。

754
01:25:46,880 --> 01:25:54,400
これは残念ながらnext.jsで必要ですが、何も壊すことはありません。

755
01:25:54,400 --> 01:26:00,320
テーマのトグルボタンを設定し、ナビバーに設置します。

756
01:26:00,320 --> 01:26:07,840
このフォルダをuiの中ではなく、componentsフォルダの中に直接入れて、次のように呼びます。

757
01:26:07,840 --> 01:26:17,760
テーマtoggle.tsxをクライアント・コンポーネントとし、デフォルト関数theme
toggleをエクスポートする。

758
01:26:17,760 --> 01:26:29,120
ここで、次のテーマからテーマを使用する次のフックを呼び出します。

759
01:26:29,120 --> 01:26:32,000
テーマをトグルするための関数です。

760
01:26:34,640 --> 01:26:40,800
ドロップダウン・メニューをレンダリングしたいのですが、これはshadcnコンポーネントです。

761
01:26:40,800 --> 01:26:45,680
shadcnのドキュメントで、これらのさまざまなコンポーネントの使い方を学ぶことができます。

762
01:26:45,680 --> 01:26:51,680
ドロップダウンメニューはshadcnのコンポーネントです。

763
01:26:51,680 --> 01:27:00,720
ここではドロップダウンメニューを返します。

764
01:27:00,720 --> 01:27:07,120
ui フォルダからコンポーネントをインポートします。

765
01:27:07,120 --> 01:27:14,960
というのも、これはshadcnのもので、redixのものはデフォルトではスタイルなしだからです。

766
01:27:14,960 --> 01:27:22,320
メニュートリガーを追加します。

767
01:27:22,320 --> 01:27:28,000
ここに何を入れてもレンダリングできるようにする。

768
01:27:28,000 --> 01:27:34,960
これもまたshadcnコンポーネントである。

769
01:27:34,960 --> 01:27:42,560
サイズをアイコンに設定する。

770
01:27:42,560 --> 01:27:50,000
アイコンはluzidのアイコンなので、luzid reactのangle bracket
sunを開く。

771
01:27:51,440 --> 01:27:58,640
サイズをゼロではなく、ハードコードされた値に設定する。

772
01:27:58,640 --> 01:28:07,040
このように角括弧を使って1.2倍にし、sizeで幅と高さの両方を設定する。

773
01:28:07,040 --> 01:28:15,760
次にrotate zeroを追加します。これが何のためにあるのかは、後で説明します。

774
01:28:17,200 --> 01:28:26,960
transition all それから、dark修飾子dark colonを使います。

775
01:28:26,960 --> 01:28:34,240
ダークモードでは、マイナス回転マイナス90に設定します。

776
01:28:34,240 --> 01:28:41,680
そしてスペースを空けてから、再びダークモディファイアを使用し、ダークモードではスケールをゼロに設定する。

777
01:28:42,400 --> 01:28:49,280
これは何をするかというと、ライトモードが有効な場合にのみ太陽のアイコンが表示されるようにします。

778
01:28:49,280 --> 01:28:55,840
ダークモードに切り替えると、100のスケールで月のアイコンが表示されます。

779
01:28:55,840 --> 01:29:02,800
ダークモードに切り替えると、代わりに月のアイコンが表示されます。

780
01:29:02,800 --> 01:29:08,560
この回転はちょっとしたアニメーションです。

781
01:29:08,560 --> 01:29:16,000
この回転はちょっとしたアニメーションで、shadcnのドキュメントから直接コピーしたものです。

782
01:29:16,000 --> 01:29:23,680
これはダーク・モードでのみ表示されます。

783
01:29:23,680 --> 01:29:31,760
サイズ1.2、絶対配置で太陽のアイコンの上に置く。

784
01:29:34,080 --> 01:29:41,120
このアイコンはデフォルトで90回転させ、デフォルトでスケールをゼロにします。

785
01:29:41,120 --> 01:29:47,600
ダークモードではこれを表示し、ライトモードでは表示しない。

786
01:29:47,600 --> 01:29:54,080
ダークモードでは、これを100にスケールして表示したい。

787
01:29:54,080 --> 01:30:01,840
また、太陽のアイコンの正反対に見えるように、これをゼロに回転させたい。

788
01:30:01,840 --> 01:30:07,360
少し複雑に見えるが、これは太陽と月のアイコンを切り替えるアニメーションを追加するだけだ。

789
01:30:07,360 --> 01:30:13,200
太陽と月のアイコンを切り替えるアニメーションがあります。

790
01:30:13,200 --> 01:30:20,080
を除いて、これらのクラスのほとんどを省略することもできますが、見た目はもう少しクールです。

791
01:30:20,080 --> 01:30:28,640
トグル・テーマはアクセシビリティに優れています。

792
01:30:28,640 --> 01:30:35,040
視覚障害のある人、たとえば目の不自由な人でも、このボタンが何のためにあるのかを知ることができます。

793
01:30:35,040 --> 01:30:42,560
このsr onlyクラスは、このボタンを不可視にし、他のものも追加します。

794
01:30:42,560 --> 01:30:49,360
そして、ドロップダウンメニューの下にある

795
01:30:49,360 --> 01:30:56,080
トリガーを閉じますが、まだドロップダウンメニューの中にあります。

796
01:30:56,960 --> 01:31:04,640
というのも、ここにはドロップダウンメニューの中身を入れるからです。

797
01:31:04,640 --> 01:31:11,120
ドロップダウンメニューをクリックしたときに画面の外に出ないようにするためです。

798
01:31:11,120 --> 01:31:20,240
各テーマオプションのドロップダウンメニューアイテムを3つ並べました。

799
01:31:21,360 --> 01:31:30,160
をクリックすると、set theme関数が呼び出されます。

800
01:31:30,160 --> 01:31:36,000
この関数に文字列としてlightを渡す。

801
01:31:36,000 --> 01:31:45,920
2つ目は小文字のdarkで、テキストはもちろんdarkとなります。

802
01:31:45,920 --> 01:31:55,760
もちろん、これは「トグル・テーマ」ではなく「トグル・テーマ」と書くべきだろう。

803
01:31:55,760 --> 01:32:03,440
ボタンが完成したので、これをナバーバーnavbar tsxに入れることができる。

804
01:32:03,440 --> 01:32:13,680
ユーザー・ボタンのテーマtoggleは、すべてのロジックがその中に含まれているため、自己閉鎖タグを取得します。

805
01:32:13,680 --> 01:32:19,280
というのも、すべてのロジックがこの中に含まれているからです。

806
01:32:19,280 --> 01:32:29,360
ユーザーボタンをこのように別のdivにラップし、このdivにクラス名を追加して、これを

807
01:32:29,360 --> 01:32:36,560
フレックスボックスとし、アイテムは中央、ギャップは3とします。

808
01:32:36,560 --> 01:32:42,880
トグルボタンが表示され、テーマが自動的に適用されます。

809
01:32:42,880 --> 01:32:52,000
ライトとダークの切り替えができ、システムテーマもクールだ。

810
01:32:52,000 --> 01:32:58,720
ドロップダウンメニューがテーマを変更しないのは、tailwindによってスタイリングされていないからです。

811
01:32:58,720 --> 01:33:07,760
まず、店員用のダークテーマをインポートします。

812
01:33:09,280 --> 01:33:14,160
最初にインストールしたadd clerk slash themesパッケージの中にある。

813
01:33:14,160 --> 01:33:22,080
この中にダーク・オブジェクトがあるので、現在のテーマを知る必要がある。

814
01:33:22,080 --> 01:33:28,560
ダークテーマを条件付きで適用するために、現在のテーマを知る必要がある。

815
01:33:28,560 --> 01:33:33,680
を使って現在のテーマを再び取得することができます。

816
01:33:34,640 --> 01:33:41,520
があるだけでなく、現在アクティブなテーマであるこのテーマ値もあります。

817
01:33:41,520 --> 01:33:49,760
ボタンに移動し、要素の隣にあるこのappearance
propでベーステーマを変更することができます。

818
01:33:49,760 --> 01:33:58,240
このコロンのようにテーマを設定し、現在アクティブなテーマがdarkと等しいかどうかをチェックします。

819
01:33:59,280 --> 01:34:04,640
クエスチョンマークがあれば、このダークテーマを適用する。

820
01:34:04,640 --> 01:34:09,440
これをundefinedに設定し、値を渡さないようにする。

821
01:34:09,440 --> 01:34:19,360
このドロップダウンメニューのテーマも完璧に変更され、常に他のアプリと同期されます。

822
01:34:19,360 --> 01:34:26,240
認証がうまくいき、ダークモードが機能するようになりました。

823
01:34:26,240 --> 01:34:32,800
履歴書エディターです。

824
01:34:32,800 --> 01:34:39,280
すべてのフォームに表示されるヘッダーがあります。

825
01:34:39,280 --> 01:34:46,560
フッターがあり、真ん中は2つに分かれています。

826
01:34:46,560 --> 01:34:51,760
レジュメ・プレビューが常に表示され、左側にはさまざまなフォームがあります。

827
01:34:51,760 --> 01:34:58,320
最初に考えたのは、これをすべてレイアウトtsxファイルにして、ヘッダーとフッターを

828
01:34:58,320 --> 01:35:04,080
ヘッダーとフッターと履歴書プレビューはレイアウトファイルの一部です。

829
01:35:04,080 --> 01:35:10,720
しかし、いくつかの問題が発生しました。

830
01:35:10,720 --> 01:35:16,160
検索パラメータを受け取ることができません。

831
01:35:16,160 --> 01:35:22,240
しかし、他にもいくつか問題があります。

832
01:35:22,240 --> 01:35:28,480
を基本的に置き換えるだけなのに対して、サーバーにリクエストしなければならないので、遅くなる。

833
01:35:28,480 --> 01:35:34,960
複数のページに分割すると、3つ目の状態管理が非常に難しくなります。

834
01:35:34,960 --> 01:35:40,800
しかし、すべてを1つのページにまとめれば、状態管理はとても簡単になる。

835
01:35:40,800 --> 01:35:46,800
このエディター全体を1つのページにまとめることにしたのはそのためだ。

836
01:35:46,800 --> 01:35:53,360
プロジェクトに戻って、まず最初に

837
01:35:53,360 --> 01:36:01,120
スラッシュ・レジュメのページを開き、設定を続けましょう。

838
01:36:01,120 --> 01:36:08,400
次のjs 13初心者チュートリアルで説明します。

839
01:36:09,520 --> 01:36:14,640
このように、スペルを間違えないようにして、次からメタデータをインポートしてください。

840
01:36:14,640 --> 01:36:23,360
ここで、例えば履歴書のページタイトルを設定することができます。

841
01:36:23,360 --> 01:36:29,280
このページのタイトルは「履歴書」です。

842
01:36:29,280 --> 01:36:36,480
この部分をルートレイアウトのテンプレートに入れます。

843
01:36:36,480 --> 01:36:42,560
ページタイトルとウェブサイトのタイトルの組み合わせです。

844
01:36:42,560 --> 01:36:49,200
履歴書エディターへ移動するボタンをメインタグに設置します。

845
01:36:49,200 --> 01:36:53,280
大文字のbボタンをcomponentsフォルダにある

846
01:36:53,280 --> 01:37:00,800
アイコンをレンダリングします。

847
01:37:02,080 --> 01:37:09,440
サイズは5で、タグは自動で閉じます。

848
01:37:09,440 --> 01:37:16,160
また、きちんと整列させたいので、まずメインタグにクラス名を追加します。

849
01:37:16,160 --> 01:37:21,520
navbarの最大幅は7 xlで、コンテンツにも同じ最大幅を使用したい。

850
01:37:21,520 --> 01:37:28,400
また、mx autoで画面の中央に表示させたいのですが、幅も設定したいです。

851
01:37:28,400 --> 01:37:34,960
をフルに設定し、使用可能な幅を常に使用するようにします。

852
01:37:34,960 --> 01:37:44,720
px3、垂直方向のパディングを6、そしてスペースy6を追加して、ここにある要素の間隔を広げます。

853
01:37:44,720 --> 01:37:51,840
また、このボタンをリンクに変えたい。

854
01:37:51,840 --> 01:37:57,360
ボタンのクリック機能を使って別のページに移動するのは悪い習慣です。

855
01:37:57,360 --> 01:38:02,480
なぜならリンクはそのためにあるのだから。

856
01:38:02,480 --> 01:38:10,480
プロパティを使い、次のリンクをここに置くことだ。

857
01:38:10,480 --> 01:38:15,200
ボタンのように見えるリンクがレンダリングされます。

858
01:38:15,200 --> 01:38:23,520
このリンクはスラッシュ・エディタを指し示し、アイコンとテキストをこのリンクで囲みます。

859
01:38:25,280 --> 01:38:30,640
そして、このボタンを画面の中央に配置するために、mx autoでスタイルを設定します。

860
01:38:30,640 --> 01:38:42,000
幅をfit、間隔をtourに設定し、保存すると中央に配置されます。

861
01:38:42,000 --> 01:38:48,560
そして、クロームの開発ツールでこのボタンをチェックすると、これはもうボタンではありません。

862
01:38:48,560 --> 01:38:54,560
aタグであり、リンクであることがわかります。

863
01:38:54,560 --> 01:38:59,600
このボタンをもう少し洗練させ、プレミアムプランに加入していないけれども、すでにレジュメ数が上限に達している場合に

864
01:38:59,600 --> 01:39:05,600
レジュメの上限数に達している場合、代わりにこのプレミアムダイアログを表示します。

865
01:39:05,600 --> 01:39:10,720
次にメインレイアウトに入りたいと思います。

866
01:39:10,720 --> 01:39:18,480
このdivにいくつかのクラスを追加する必要があります。

867
01:39:18,480 --> 01:39:26,640
エディタは常に画面の高さいっぱいに表示する必要があります。

868
01:39:26,640 --> 01:39:32,960
これは後で適切な配置にするために必要です。

869
01:39:32,960 --> 01:39:40,400
エディタはslash editorの下にある別のページです。

870
01:39:40,400 --> 01:39:51,600
メインエディターのslash
page.tsxをクリックして、pageというデフォルト関数をエクスポートします。

871
01:39:51,600 --> 01:40:01,600
また、タイトルをexport const metadata of type
metadataとします。

872
01:40:05,120 --> 01:40:15,040
これは履歴書をデザインする際に、このページからしかメタデータをエクスポートできないことを示します。

873
01:40:15,040 --> 01:40:19,600
クライアントコンポーネントにすると、この機能はなくなります。

874
01:40:19,600 --> 01:40:25,040
履歴書エディタはクライアント・コンポーネントでなければなりません。

875
01:40:25,040 --> 01:40:29,760
これを解決する方法は、このページの内容を別のファイルに保存することです。

876
01:40:29,760 --> 01:40:35,040
それをクライアントコンポーネントとし、同じエディタフォルダに置きます。

877
01:40:35,040 --> 01:40:44,080
これをresume
editor.tsxと呼び、ここからクライアント・コンポーネントをエクスポートします。

878
01:40:44,080 --> 01:40:53,120
今のところ、このように空のフラグメントを返します。

879
01:40:53,120 --> 01:41:01,280
これを保存して、ページに貼り付けたいので、ページに戻ってresume editorを返します。

880
01:41:01,280 --> 01:41:08,400
そして、すべてのマジックはこの中で起こります。

881
01:41:08,400 --> 01:41:15,120
このpage.tsxはページのタイトルを設定し、レジュメエディタを表示します。

882
01:41:15,120 --> 01:41:21,680
はul内の履歴書IDですが、これについては後ほど説明します。

883
01:41:22,320 --> 01:41:26,480
もちろん、空のフラグメントをレンダリングしたいわけではありません。

884
01:41:26,480 --> 01:41:36,560
をレンダリングし、フレックスグロウンとフレックスコルでスタイルを設定します。

885
01:41:36,560 --> 01:41:43,040
スペース y 1.5 ボーダー下

886
01:41:45,440 --> 01:41:53,280
水平方向のパディングは3、垂直方向のパディングは5、テキストは中央に配置します。

887
01:41:53,280 --> 01:42:02,880
このヘッダーには見出しのテキストが入っている。

888
01:42:02,880 --> 01:42:11,040
あなたの履歴書をデザインすることになる。

889
01:42:11,040 --> 01:42:17,760
この下にちょっとした説明文を入れたい。

890
01:42:17,760 --> 01:42:28,800
テキストはミュート、前景色はこのようにします。

891
01:42:28,800 --> 01:42:37,040
進捗状況は自動的に保存されます。

892
01:42:37,040 --> 01:42:42,000
このように長いテキストを入力すると、prettierが適切な改行を追加してくれます。

893
01:42:42,000 --> 01:42:48,480
ショートカットを押してもきちんと整列されるので、作業がしやすくなります。

894
01:42:48,480 --> 01:42:53,840
テキストがどのように表示されるかは変わりません。

895
01:42:53,840 --> 01:43:01,200
ヘッダーの下にmainタグを配置します。

896
01:43:01,200 --> 01:43:08,560
そしてその下にはフッターを置きたい。

897
01:43:08,560 --> 01:43:15,520
ボーダーの上の水平方向のパディングは3、垂直方向のパディングは5です。

898
01:43:15,520 --> 01:43:24,640
ここにまた別のdiffを置き、最大幅を7xlとする。

899
01:43:25,280 --> 01:43:30,880
フレックスラップでフレックスボックスを作成します。

900
01:43:30,880 --> 01:43:40,560
この差分を閉じ、ここに別の差分を入れます。

901
01:43:40,560 --> 01:43:50,480
をフレックスアイテムセンターでスタイルし、ギャップを3にします。

902
01:43:50,480 --> 01:43:56,400
ボタンを配置します。

903
01:43:56,400 --> 01:44:02,080
左側に配置し、右側に他のものを配置します。

904
01:44:02,080 --> 01:44:10,720
大文字のbボタン、バリアントはセカンダリで、これは薄い色になります。

905
01:44:10,720 --> 01:44:21,600
もう一つのボタンはデフォルトのバリアントで、次のステップです。

906
01:44:21,600 --> 01:44:27,920
今のところ、これらのボタンは何もしませんが、後で機能を追加します。

907
01:44:27,920 --> 01:44:34,320
そしてこの内側の diff の下に、フッターの右側のコンテンツ用の diff を配置します。

908
01:44:35,280 --> 01:44:40,800
ここでもflexとitem
centerを使用し、中の要素間の間隔を空けるためにgapを3つ空けます。

909
01:44:40,800 --> 01:44:49,920
そしてこの中にリンクをレンダリングするセカンダリのバリアントボタンを配置します。

910
01:44:49,920 --> 01:44:57,920
子プロップとして使用し、次のリンクをレンダリングします。

911
01:44:57,920 --> 01:45:04,640
もちろん、戻ることもできます。

912
01:45:04,640 --> 01:45:12,080
ナビバーのリンクから戻ることもできますが、ユーザビリティのためにこの閉じるボタンを追加します。

913
01:45:12,080 --> 01:45:18,800
現在変更が保存されているかどうかを示すテキストを置きたい。

914
01:45:18,800 --> 01:45:26,240
この閉じるボタンの横にある「保存」というタグ。

915
01:45:26,240 --> 01:45:32,880
というのも、item startではきちんと整列されないからだ。

916
01:45:32,880 --> 01:45:39,680
段落タグのテキストをミュート前景色にして、薄いグレーにします。

917
01:45:39,680 --> 01:45:46,320
を透明にして、不透明度をゼロにして非表示にしたい。

918
01:45:46,320 --> 01:45:51,920
画面の高さいっぱいに表示したい。

919
01:45:51,920 --> 01:45:58,400
フッターが上部に表示され、画面からはみ出さないようにしたい。

920
01:45:58,400 --> 01:46:05,280
mainタグを相対位置で、サイズをgrowにする。

921
01:46:05,280 --> 01:46:15,120
を追加し、このdiffに絶対ポジショニングを追加します。

922
01:46:15,120 --> 01:46:20,880
ボックスとし、幅をいっぱいにします。

923
01:46:20,880 --> 01:46:26,400
ズームレベルに関係なく、エディターの高さいっぱいに表示されます。

924
01:46:26,400 --> 01:46:38,160
そしてここに、クラス名をwidth fullにした別の差分を置きたい。

925
01:46:38,160 --> 01:46:46,160
このmdブレークポイントモディファイアをmdブレークポイントで使用する。

926
01:46:46,160 --> 01:46:52,000
エディターの左側をleftとし、右側をrightとする。

927
01:46:53,120 --> 01:47:02,640
後でレジュメのプレビューを表示する場所です。

928
01:47:02,640 --> 01:47:08,000
これはmdブレークポイント以降にのみ表示されるようにします。

929
01:47:08,000 --> 01:47:14,720
デフォルトではレジューム・プレビューは表示されないので、デフォルトでは非表示にし、mdブレークポイントでも非表示にする。

930
01:47:14,720 --> 01:47:22,160
フレックスボックスにして再度表示させます。

931
01:47:22,160 --> 01:47:28,960
これをもう少し大きくすると、右側が表示されます。

932
01:47:28,960 --> 01:47:36,320
レイアウトの半分を占め、その間に仕切り線を入れたい。

933
01:47:36,320 --> 01:47:43,280
左と右の2つのデフの間に、もう1つのデフを配置しよう。

934
01:47:43,280 --> 01:47:49,280
そして、ここではクラススクロールを追加して、利用可能な高さいっぱいに表示します。

935
01:47:50,160 --> 01:47:56,640
右のmdブレイクポイントにのみ表示したいので、右のmdコロンボーダーを追加します。

936
01:47:56,640 --> 01:48:03,840
を追加して、ここにボーダーを表示する。

937
01:48:03,840 --> 01:48:08,720
エディターの左側にはフォーム要素を置きたい。

938
01:48:08,720 --> 01:48:13,920
schatziとフォームコンポーネントはリアクトフックフォームと統合されているのでとても便利です。

939
01:48:13,920 --> 01:48:19,280
react hook formはreactで最も人気のあるフォームライブラリです。

940
01:48:19,280 --> 01:48:24,240
フォームの送信、フォームからの値の取得、そしてリアルタイムの

941
01:48:24,240 --> 01:48:29,840
バリデーションもできる。

942
01:48:29,840 --> 01:48:36,080
フォームスキーマを設定し、それをこのuse form hookでフックする必要があります。

943
01:48:36,080 --> 01:48:41,360
でフックし、さまざまなフォームコンポーネントを追加します。

944
01:48:41,360 --> 01:48:46,960
アクセシビリティのような多くのことを引き受けてくれる。

945
01:48:46,960 --> 01:48:52,800
は入力フィールドに適切に接続され、説明文とオプションのエラーメッセージも表示されます。

946
01:48:52,800 --> 01:48:58,960
このように、多くの機能が箱から取り出され、またこのような素敵な方法でスタイリングされています。

947
01:48:58,960 --> 01:49:05,680
プロジェクトに戻って、まず最初に、libフォルダーの下に新しいファイルを作成します。

948
01:49:05,680 --> 01:49:13,600
ここにフォームスキーマを置きます。

949
01:49:13,600 --> 01:49:18,960
これらのスキーマを使用するコンポーネントに置くこともできます。

950
01:49:18,960 --> 01:49:24,000
通常、これらのスキーマを使用するコンポーネントに置くこともできます。

951
01:49:24,000 --> 01:49:29,360
これらのスキーマをフロントエンドのフォームで使うだけでなく、バックエンドでも使います。

952
01:49:29,360 --> 01:49:34,480
サーバーで受け取ったデータを検証します。

953
01:49:34,480 --> 01:49:39,520
サーバーで受け取るデータはフォームに入力するものとほとんど同じなので、同じバリデーションスキーマを共有できます。

954
01:49:39,520 --> 01:49:47,680
そのため、libフォルダの共有ファイルにこのスキーマを置くことにします。

955
01:49:47,680 --> 01:49:55,520
という名前の定数をエクスポートします。

956
01:49:55,520 --> 01:50:03,200
このフォームに履歴書のタイトルと説明を入力します。

957
01:50:04,720 --> 01:50:13,200
zをZotライブラリからインポートし、z.objectで次のようにスキーマを作成します。

958
01:50:13,200 --> 01:50:20,880
括弧 中括弧 ここにこのフォームに入れたいフィールドを入れます。

959
01:50:20,880 --> 01:50:29,440
説明したように、タイトルと説明で、それぞれz.stringです。

960
01:50:29,440 --> 01:50:35,440
文字列を受け取り、数値や他の何かではない場合、.trim を呼び出すこともできます。

961
01:50:35,440 --> 01:50:40,880
.trimを呼び出すと、入力の最初と最後にある空白が自動的に削除されます。

962
01:50:40,880 --> 01:50:48,160
しかし、タイトルを挿入する必要はない。

963
01:50:48,160 --> 01:50:54,880
オプショナルにすることもできるが、オプショナルには空文字列ではなくundefinedしか含まれない。

964
01:50:54,880 --> 01:51:02,640
この関数にz.iteralを渡し、そこに空文字列を渡す。

965
01:51:02,640 --> 01:51:10,320
undefinedや空文字列を空の値として渡すことができます。

966
01:51:10,320 --> 01:51:16,800
というconstをエクスポートし、それをsch.optional stringに代入する。

967
01:51:16,800 --> 01:51:24,560
をエクスポートし、それをスキーマに代入します。

968
01:51:24,560 --> 01:51:31,840
これはちょっとしたトリックです。

969
01:51:31,840 --> 01:51:39,360
スキーマのエクスポート型から型を生成することもできます。

970
01:51:39,360 --> 01:51:47,600
この名前は任意で、好きな名前をつけることができます。

971
01:51:47,600 --> 01:51:54,800
を呼び出し、ここに一般情報スキーマの型を渡します。

972
01:51:54,800 --> 01:52:01,200
この2つの値とオプションの文字列を含む型を作成します。

973
01:52:01,200 --> 01:52:09,440
次に、このスキーマを使用する最初のフォームを作成します。

974
01:52:09,440 --> 01:52:17,360
このスキーマを使う最初のフォームを作成します。

975
01:52:17,360 --> 01:52:26,480
editorにformsという新しいフォルダを作り、その中にgeneral info
formを置きたい。

976
01:52:26,480 --> 01:52:37,600
ドットtsxをエディタフォームの一般情報フォームの中に置き、このコンポーネントをここからエクスポートします。

977
01:52:37,600 --> 01:52:49,520
このコンポーネントをエクスポートします。

978
01:52:49,520 --> 01:52:55,680
履歴書エディタはすでにクライアントコンポーネントなので、このファイルをクライアントコンポーネントにする必要はありません。

979
01:52:55,680 --> 01:53:01,440
クライアントコンポーネントの子なので、このファイルをクライアントコンポーネントにする必要はありません。

980
01:53:01,440 --> 01:53:09,040
この左側のテキストを削除して、代わりに一般情報フォームをレンダリングします。

981
01:53:09,040 --> 01:53:20,080
また、このdivにこのように3つのパディングを与えたいと思います。

982
01:53:20,080 --> 01:53:30,640
一般情報フォームtsxファイルの一番上にconstフォームを作成し、useフォームを呼び出します。

983
01:53:30,640 --> 01:53:36,960
チャットcnのドキュメントで説明されています。

984
01:53:36,960 --> 01:53:44,080
ここでinfoの値を生成するために型を設定します。

985
01:53:44,080 --> 01:53:51,120
これはスキーマから生成された型であり、reactフックフォームにフォームが後で受け取る値を伝えます。

986
01:53:51,120 --> 01:53:58,960
次に、2つの色で括弧を囲んで、リゾルバを渡します。

987
01:53:59,920 --> 01:54:06,480
にzotリゾルバを渡しますが、自動インポートではうまくいかないので、手動でインポートしましょう。

988
01:54:06,480 --> 01:54:13,840
フックフォームのスラッシュ・リゾルバから中かっこをインポートし、この中で

989
01:54:13,840 --> 01:54:22,800
このようなリゾルバは実際にはスラッシュ・リゾルバであり、スラッシュ・ゾットである。

990
01:54:24,560 --> 01:54:32,160
このスキーマに一般的な情報ソートスキーマを渡します。

991
01:54:32,160 --> 01:54:38,560
スキーマをフォームに接続し、reactフックフォームが入力がどのようなルールに従うかを確認します。

992
01:54:38,560 --> 01:54:44,320
ここで設定したルールはとてもシンプルです。

993
01:54:44,320 --> 01:54:49,840
というのも、これらのフィールドは単なるオプションフィールドだからです。

994
01:54:49,840 --> 01:54:55,440
あるフィールドには数字だけを入力しなければならないといったバリデーションがあった場合、このリゾルバは

995
01:54:55,440 --> 01:55:03,520
すべてのフィールドが正しく入力されるまでフォームを送信できるようにするものです。

996
01:55:03,520 --> 01:55:10,560
バリデーションスキーマのオートコンプリートを取得します。

997
01:55:10,560 --> 01:55:16,480
で初期化することが推奨されています。

998
01:55:16,480 --> 01:55:23,360
空文字列で初期化することが推奨されています。

999
01:55:23,360 --> 01:55:34,000
の最大幅をxlにして、7xlではなくxlと小さくします。

1000
01:55:34,000 --> 01:55:38,160
を中央に配置し、縦の間隔を6

1001
01:55:40,960 --> 01:55:47,840
ここに別のdivを置き、スペースyを1.5、テキストを中央に配置する。

1002
01:55:47,840 --> 01:55:55,120
これは見出しh2を含むことになる。

1003
01:55:55,120 --> 01:56:05,920
テキストは2xl、フォントは半太字で、これには一般的な情報を書きます。

1004
01:56:06,560 --> 01:56:10,800
で、その下にまた少し説明文を入れます。

1005
01:56:10,800 --> 01:56:24,560
テキストをsm、前景をミュートにして、これは履歴書には掲載されませんと書きます。

1006
01:56:24,560 --> 01:56:32,560
これはフォームのこのステップの単なる説明文です。

1007
01:56:32,560 --> 01:56:40,080
そして、このdivの閉じタグの下に、大文字のfフォーム・コンポーネントを置く。

1008
01:56:40,080 --> 01:56:47,600
reactフックフォームではなく、componentsフォルダにあるshadcnフォームコンポーネントだ。

1009
01:56:47,600 --> 01:56:54,880
ここにuse formから取得したフォームを広げて、すべてをつなげます。

1010
01:56:54,880 --> 01:57:00,960
そして、ここに小文字のフォームを置く必要があります。

1011
01:57:02,800 --> 01:57:08,560
小文字のフォームの縦の間隔は3です。

1012
01:57:08,560 --> 01:57:14,960
タイトル用と説明用のフォームフィールドがあります。

1013
01:57:14,960 --> 01:57:20,720
shadcnドキュメントに記載されています。

1014
01:57:20,720 --> 01:57:28,080
にラップし、ここでいくつかの設定を行います。

1015
01:57:28,080 --> 01:57:36,080
をフォームの値に接続する必要があります。これはコントロールプロップを通して行います。

1016
01:57:36,080 --> 01:57:43,520
入力フィールドの名前にはオートコンプリートを使います。

1017
01:57:43,520 --> 01:57:50,640
このフィールドはタイトル入力フィールドです。

1018
01:57:50,640 --> 01:57:56,560
ここに表示したい実際のフォームフィールドを入れ、中カッコで囲み、矢印関数をこのように記述します。

1019
01:57:57,280 --> 01:58:03,120
そしてまた中括弧ではなく括弧を入れます。

1020
01:58:03,120 --> 01:58:11,840
この構造化されていない引数の中に、必要な値を含むフィールドがあります。

1021
01:58:11,840 --> 01:58:15,120
ここにフォーム項目を置く

1022
01:58:15,120 --> 01:58:24,640
このフォーム項目にフォーム・ラベルを置き、このラベルにはプロジェクト名と書く。

1023
01:58:24,640 --> 01:58:31,040
入力フィールドの等号と大の間にスペースがあってはならない。

1024
01:58:31,040 --> 01:58:39,120
これは矢印関数なので、フォーム・ラベルの下にフォーム・コントロールを置く。

1025
01:58:39,120 --> 01:58:45,520
入力フィールドを含むフォーム・コントロールと、componentsフォルダにある大文字のi入力を置きます。

1026
01:58:45,520 --> 01:58:52,720
大文字のiは、すでにスタイルが設定されているので、シャドクン入力として、ここに広げます。

1027
01:58:52,720 --> 01:58:59,600
このレンダー関数から渡されたフィールドをここに広げる必要があります。

1028
01:58:59,600 --> 01:59:06,960
例えば、プレースホルダーで、プレースホルダーには私のクールな履歴書と書かれています。

1029
01:59:06,960 --> 01:59:13,440
を追加して、このフォームを開いたときにカーソルが自動的に

1030
01:59:13,440 --> 01:59:20,160
フォームコントロールの下にはエラーメッセージを表示するフォームメッセージを置くことができます。

1031
01:59:20,160 --> 01:59:25,920
フォーム・コントロールの下には、入力が正しくない場合にこの入力フィールドのエラー・メッセージを表示するフォーム・メッセージを置くことができる。

1032
01:59:25,920 --> 01:59:31,120
これらのフィールドはすべて任意であり、文字列であり、文字列には任意の文字が含まれるため、基本的にエラーメッセージが表示されることはありません。

1033
01:59:31,120 --> 01:59:36,480
エラーメッセージが表示されることは基本的にない。

1034
01:59:36,480 --> 01:59:42,240
このフォームのメッセージはソートからのエラーメッセージを表示します。

1035
01:59:42,240 --> 01:59:50,560
スキーマのエラーメッセージが表示されます。

1036
01:59:50,560 --> 02:00:00,320
を複製して、タイトルをdescriptionに変更し、フォームのラベルも変更してみましょう。

1037
02:00:00,320 --> 02:00:09,440
入力フィールドはまだ必要ですが、オートフォーカスを外して、プレースホルダーを次のようにします。

1038
02:00:10,640 --> 02:00:15,280
次の仕事のための履歴書 例えば、これは単なるプレースホルダーのテキストです。

1039
02:00:15,280 --> 02:00:23,120
そしてもうひとつ、フォーム・コントロールの下に、フォームの説明を記述することができます。

1040
02:00:23,120 --> 02:00:29,360
これは説明テキストで、アクセシビリティのためにフォームに適切に接続されています。

1041
02:00:29,360 --> 02:00:34,000
スクリーンリーダーは、フォームの説明がこの入力フィールドに属していることを知ることができます。

1042
02:00:34,000 --> 02:00:41,120
このフォーム項目がすべてを結びつけます。

1043
02:00:41,120 --> 02:00:50,720
このフォームの説明文もすでにスタイル設定されています。

1044
02:00:50,720 --> 02:00:59,440
さて、これで最初のフォームが完成しました。

1045
02:00:59,440 --> 02:01:08,160
エディターの次のステップでは、別のスキーマを作成します。

1046
02:01:08,160 --> 02:01:16,720
個人情報スキーマは、我々が期待するさまざまなフィールドを持つZドットオブジェクトです。

1047
02:01:16,720 --> 02:01:23,760
これはもう少し複雑で、ここにはファイルである写真もあります。

1048
02:01:24,800 --> 02:01:31,200
カスタムでは、独自のルールを設定することができます。

1049
02:01:31,200 --> 02:01:39,280
写真をアップロードする必要はない。

1050
02:01:39,280 --> 02:01:46,560
しかし、カスタムを使用する場合は、独自のルールを定義する必要があります。

1051
02:01:46,560 --> 02:01:54,080
文字列の場合は、独自のルールを設定することができます。

1052
02:01:54,080 --> 02:02:00,800
ここでは、エラー関数を通過して、チェックしたいファイルを受け取ります。

1053
02:02:00,800 --> 02:02:07,440
ブール値を返すことでルールを設定し、エラーメッセージを追加することができる。

1054
02:02:07,440 --> 02:02:12,240
このルールに従わなかった場合に表示したいエラーメッセージを追加することができる。

1055
02:02:12,240 --> 02:02:18,240
このエラーメッセージは、入力コンポーネントによって表示される。

1056
02:02:18,240 --> 02:02:23,920
バックエンドでもこれらのスキーマを使用して、正しいファイルタイプを受信するようにします。

1057
02:02:23,920 --> 02:02:30,000
エクセルファイルやPDFなどではなく、画像だけを受け取りたいからです。

1058
02:02:30,000 --> 02:02:37,120
また、ファイルが実際にファイルであることも確認したい。

1059
02:02:37,120 --> 02:02:43,520
ファイルがない場合はtrueを返す。

1060
02:02:43,520 --> 02:02:48,960
なぜかというと、写真を送る必要がないからです。写真を送らないこともできます。

1061
02:02:48,960 --> 02:02:56,400
もしファイルを送信するのであれば、それはファイル・タイプのインスタンスでなければならない。

1062
02:02:56,400 --> 02:03:03,840
画像でなければならないので、括弧を追加し、大文字のfileインスタンスをチェックする。

1063
02:03:04,640 --> 02:03:14,720
で始まり、画像はスラッシュで始まる文字列である。

1064
02:03:14,720 --> 02:03:21,120
このようにして、画像ファイルであることを確認し、カンマを追加します。

1065
02:03:21,120 --> 02:03:29,520
このルールに従わない場合に表示されるエラーメッセージを定義することができます。

1066
02:03:30,480 --> 02:03:36,560
というエラーメッセージを定義することができます。

1067
02:03:36,560 --> 02:03:42,320
バックエンドに無効なファイルを送信しようとしたときに、入力フィールドかサーバーのエラーメッセージとして表示されます。

1068
02:03:42,320 --> 02:03:48,480
nextのサーバーレス関数に送信できるのは4メガバイトまでだからだ。

1069
02:03:48,480 --> 02:03:53,120
jsのサーバーレス関数に送信できるのは4メガバイトまでで、これは写真画像としては十分なサイズです。

1070
02:03:53,120 --> 02:03:59,520
クライアント側にアップロードする必要があるが、これは別のトピックなので、別のルールで別の絞り込みを追加する。

1071
02:03:59,520 --> 02:04:06,320
ここでもファイルを通過させる。

1072
02:04:06,320 --> 02:04:16,960
あるいは、ファイルのドット・サイズが4メガバイト以下であれば、それを通過させることができる。

1073
02:04:16,960 --> 02:04:27,200
1024を1024倍すると4メガバイトになります。

1074
02:04:28,320 --> 02:04:35,120
コンマの後に、エラーメッセージ file must be less than 4mb を指定します。

1075
02:04:35,120 --> 02:04:44,160
これで、ソートを使った完全なカスタム検証ルールの設定は完了だ。

1076
02:04:44,160 --> 02:04:53,280
入力フィールドは簡単で、すべてオプションの文字列である。

1077
02:04:57,760 --> 02:05:03,360
職種 これらはすべて、フォームに入れたいさまざまな入力フィールドだ。

1078
02:05:03,360 --> 02:05:12,160
国、そしてgithub copilotはレコーディングに使わないのですでに懐かしい。

1079
02:05:12,160 --> 02:05:22,800
電話番号と最後のメールアドレスは、フォームとメールに特別なルールを追加することができます。

1080
02:05:22,800 --> 02:05:28,320
emailはemailアドレスのような形でなければならないとか、電話は数字しか使えないとか。

1081
02:05:28,320 --> 02:05:34,160
しかし、ユーザーが何を入力するかはあまり気にしないので、その必要はないと思います。

1082
02:05:34,160 --> 02:05:39,280
もしユーザーがメールアドレスに適当な単語を入力したいのであれば、私たちがそれを指示する必要はない。

1083
02:05:39,280 --> 02:05:44,480
このため、単なるオプションの文字列にしています。

1084
02:05:44,480 --> 02:05:49,680
ユーザーは好きなものを入力できるが、必要であれば、より具体的なルールを設定することもできる。

1085
02:05:50,480 --> 02:05:57,920
そしてまた、スキーマの個人情報の値から型を生成してエクスポートしたい。

1086
02:05:57,920 --> 02:06:08,480
c dot infer type of personal info schema all right
and then we need new form for our schema

1087
02:06:08,480 --> 02:06:17,520
生成するフォームと同じフォームフォルダに入れます。

1088
02:06:17,520 --> 02:06:26,400
これは、デフォルト関数をエクスポートする2番目のステップです。

1089
02:06:26,400 --> 02:06:35,360
とりあえず空のdiffに戻しましょう。

1090
02:06:35,360 --> 02:06:44,480
一般情報フォームを個人情報フォームに置き換えるだけです。

1091
02:06:44,480 --> 02:06:50,080
画面上で確認できるようにします。

1092
02:06:50,080 --> 02:06:59,280
しかし、今はこのフォームをハードコードし、さらにoverflow y autoクラスを追加します。

1093
02:06:59,280 --> 02:07:04,400
このフォームは少し大きくなり、画面の高さよりも大きくなります。

1094
02:07:04,400 --> 02:07:09,440
フォームの内容が画面より大きい場合は、この差分にスクロールバーを追加します。

1095
02:07:10,480 --> 02:07:17,360
個人情報フォームコンポーネントに戻りましょう。

1096
02:07:17,360 --> 02:07:22,160
フォームが少し大きくなっただけです。

1097
02:07:22,160 --> 02:07:29,040
を呼び出します。

1098
02:07:29,040 --> 02:07:39,680
今回もzotリゾルバを渡しましたが、自動インポートは完璧です。

1099
02:07:40,720 --> 02:07:46,960
個人情報スキーマを渡します。

1100
02:07:46,960 --> 02:07:56,880
ここでオートコンプリートを取得し、すべて空の文字列に設定します。

1101
02:07:56,880 --> 02:08:01,760
役職名 都市名

1102
02:08:04,640 --> 02:08:10,320
国 電話番号とEメール

1103
02:08:10,320 --> 02:08:18,160
ここにすべて追加して、フォームを以下のように返します。

1104
02:08:18,160 --> 02:08:24,160
最大幅をxlに設定します。

1105
02:08:26,720 --> 02:08:34,880
レイアウトは他のフォームと同じです。

1106
02:08:34,880 --> 02:08:44,480
レイアウトは他のフォームと同じで、ここにもdiffを入れ、スペースYは1.5、テキストは中央揃え、見出しはh2

1107
02:08:44,480 --> 02:08:56,240
テキストはExcelに、フォントは半太字で個人情報とし、その下に段落をテキストsmとする。

1108
02:08:57,360 --> 02:09:04,560
テキストはミュートフォアグラウンド、説明テキストには、あなた自身について教えてくださいと書かれています。

1109
02:09:04,560 --> 02:09:13,200
さあ、ここからが一番楽しいところだ。

1110
02:09:13,200 --> 02:09:18,080
コンポーネントフォルダからまた大文字のfフォームを作成しよう。

1111
02:09:19,760 --> 02:09:26,640
またこのフォームオブジェクトをpropsとしてここに広げ、また小文字のfフォームを

1112
02:09:26,640 --> 02:09:35,680
をスペースy3で囲み、それからさまざまなフォームフィールドを追加します。

1113
02:09:35,680 --> 02:09:43,280
このフォーム・フィールド・コンポーネントを自己閉鎖タグで追加し、コントロール経由でフォーム・オブジェクトに接続します。

1114
02:09:45,120 --> 02:09:48,640
これは写真の入力フィールドで、ここでもオートコンプリートを使用します。

1115
02:09:48,640 --> 02:09:58,080
ここでもレンダー・プロップがあるので、中かっこを中かっこで囲み、フィールドを中かっこで囲みます。

1116
02:09:58,080 --> 02:10:10,960
で囲み、これを矢印関数にしてフォーム項目を返します。

1117
02:10:12,000 --> 02:10:15,200
あなたの写真

1118
02:10:15,200 --> 02:10:25,360
その下にまたフォーム・コントロールを配置します。

1119
02:10:25,360 --> 02:10:36,640
そして、ここでもフィールドの値を広げる必要がある。

1120
02:10:36,640 --> 02:10:42,720
この入力フィールドの値や変更時のハンドラなどです。

1121
02:10:42,720 --> 02:10:48,080
このフィールドはこの値を取ることができない。

1122
02:10:48,080 --> 02:10:56,000
これは、このフィールドをコロン中括弧でデストラクチャリングして値を取り、残りの値をドット・ドット・ドットで囲みます。

1123
02:10:56,000 --> 02:11:02,800
ドット・ドット・ドットで残りの値を取り、この下にフィールドの値だけを適用する。

1124
02:11:02,800 --> 02:11:09,520
この方法ではこの値を無視することができる。

1125
02:11:09,520 --> 02:11:16,320
この入力フィールドのタイプをfileに設定することで、テキスト入力からこのようなファイル入力に変更することができる。

1126
02:11:16,320 --> 02:11:22,960
クリックできるファイルピッカーに変更します。

1127
02:11:22,960 --> 02:11:31,120
プロップ・イメージ・スラッシュ・アスタリスク以外のファイルは受け付けない。

1128
02:11:31,120 --> 02:11:36,640
をクリックすると、画像だけを選択できるようになります。

1129
02:11:36,640 --> 02:11:42,800
フロントエンドのバリデーションだけでは十分ではありません。

1130
02:11:42,800 --> 02:11:48,080
フロントエンドのバリデーションは、ユーザーが簡単に正しいファイルを選べるようにするためのものです。

1131
02:11:48,080 --> 02:11:54,320
バックエンドのセキュリティーを確保する必要があります。

1132
02:11:55,520 --> 02:12:03,120
そのために、ここでは変更時にeを渡すように実装している。

1133
02:12:03,120 --> 02:12:09,920
ファイルを選択すると、この入力フィールドからファイル・リストを受け取るからだ。

1134
02:12:09,920 --> 02:12:17,600
しかし、Zotスキーマはファイルリストではなく、単一のファイルを期待している。

1135
02:12:17,600 --> 02:12:23,120
そこで、ファイルリストから単一ファイルを取り出して、トークフォームに渡します。

1136
02:12:24,000 --> 02:12:31,360
次のようにしてconstファイルを作成し、e.target.filesでそれを見つけることができます。

1137
02:12:31,360 --> 02:12:36,400
ここでは、save call演算子を使わなければならない。

1138
02:12:36,400 --> 02:12:40,480
最初の要素を取得します。

1139
02:12:40,480 --> 02:12:47,120
そして、これをリアクト・トークフォームに渡します。

1140
02:12:47,120 --> 02:12:52,080
そしてファイルを渡すon change関数があります。

1141
02:12:54,080 --> 02:12:58,800
最初は少し複雑ですが、これがreactでファイルを扱う方法です。

1142
02:12:58,800 --> 02:13:05,360
next.jsの最新バージョンでは、このlintルールが少し厳しくなりました。

1143
02:13:05,360 --> 02:13:12,800
next.jsの最新バージョンでは、このlintルールが少し厳しくなり、未使用の値をここに置くことができなくなりました。

1144
02:13:12,800 --> 02:13:18,000
このルールを入力フィールドに適用したくないからです。

1145
02:13:18,000 --> 02:13:25,440
eslint.rz.jsonファイルに行って、extendsの後にカンマを追加する。

1146
02:13:25,440 --> 02:13:34,480
extendsの後にカンマを追加し、eslintのルールを上書きするためのルールキーを追加します。

1147
02:13:34,480 --> 02:13:40,480
ルールを上書きして変更することができます。

1148
02:13:40,480 --> 02:13:50,560
変更したいルールはtypescript -eslint/no-unused-varsというものです。

1149
02:13:50,560 --> 02:13:58,640
コロンと角括弧で囲んで、最初の値をerrorとする。

1150
02:13:58,640 --> 02:14:06,160
2つ目はオブジェクトで、ここには

1151
02:14:06,160 --> 02:14:18,640
ignore-rest-siblingsフィールドがあり、trueに設定します。

1152
02:14:18,640 --> 02:14:24,000
そしてご覧の通り、エラーが消えた。

1153
02:14:24,000 --> 02:14:30,640
もしエラーがまだ表示されるようであれば、ideを再起動してください。

1154
02:14:30,640 --> 02:14:38,080
を再起動する必要があるかもしれません。

1155
02:14:38,080 --> 02:14:45,120
コマンドでeslintサーバーを再起動することもできます。

1156
02:14:45,120 --> 02:14:52,000
というエラーメッセージが表示されます。

1157
02:14:52,000 --> 02:14:58,160
このエラーメッセージを実際に見てみるために、コメントアウトしてこの部分以外を削除してみましょう。

1158
02:14:58,160 --> 02:15:04,080
画像以外のファイルをアップロードすることはスキーマで許可されていません。

1159
02:15:04,080 --> 02:15:10,240
を選択しても、エラーメッセージが表示されるだけなので、自動的にはトリガーされません。

1160
02:15:10,240 --> 02:15:16,000
フォームを送信しようとしたときにエラーメッセージが表示されるだけだからです。

1161
02:15:16,000 --> 02:15:21,760
というのも、変更内容をすぐにプレビューに表示したいからです。

1162
02:15:21,760 --> 02:15:26,720
returnステートメントの上にuseエフェクトを設置します。

1163
02:15:26,720 --> 02:15:36,240
依存配列をここに追加します。

1164
02:15:36,240 --> 02:15:42,880
レジュームデータを含むページに移動させます。

1165
02:15:42,880 --> 02:15:53,600
非同期エラー関数を渡す。

1166
02:15:53,600 --> 02:16:01,520
中括弧で囲んだこのような関数に、非同期のエラー関数を渡します。

1167
02:16:01,520 --> 02:16:08,480
まずフォームを検証し、入力が有効かどうかをチェックしたいので

1168
02:16:08,480 --> 02:16:17,200
constは有効であり、form.trigger()待ちで実行できる。

1169
02:16:17,200 --> 02:16:22,640
なぜなら、バリデーションはフォームを送信するときにも行われるからです。

1170
02:16:22,640 --> 02:16:28,560
送信ボタンがない代わりに、常に最新の入力を親ページに渡します。

1171
02:16:28,560 --> 02:16:34,320
をすぐに親ページに渡したいので、このバリデーションロジックを自分たちで書かなければなりません。

1172
02:16:36,000 --> 02:16:42,400
もしvalidがfalseであれば、無効な入力があるためリターンしたい。

1173
02:16:42,400 --> 02:16:48,160
もし入力が有効であれば、レジュームデータを更新したい。

1174
02:16:48,160 --> 02:16:55,920
この処理は後で行うことにして、ここではコメントを残しておこう。

1175
02:16:55,920 --> 02:17:02,560
なぜならこの中にunsubscribeがあるからです。

1176
02:17:02,560 --> 02:17:08,880
複数のフォームウォッチャーを作りたくないからです。

1177
02:17:08,880 --> 02:17:14,400
新しいリスナーを作成する前に、前のリスナーの登録を解除する必要があります。

1178
02:17:14,400 --> 02:17:20,640
ところで、このクリーンアップ関数の使い方については、リアクトのベストプラクティスのコースで説明しました。

1179
02:17:20,640 --> 02:17:25,360
このクリーンアップ関数の使い方については、最初に紹介したリアクトのベストプラクティスコースで説明しました。

1180
02:17:25,360 --> 02:17:31,920
codingandflow.com/reactbestpracticesで入手できる。

1181
02:17:31,920 --> 02:17:37,200
しかし、一言で言えば、私たちはここで配信停止関数を返さなければなりません。

1182
02:17:37,200 --> 02:17:42,880
このユースエフェクトが実行されると、新しいリスナーを作成する前に、まずunsubscribeを呼び出してこのリスナーを削除します。

1183
02:17:42,880 --> 02:17:49,600
こうすることで、フォームウォッチャーが常に1つだけであることを確認できる。

1184
02:17:49,600 --> 02:17:55,760
エフェクトを使うためには、フォームを依存関係として渡さなければならない。

1185
02:17:55,760 --> 02:18:01,600
まだ何も保存されませんが、フォームのバリデーションがトリガーされます。

1186
02:18:01,600 --> 02:18:06,880
もう一度exifファイルを選択しようとすると、すぐにエラーメッセージが表示されます。

1187
02:18:06,880 --> 02:18:14,000
というエラーメッセージが表示されます。

1188
02:18:14,000 --> 02:18:20,480
画像を選択すれば、このエラーメッセージは表示されません。

1189
02:18:20,480 --> 02:18:29,680
最初のフォームフィールドの下にdivを置き、グリッドを呼び出します。

1190
02:18:30,640 --> 02:18:36,400
と3つのグリッドのギャップを入れます。

1191
02:18:36,400 --> 02:18:39,280
フォームフィールド

1192
02:18:39,280 --> 02:18:52,080
を追加し、フォームコントロールを追加します。

1193
02:18:52,080 --> 02:19:01,920
render propでフィールドを再構築し、エラー関数を渡してフォーム項目をレンダリングします。

1194
02:19:01,920 --> 02:19:12,400
これはいつも同じ構造のフォームラベルです。

1195
02:19:14,640 --> 02:19:24,720
フィールドを再構築し、フォームコントロールの下にエラーメッセージを表示します。

1196
02:19:24,720 --> 02:19:34,240
姓の入力フィールドを複製します。

1197
02:19:35,440 --> 02:19:44,320
という入力フィールドをコピーして、その下にもう一つ追加しよう。

1198
02:19:44,320 --> 02:19:56,000
このフォームフィールドをコピーして、次の行のdivの下にもう1つ配置します。

1199
02:19:56,000 --> 02:20:02,320
そして、もう2つの入力フィールドが隣り合っている。

1200
02:20:02,320 --> 02:20:08,400
同じコードを何度も書く必要がないように、このdiv全体をコピーしましょう。

1201
02:20:08,400 --> 02:20:13,520
下に貼り付けてください。

1202
02:20:13,520 --> 02:20:18,560
そして国

1203
02:20:18,560 --> 02:20:30,480
電話番号とEメールの入力フィールドが必要なので、もう一度フォームをコピーします。

1204
02:20:30,480 --> 02:20:39,680
フィールドをコピーします。

1205
02:20:39,680 --> 02:20:47,040
そして、入力フィールドのタイプを設定することで、どのような文字が許可されるかを変更することができます。

1206
02:20:47,040 --> 02:20:52,000
入力フィールドのタイプを設定することができます。

1207
02:20:52,000 --> 02:20:57,520
特に携帯電話では便利だと思います。

1208
02:20:57,520 --> 02:21:04,000
最後の入力フィールドはEメールです。

1209
02:21:04,000 --> 02:21:13,440
フォームのラベルにはemailとあり、ここでもタイプをemailに設定することでキーボードを変更することができます。

1210
02:21:13,440 --> 02:21:20,320
これで2つ目のフォームの準備ができました。

1211
02:21:20,320 --> 02:21:25,840
そのためには、フォームのさまざまなステップを格納した配列を作成します。

1212
02:21:25,840 --> 02:21:30,800
と対応するコンポーネントを含む配列を作成します。

1213
02:21:30,800 --> 02:21:39,280
このファイルをsteps.tsと呼ぶことにしましょう。

1214
02:21:39,280 --> 02:21:46,320
stepsというconstをエクスポートしている。

1215
02:21:46,320 --> 02:21:53,360
この配列に要素を追加するときに、オートコンプリートと型の安全性を確保するために、stepsの後に中括弧と角括弧を書く。

1216
02:21:53,360 --> 02:21:59,920
これはオブジェクトの配列で、各オブジェクトには文字列型のタイトルが含まれているはずだからだ。

1217
02:21:59,920 --> 02:22:07,120
レンダリングしたいフォーム・コンポーネント、たとえば一般情報フォームや

1218
02:22:07,120 --> 02:22:13,280
個人情報フォームで、これはリアクト・コンポーネントでなければなりません。

1219
02:22:13,280 --> 02:22:22,640
コンポーネントの型と、ページを更新したときにこのフォームを開くためにURLに入れるキーを指定します。

1220
02:22:22,640 --> 02:22:30,000
これはページを更新したときにこのフォームを開くためにurlに入れるもので、これも文字列です。

1221
02:22:30,000 --> 02:22:39,600
オートコンプリートでタイトルを設定することができます。

1222
02:22:39,600 --> 02:22:51,200
カンマ......コンポーネントは一般情報フォームコンポーネントで、キーは一般マイナス情報です。

1223
02:22:51,200 --> 02:23:02,240
を小文字で入力し、2つ目のタイトルを追加する。

1224
02:23:02,240 --> 02:23:14,960
キーは個人情報マイナス情報です。

1225
02:23:16,000 --> 02:23:22,960
もちろん、ここにはもっと多くのエントリーを追加するが、今はこの2つだけだ。

1226
02:23:22,960 --> 02:23:28,560
フォームレイアウトにパンくずを置きたい。

1227
02:23:28,560 --> 02:23:34,640
を設置したい。

1228
02:23:34,640 --> 02:23:42,000
shadcnがこの構造なので、このために別のコンポーネントを作成しましょう。

1229
02:23:42,720 --> 02:23:50,720
を右クリックして、パンくずドットtsxファイルを作成します。

1230
02:23:50,720 --> 02:24:03,280
デフォルト関数bread
crumbsをエクスポートし、このコンポーネントには小道具が必要なので、上に

1231
02:24:03,280 --> 02:24:12,400
というインターフェイスを作成します。

1232
02:24:12,400 --> 02:24:17,680
しかし、この情報はurlに含まれているため、ページから取得します。

1233
02:24:17,680 --> 02:24:26,080
に含まれているので、これを文字列型のcurrent stepという小道具として渡します。

1234
02:24:26,080 --> 02:24:34,880
パンくずリンクをクリックしたら、現在のステップを更新したい。

1235
02:24:34,880 --> 02:24:43,040
これは新しいステップを受け取る関数で、何も返しません。

1236
02:24:43,040 --> 02:24:51,520
そして、ブレッドクラムのプロパティを再構築して、現在のステップを見つけます。

1237
02:24:51,520 --> 02:25:02,960
を見つけ、現在のステップを設定し、このコンポーネントから差分を返します。

1238
02:25:02,960 --> 02:25:09,680
ブレッドクラムの使い方はshadcnのドキュメントを参照してください。

1239
02:25:09,680 --> 02:25:16,080
この全体をcomponentsフォルダからブレッドクラムにラップし、この中にブレッドクラムリストを入れます。

1240
02:25:16,080 --> 02:25:24,080
パンくずリストがあり、ここにさまざまな要素をレンダリングしたいので、ここから取得します。

1241
02:25:24,080 --> 02:25:32,480
steps配列から取得し、エクスポートする。

1242
02:25:32,480 --> 02:25:40,000
各ステップをパンくずアイテムにマッピングする。

1243
02:25:40,000 --> 02:25:46,960
ここにパンくずリンクとセパレーターの2つの要素を入れたいのですが、できません。

1244
02:25:46,960 --> 02:25:53,120
つの要素をこのreturnブロックの中に直接入れることはできない。

1245
02:25:53,120 --> 02:25:58,640
このようにフラグメントを作成しますが、テキストにも違いがあります。

1246
02:25:58,640 --> 02:26:07,440
リアクト・ドット・フラグメントでこのようなフラグメントを作成することもできます。

1247
02:26:07,440 --> 02:26:14,400
配列のレンダリングに必要なキーを適用できるからです。

1248
02:26:14,400 --> 02:26:20,240
というのも、配列のレンダリングに必要なキーを適用できるからです。

1249
02:26:20,240 --> 02:26:30,080
配列の中にパンくず項目を置き、パンくず項目の下にパンくずセパレーターを置く。

1250
02:26:30,080 --> 02:26:37,200
そして、パンくずアイテムの中に、リンクか通常のテキストをレンダリングします。

1251
02:26:37,200 --> 02:26:44,080
現在のページは通常のテキストをレンダリングする必要がある。

1252
02:26:44,080 --> 02:26:52,880
ステップ・ドット・キーが現在のステップと等しければ、ステップとはマップの反復における現在のステップのことである。

1253
02:26:52,880 --> 02:26:59,760
であれば、あるコンポーネントのクエスチョンマークをレンダリングし、そうでなければ

1254
02:26:59,760 --> 02:27:06,560
別のコンポーネントをレンダリングしたい。

1255
02:27:06,560 --> 02:27:15,760
リンクのない通常のテキストであるブレッドクラムページをレンダリングし、現在のステップの読みやすい名前であるステップドットタイトルを表示します。

1256
02:27:15,760 --> 02:27:23,920
私たちはこれをここにレンダリングしますが、もしこの要素が現在アクティブでなければ、パンクラムリンクをレンダリングします。

1257
02:27:23,920 --> 02:27:31,920
リンクではなく、ボタンをレンダリングしたいからです。

1258
02:27:31,920 --> 02:27:37,920
リンクではないので、クリック・ハンドラが必要ですが、スタイルされるべきではないので、小文字のbボタンを使います。

1259
02:27:37,920 --> 02:27:47,120
を使い、ステップ・ドット・タイトルをレンダリングする。

1260
02:27:47,120 --> 02:27:54,160
現在のステップを呼び出し、親に渡してステップをアクティブにしたいので、ここでは

1261
02:27:54,160 --> 02:28:02,480
エラー関数を渡して現在のステップを呼び出し、ステップ・ドット・キーを渡します。

1262
02:28:02,480 --> 02:28:12,160
これを保存して、レジュームエディタに入れましょう。

1263
02:28:12,160 --> 02:28:17,920
レジュメエディタの一番上にある

1264
02:28:18,720 --> 02:28:24,400
現在アクティブなフォームが url に入力されていることを思い出してください。

1265
02:28:24,400 --> 02:28:29,520
クライアントコンポーネントでは、use searchでこれを行うことができます。

1266
02:28:29,520 --> 02:28:35,200
フックで行うこともできます。

1267
02:28:35,200 --> 02:28:41,520
として転送することもできますが、このフックがあるため、その必要はありません。

1268
02:28:41,520 --> 02:28:50,320
現在アクティブなステップを取得することができますので、const current
stepを作成し、searchparams.getから取得します。

1269
02:28:50,320 --> 02:28:58,800
キーはstepで、もしここに値がなければ、配列の最初のstepをアクティブにします。

1270
02:28:58,800 --> 02:29:06,000
検索パラメータが未定義の場合、フォールバック値として、一般的な情報フォームをアクティブにします。

1271
02:29:06,720 --> 02:29:14,560
stepsはstepsファイルからインポートしたものである。

1272
02:29:14,560 --> 02:29:22,240
ステップを更新するために、set stepという関数を作成します。

1273
02:29:22,240 --> 02:29:32,400
この関数は新しいキーを受け取り、新しい検索パラメータを作成します。

1274
02:29:32,400 --> 02:29:39,200
フックから既存の検索パラメータを渡す。

1275
02:29:39,200 --> 02:29:45,280
この検索パラメータはコピーされますが、すでにある他のパラメータはすべて新しいパラメータに保持されます。

1276
02:29:45,280 --> 02:29:50,560
つまり、ここにレジュメIDがあり、ステップを更新したいだけであれば、そのレジュメIDを新しいparamsに持たせます。

1277
02:29:50,560 --> 02:29:57,360
同じレジュメIDを新パラメータにコピーするわけです。

1278
02:29:57,360 --> 02:30:08,000
stepパラメータだけを変更したいのです。新しい検索パラメータのドットセットでは、キーは再びstepとなり、値はキーとなります。

1279
02:30:08,000 --> 02:30:14,400
この関数に渡すデータを後でurlに貼り付けたいので、次のようにする。

1280
02:30:14,400 --> 02:30:23,920
window dot history dot push state 第1引数のdataはnull
第2引数は

1281
02:30:23,920 --> 02:30:29,680
は空の文字列で、これはこの関数の構文に過ぎない。

1282
02:30:29,680 --> 02:30:36,080
検索パラメータはクエスチョンマークで始まるので、ここにバックスティック文字列のクエスチョンマークを追加します。

1283
02:30:36,080 --> 02:30:43,280
クエスチョンマークと変数プレースホルダーを追加します。

1284
02:30:43,280 --> 02:30:49,200
これで検索パラメーターのステップが更新される。

1285
02:30:49,200 --> 02:30:56,480
そして、この新しいURLをブラウザにプッシュする。

1286
02:30:56,480 --> 02:31:02,880
を使うこともできることをご存じだろう。

1287
02:31:02,880 --> 02:31:09,200
ルーター・ドット・プッシュを使うと、実際にサーバーにリクエストしなければならないという違いがあります。

1288
02:31:09,200 --> 02:31:16,240
一方、window history push stateを使用すると、遅延は発生しない。

1289
02:31:16,240 --> 02:31:22,000
検索パラメーターを即座にurlに入れるだけなので、待つ必要がない。

1290
02:31:22,000 --> 02:31:27,600
というのも、もし遅延があると、パンくずをクリックしたときに、アプリの反応が悪くなってしまうからです。

1291
02:31:27,600 --> 02:31:33,040
をクリックし、フォームが切り替わるまで半秒ほどかかるからです。

1292
02:31:33,040 --> 02:31:37,440
すぐにフォームが切り替わるので、とてもキビキビして速く感じます。

1293
02:31:37,440 --> 02:31:43,840
もちろん、個人情報フォームやその他のフォームをレンダリングする必要はありません。

1294
02:31:43,840 --> 02:31:50,080
配列で現在選択されているフォームをレンダリングするために、以下にフォームコンポーネントを作成します。

1295
02:31:50,080 --> 02:31:55,680
というのも、ここにコンポーネントを格納したいからです。

1296
02:31:55,680 --> 02:32:02,000
というのも、ここにはコンポーネントを格納したいからである。

1297
02:32:02,000 --> 02:32:08,400
ステップ配列の中で、現在アクティブなキーのコンポーネントを探します。

1298
02:32:09,760 --> 02:32:17,040
そこで、このfind関数を呼び出す。

1299
02:32:17,040 --> 02:32:25,120
が現在のステップと等しいステップを返したい。

1300
02:32:25,120 --> 02:32:35,840
そして、スクロールダウンして個人情報フォームを削除し、代わりに

1301
02:32:35,840 --> 02:32:45,680
をレンダリングします。

1302
02:32:45,680 --> 02:32:56,800
そしてzカレントステップ関数はzステップ関数です。

1303
02:32:56,800 --> 02:33:01,760
フォーム・コンポーネントをレンダリングしたいのですが、findがundefinedを返すことがあるので、undefinedになる可能性があります。

1304
02:33:02,480 --> 02:33:09,120
そのため、ここに式を追加して、フォーム・コンポーネントが定義されているかどうかをチェックする必要があります。

1305
02:33:09,120 --> 02:33:14,800
フォーム・コンポーネントが定義されていれば、それをレンダリングします。

1306
02:33:14,800 --> 02:33:21,440
これを保存して、見てみよう。

1307
02:33:21,440 --> 02:33:28,960
パンくずを囲むdiffにスペースy6を追加して、ここにスペースを追加します。

1308
02:33:30,000 --> 02:33:37,120
そして、この最後の仕切りを取り除きたい。

1309
02:33:37,120 --> 02:33:42,880
パンくずアイテムが表示され、セパレーターが表示される。

1310
02:33:42,880 --> 02:33:49,520
別のクラスを追加し、最後のモディファイアを使用して、次のようにします。

1311
02:33:49,520 --> 02:33:55,440
これで、最後の要素だけが完璧に非表示になります。

1312
02:33:55,440 --> 02:34:01,120
つの仕切りが表示されます。

1313
02:34:01,120 --> 02:34:08,400
そして、この切り替えはご覧のように即座に行われ、URLのキーが更新されます。

1314
02:34:08,400 --> 02:34:15,120
ページを更新しても、以前と同じフォームが開かれたままです。

1315
02:34:15,120 --> 02:34:20,400
urlに現在のステップを入力することで、次のようなクールな副次的効果が得られます。

1316
02:34:20,400 --> 02:34:25,600
戻るボタンをクリックすれば、前のフォームに戻れる。

1317
02:34:25,600 --> 02:34:30,720
同じページであるにもかかわらず、このステップをurlに入れることで、ナビゲートできるのです。

1318
02:34:30,720 --> 02:34:34,800
もしこれが必要なければ、変更することもできます。

1319
02:34:34,800 --> 02:34:43,600
プッシュ状態を置換状態に変更することもできます。

1320
02:34:43,600 --> 02:34:49,360
しかし、私はこのような形が好きだ。

1321
02:34:49,360 --> 02:34:54,960
と次のステップのボタンを使えるようにしたい。

1322
02:34:54,960 --> 02:35:02,240
フッター全体を別のファイルにして整理したいので、レジュメエディターからこのフッタータグ全体を切り取って、新しい

1323
02:35:02,240 --> 02:35:12,400
フッターtsxと呼びます。

1324
02:35:12,400 --> 02:35:21,680
フッターをエクスポートし、このフッターを返します。

1325
02:35:21,680 --> 02:35:29,920
そして、パンくずと同じように、現在アクティブなステップをこのコンポーネントに渡す必要があります。

1326
02:35:29,920 --> 02:35:34,880
ステップを変更するコールバック関数を渡す必要があります。

1327
02:35:34,880 --> 02:35:42,080
にあるため、フッタープロップスというインターフェイスを作成します。

1328
02:35:42,080 --> 02:35:50,080
とコールバック関数を渡します。

1329
02:35:50,080 --> 02:35:58,400
という関数があり、新しいステップを受け取って何も返しません。

1330
02:35:58,400 --> 02:36:08,560
現在のステップとz現在のステップを再構築します。

1331
02:36:08,560 --> 02:36:15,600
古いフッターをカットし、大文字のfフッターを追加します。

1332
02:36:15,600 --> 02:36:23,120
と、パンくずで使ったzステップ関数を渡します。

1333
02:36:23,120 --> 02:36:32,640
フッターコンポーネントに戻り、次のステップと前のステップを配列で見つける必要がある。

1334
02:36:32,640 --> 02:36:37,760
ボタンに機能を追加できるようにするためだ。

1335
02:36:37,760 --> 02:36:43,120
なぜなら、これはいくつかのロジックを必要とするからです。

1336
02:36:43,120 --> 02:36:50,320
を作成するコンポーネント内にカプセル化します。

1337
02:36:50,320 --> 02:36:57,280
このために、stepsファイルからsteps配列を取り出し、前のステップを見つける必要があります。

1338
02:36:57,280 --> 02:37:03,360
ここで各ステップを通過するわけですが、実はこのステップには興味がありません。

1339
02:37:03,360 --> 02:37:09,040
このアンダースコアという名前は、未使用の変数につけられるものです。

1340
02:37:09,040 --> 02:37:16,640
そして、次のステップを見つけるために、このようにエラー関数を追加します。

1341
02:37:16,640 --> 02:37:29,280
インデックスに1を足したドット・キーが現在のステップに等しい場合、次のステップに進む。

1342
02:37:29,280 --> 02:37:35,440
インデックスに1を足したものが現在のステップなので、次のインデックスが現在のステップとなる。

1343
02:37:35,440 --> 02:37:41,600
このようにすれば、この配列から前のステップを見つけることができる。

1344
02:37:41,600 --> 02:37:47,600
このインデックスが存在しないので、セーフコール演算子を追加しなければならない。

1345
02:37:47,600 --> 02:37:52,240
というのも、次のステップも前のステップもないからだ。

1346
02:37:53,200 --> 02:38:00,880
ここではキーが必要で、次のステップのドット検索も同じように行う。

1347
02:38:00,880 --> 02:38:04,800
再び各インデックスを取る

1348
02:38:04,800 --> 02:38:14,880
今回は、インデックスから1を引いたステップで、前の要素は現在のステップでなければなりません。

1349
02:38:14,880 --> 02:38:23,040
このように、安全な呼び出し演算子をここに追加し、新しいキーが必要になる。

1350
02:38:23,040 --> 02:38:28,480
chatのgptとgithubのcopilotは本当に優秀だ。

1351
02:38:28,480 --> 02:38:35,440
前のステップでcopilotがコードを書いてくれた。

1352
02:38:35,440 --> 02:38:43,200
前のステップのボタンはクリック時にハンドラを受け取ります。

1353
02:38:43,200 --> 02:38:48,880
というのも、前のステップが定義されていないかもしれないからだ。

1354
02:38:48,880 --> 02:38:56,640
エラー関数を渡す代わりに、前のステップが定義されているかどうかをチェックします。

1355
02:38:56,640 --> 02:39:05,200
もし前のステップが未定義なら、エラー関数を渡す。

1356
02:39:05,200 --> 02:39:10,480
が定義されていない場合、クリックリスナーを設定したくないので、クリックリスナーにundefinedを渡します。

1357
02:39:10,480 --> 02:39:19,680
次のステップをクリックしたときに、次のステップが定義されているかどうかをチェックする。

1358
02:39:19,680 --> 02:39:25,920
が定義されているかどうかをチェックし、エラー関数を渡して現在のステップを次のステップに設定します。

1359
02:39:25,920 --> 02:39:33,120
そうでなければ、クリックリスナーをundefinedに設定します。

1360
02:39:33,120 --> 02:39:39,520
対応するステップが定義されていない場合、これらのボタンをグレーアウトした状態で表示することも意味がある。

1361
02:39:39,520 --> 02:39:47,200
従って、前のステップのボタンでは、前のステップが定義されていない場合、これを無効にします。

1362
02:39:47,200 --> 02:39:54,480
同様に、次のステップのボタンも、次のステップが定義されていない場合は無効にします。

1363
02:39:54,480 --> 02:40:02,960
次のステップはありませんが、前のステップはあります。

1364
02:40:02,960 --> 02:40:09,440
これらのボタンはパンくずとulと常に同期している。

1365
02:40:09,440 --> 02:40:15,520
もちろん、今はこの入力はどこにも保存されていない。

1366
02:40:15,520 --> 02:40:21,280
を表示する場所なので、この状態をレジュームエディタに保存したいのです。

1367
02:40:21,280 --> 02:40:27,200
というのも、ここはすべてのフォームとプレビューを表示する場所だからです。

1368
02:40:27,200 --> 02:40:37,040
エディタコンポーネントに戻り、use stateを追加します。

1369
02:40:37,040 --> 02:40:45,040
使用状態で初期化しますが、ここで型も設定します。

1370
02:40:45,040 --> 02:40:50,400
履歴書の値の型を設定します。

1371
02:40:50,400 --> 02:40:56,000
個人情報フォームだけでなく、将来的に追加される他のすべてのフォームにあるすべてのフィールドを含む型が必要です。

1372
02:40:56,000 --> 02:41:02,560
しかし、もっと賢い方法は、すでにあるフォーム・スキーマを使い、それらをひとつの大きなスキーマにまとめることだ。

1373
02:41:02,560 --> 02:41:07,760
この大きなスキーマから型を生成し、履歴書全体の型を作成することができます。

1374
02:41:07,760 --> 02:41:14,880
また、この大きなスキーマを使って、後でバックエンドで履歴書を検証することもできます。

1375
02:41:14,880 --> 02:41:21,040
というのも、すべてのデータを一度に送信するためです。

1376
02:41:21,040 --> 02:41:30,480
履歴書スキーマと呼ばれる定数をエクスポートし、それをzドットオブジェクトに代入します。

1377
02:41:30,480 --> 02:41:40,080
ドット・ドット・ドット一般情報スキーマ・ドット・シェイプとドット・ドット・ドット個人情報スキーマ・ドット・シェイプを渡す。

1378
02:41:40,080 --> 02:41:47,520
このようにして、これら2つのスキーマを1つにまとめる。

1379
02:41:47,520 --> 02:41:52,400
個人情報スキーマと一般情報スキーマの両方を含む、1つの大きなスキーマができあがりました。

1380
02:41:52,400 --> 02:41:57,760
追加フォームを作成する際にも、このスキーマを使用します。

1381
02:41:57,760 --> 02:42:08,240
を生成し、これをzドットに割り当てる。

1382
02:42:08,240 --> 02:42:15,840
履歴書スキーマの型に追加したいことがある。

1383
02:42:15,840 --> 02:42:22,640
このようにすることで、この型を拡張することができます。

1384
02:42:22,640 --> 02:42:28,400
既存のレジュメを更新するときにもこの型を拡張することができる。

1385
02:42:28,400 --> 02:42:33,680
しかし、履歴書を更新するときには、このようなアイデアがあります。

1386
02:42:33,680 --> 02:42:39,440
履歴書のidは他のフィールドと一緒に保存されます。

1387
02:42:39,440 --> 02:42:45,520
この型は文字列型であり、オプションである。

1388
02:42:45,520 --> 02:42:51,920
もうひとつ問題がある。

1389
02:42:51,920 --> 02:42:58,960
未定義ですが、バックエンドに写真をアップロードすると、写真はurlに変わります。

1390
02:42:58,960 --> 02:43:05,440
urlに変わってしまいます。

1391
02:43:05,440 --> 02:43:11,920
文字列なので、typescriptに写真はファイルか文字列か未定義であることを伝えなければならない。

1392
02:43:12,800 --> 02:43:20,960
そこで、optional photoにファイルか文字列か未定義の値を追加する。

1393
02:43:20,960 --> 02:43:26,160
はすでにここにある写真と衝突してしまう。

1394
02:43:26,160 --> 02:43:32,160
そこで、この値をこのタイプから削除して、このタイプで使用するのは

1395
02:43:32,160 --> 02:43:38,240
そのためにtypescriptにはomitというヘルパー型がある。

1396
02:43:38,240 --> 02:43:47,360
次のように、c.inferの前にomitと書き、このソート型全体をomitで囲む。

1397
02:43:47,360 --> 02:43:53,440
このように角括弧で囲み、この閉じ角括弧の間にカンマを書く。

1398
02:43:53,440 --> 02:43:59,840
そして、省略したい値を定義します。ここでは写真を省略したいので、写真

1399
02:43:59,840 --> 02:44:06,480
の値は元の型から削除され、ここで定義した型に置き換えられる。

1400
02:44:07,280 --> 02:44:12,160
これらは、タイプスクリプトのテクニックとして覚えておくべきものだ。

1401
02:44:12,160 --> 02:44:18,080
というのも、後で写真を削除するときにnullを送信してしまうからです。

1402
02:44:18,080 --> 02:44:23,520
undefinedはすでにバックエンドに含まれている。

1403
02:44:23,520 --> 02:44:29,920
この型は正しいので、レジュームエディタに戻ってこの型を設定します。

1404
02:44:29,920 --> 02:44:36,480
を空のオブジェクトで初期化することができます。

1405
02:44:36,480 --> 02:44:42,960
この状態で何をするかというと、この値をフォーム・コンポーネントに渡したいのです。

1406
02:44:42,960 --> 02:44:50,320
というのも、このデータをフォームに表示する必要があるからです。

1407
02:44:50,320 --> 02:44:55,200
フォーム・コンポーネントにpropsとして渡す必要があります。

1408
02:44:55,200 --> 02:45:01,520
つまり、それぞれのフォームにはpropsが必要ですが、どれもまったく同じpropsが必要です。

1409
02:45:01,520 --> 02:45:06,240
何度も同じことを繰り返すのではなく、別のファイルにまとめましょう。

1410
02:45:06,240 --> 02:45:11,200
そのために、libフォルダにtypes.tsという新しいファイルを作成します。

1411
02:45:11,200 --> 02:45:22,800
という新しいファイルを作成し、ここにeditor form
propsというインターフェイスをエクスポートします。

1412
02:45:22,800 --> 02:45:31,200
とコールバックセットレジュームデータを受け取ります。

1413
02:45:31,200 --> 02:45:37,440
新しいデータを取得します。

1414
02:45:37,440 --> 02:45:46,000
これを保存し、steps.tsファイルに移動します。

1415
02:45:46,000 --> 02:45:53,680
このコンポーネントはエディタフォームの小道具を受け取るリアクトコンポーネントでなければなりません。

1416
02:45:53,680 --> 02:45:58,000
コンポーネントを配列に入れることができます。

1417
02:45:59,440 --> 02:46:05,200
これで、履歴書エディタはエラーを表示するはずです。

1418
02:46:05,200 --> 02:46:12,560
履歴書データとz履歴書データをここに渡そう。

1419
02:46:12,560 --> 02:46:19,200
とzの値をフォーム・コンポーネントに渡すことができます。

1420
02:46:19,200 --> 02:46:27,840
しかし、もちろんこれらのコンポーネントを修正する必要もあります。

1421
02:46:27,840 --> 02:46:37,200
エディターフォームの小道具は、ここで履歴書データとz履歴書データを見つけます。

1422
02:46:37,200 --> 02:46:42,880
フォームに渡すレジュメデータは、基本的に既存のレジュメを読み込む際のデフォルト値です。

1423
02:46:42,880 --> 02:46:48,240
フォームに渡す履歴書データは、基本的に既存の履歴書を読み込んだときのデフォルト値です。

1424
02:46:48,240 --> 02:46:55,600
このデフォルト値を各フォームフィールドに割り当てます。

1425
02:46:55,600 --> 02:46:58,880
で、これが未定義の場合のみ、空の文字列にフォールバックします。

1426
02:46:58,880 --> 02:47:04,240
そして、同じことをresume data dot last nameの下でも行います。

1427
02:47:04,240 --> 02:47:13,120
履歴書データ・ドット名 多分、何度も入力しなくてもいいように、これをコピーしておこう。

1428
02:47:13,120 --> 02:47:17,040
都市名

1429
02:47:17,040 --> 02:47:21,120
国

1430
02:47:21,120 --> 02:47:25,140
電話番号

1431
02:47:25,620 --> 02:47:28,500
Eメール

1432
02:47:28,500 --> 02:47:37,860
正しい値を代入してください。

1433
02:47:37,860 --> 02:47:44,900
既存の履歴書を読み込むときに、これらの値をフォームのフィールドに入れます。

1434
02:47:44,900 --> 02:47:51,060
履歴書データの呼び出しは、すでに設定したuse effectで行います。

1435
02:47:51,060 --> 02:47:57,780
この非同期関数で実際に

1436
02:47:57,780 --> 02:48:04,420
このasync関数の中で、このフォームの入力である現在の値を受け取り、そしてこのコメント

1437
02:48:04,420 --> 02:48:13,140
zレジュメデータ括弧中括弧と呼びますが、ここですでにあるレジュメデータを広げます。

1438
02:48:13,140 --> 02:48:19,140
というのも、他のフォームの入力を保持したいからである。

1439
02:48:19,140 --> 02:48:28,660
そして、これらの新しい値を依存関係として、use effect resume data と

1440
02:48:28,660 --> 02:48:36,740
z resume dataに依存関係としてこれらの新しい値を追加しなければならない。

1441
02:48:36,740 --> 02:48:44,980
同じものが必要なので、コピーして一般情報フォームに移動する。

1442
02:48:46,580 --> 02:48:52,980
エディターフォームプロップスには、履歴書データとz履歴書データがあります。

1443
02:48:52,980 --> 02:48:59,940
ここでもデフォルト値を割り当てます。

1444
02:48:59,940 --> 02:49:10,580
履歴書データのドットタイトル、履歴書データのドット説明、そしてこの使用効果のインポート使用効果を貼り付けます。

1445
02:49:12,100 --> 02:49:16,660
を貼り付けます。

1446
02:49:16,660 --> 02:49:23,620
にレンダリングされないので、まだ見ることができません。

1447
02:49:23,620 --> 02:49:31,380
右側に何もレンダリングされていないので、まだ見ることができません。

1448
02:49:31,380 --> 02:49:38,500
フォームのデータを文字列化してみましょう。

1449
02:49:38,500 --> 02:49:47,060
レンダーjsonドット文字列化履歴書データ

1450
02:49:47,060 --> 02:49:54,180
そして、書式を維持するためにnullとtourを渡すと、このjsonは適切に書式化されます。

1451
02:49:54,180 --> 02:49:58,820
そしてこれを保存したら、ページを更新しよう。

1452
02:49:58,820 --> 02:50:07,140
何か入力するとすぐにこのデータが表示されます。

1453
02:50:07,140 --> 02:50:14,260
フォームに入力したデータがすべて入っています。

1454
02:50:14,260 --> 02:50:21,300
入力し始めるとすぐに使用状態になり、後で実際のレジュームプレビューをレンダリングすることができます。

1455
02:50:21,300 --> 02:50:28,260
しかし、その前に残りのフォームを追加したい。

1456
02:50:28,260 --> 02:50:34,020
必要なのは職務経験フォームですが、これはちょっと厄介です。

1457
02:50:34,020 --> 02:50:40,820
というのも、職歴はいくつでも追加できるし、並べ替えもできるからだ。

1458
02:50:40,820 --> 02:50:48,500
リアクトフックフォームでこれを処理する方法を見つけなければなりません。

1459
02:50:48,500 --> 02:50:54,820
このため、データベースに新しいモデルを作成する必要があります。

1460
02:50:54,820 --> 02:51:00,500
一対多の関係がある場合、それぞれの職歴は別々のテーブルに保存されます。

1461
02:51:00,500 --> 02:51:07,860
一つの履歴書に複数の職歴があるような場合、通常、これらの多くの項目を別のテーブルに保存したいものです。

1462
02:51:07,860 --> 02:51:13,620
オブジェクトの配列にすることもできますが、そうすると作業が難しくなります。

1463
02:51:13,620 --> 02:51:20,020
オブジェクトの配列にすることもできますが、そうすると作業が難しくなります。

1464
02:51:20,020 --> 02:51:27,380
各エントリには一意なIDが必要なので、履歴書モデルからこの行をコピーします。

1465
02:51:29,540 --> 02:51:35,300
そして、ここに格納したいさまざまな値です。 ポジションはオプションの文字列です。

1466
02:51:35,300 --> 02:51:37,380
会社名

1467
02:51:37,380 --> 02:51:46,740
開始日（日付型、時間型、終了日は任意

1468
02:51:46,740 --> 02:51:56,500
そして同じくオプションの文字列であるdescriptionが必要です。

1469
02:51:56,500 --> 02:52:03,860
この職歴が属する履歴書も文字列で、リレーションを作成することができます。

1470
02:52:03,860 --> 02:52:10,180
を作成し、このリレーションで履歴書を取得する際にすべての職務経験を取得することができます。

1471
02:52:10,180 --> 02:52:16,340
このため、履歴書という別のフィールドを追加する。

1472
02:52:16,340 --> 02:52:25,540
というフィールドを追加する。

1473
02:52:27,300 --> 02:52:38,820
フィールドのコロン履歴書idをカンマ参照の配列にして、ここにidを入れる。

1474
02:52:38,820 --> 02:52:44,420
は職務経歴書モデルと履歴書モデルを結びつけます。

1475
02:52:44,420 --> 02:52:53,140
を履歴書テーブルのアイデアに属するとプリズマに伝えるからです。

1476
02:52:53,940 --> 02:52:59,460
というのは、このような関係を追加すると、エラーが発生するからです。

1477
02:52:59,460 --> 02:53:07,540
というのも、このようなリレーションを追加する場合、履歴書モデルには反対側も追加しなければならないからです。

1478
02:53:07,540 --> 02:53:17,700
というフィールドを追加します。このフィールドは職歴モデルの配列です。

1479
02:53:17,700 --> 02:53:23,540
こうすることで、後でこれらの職務経験モデルに直接アクセスすることができます。

1480
02:53:23,540 --> 02:53:30,820
また、タイムスタンプの追加と更新を行いたい。

1481
02:53:30,820 --> 02:53:39,700
で、このテーブルの名前をwork_experiencesに変更したい。

1482
02:53:39,700 --> 02:53:46,580
この新しいテーブルをデータベースにプッシュしなければならない。

1483
02:53:46,580 --> 02:53:55,780
新しいprismaクライアントが生成される。

1484
02:53:55,780 --> 02:54:04,500
を再度プッシュし、npm run devを再度実行します。

1485
02:54:04,500 --> 02:54:11,540
職務経験フォーム用の新しいバリデーションスキーマが必要です。

1486
02:54:11,540 --> 02:54:18,980
個人情報の値の下に、レジュメ・スキーマ・エクスポートの定数の上に、次のように記述したい。

1487
02:54:18,980 --> 02:54:31,540
職歴スキーマはzオブジェクトですが、職歴はいくつでも追加できます。

1488
02:54:31,540 --> 02:54:38,980
つまり、ここに配列を入れなければならない。

1489
02:54:38,980 --> 02:54:47,780
というフィールドを追加し、これをzドット配列の括弧に代入します。

1490
02:54:47,780 --> 02:54:55,460
を定義します。他のスキーマと同じように、期待する値を定義します。

1491
02:54:55,460 --> 02:55:01,300
これは配列なので、複数のフォームフィールドが必要なだけこれらのオブジェクトを追加することができます。

1492
02:55:01,300 --> 02:55:08,260
を追加することができることです。

1493
02:55:08,260 --> 02:55:13,060
基本的には、このモデルにあるのと同じ値をここに入れたいと思います。

1494
02:55:13,060 --> 02:55:18,500
データベースに保存したいので、ポジション会社

1495
02:55:18,500 --> 02:55:28,740
開始日 これもオプションの文字列です。

1496
02:55:28,740 --> 02:55:33,460
この文字列は後でサーバー上で日付オブジェクトに変換されます。

1497
02:55:33,460 --> 02:55:41,460
しかし、私たちのフォームでは、終了日も文字列です。

1498
02:55:41,460 --> 02:55:48,180
そしてこの配列関数の後に、ドットオプションの

1499
02:55:48,180 --> 02:55:53,460
を追加しています。なぜなら、この配列は後で未定義にすることができるからです。

1500
02:55:53,460 --> 02:56:02,980
そしてまた、スキーマから型を生成したい。

1501
02:56:02,980 --> 02:56:14,020
値 z dot infer type of work experience
スキーマから型を生成します。

1502
02:56:14,020 --> 02:56:20,420
大きな履歴書スキーマに追加したい。

1503
02:56:20,420 --> 02:56:28,100
職務経験スキーマのドットシェイプは、履歴書の値型に自動的に追加されます。

1504
02:56:28,100 --> 02:56:36,100
次に新しいフォームコンポーネントが必要なので、formsフォルダに入れます。

1505
02:56:36,100 --> 02:56:42,580
職務経歴書フォームドットtsx

1506
02:56:42,580 --> 02:56:47,700
デフォルト関数をエクスポートします。

1507
02:56:50,820 --> 02:56:56,900
このフォームには他のフォームと同様にエディターフォームプロップスが必要です。

1508
02:56:56,900 --> 02:57:01,700
ここで履歴書データとゼータコールバックを取得します。

1509
02:57:01,700 --> 02:57:09,940
そして、いつものようにuse formフックを使ってconstフォームを作成します。

1510
02:57:09,940 --> 02:57:14,660
型は職務経験値です

1511
02:57:17,540 --> 02:57:24,980
リゾルバをzリゾルバに設定し、職歴スキーマを渡します。

1512
02:57:24,980 --> 02:57:34,740
デフォルトの値はこの職務経験配列のみです。

1513
02:57:34,740 --> 02:57:41,620
data dot work experiences とするか、未定義の場合は空の配列とします。

1514
02:57:41,620 --> 02:57:48,820
既存の履歴書を読み込む際に、これらの職務経験をフィールドに入力するためです。

1515
02:57:48,820 --> 02:57:55,380
履歴書エディタコンポーネントのデータを更新するために、他のフォームと同じ効果を使用します。

1516
02:57:55,380 --> 02:58:03,700
使用効果をコピーしてここに貼り付けますが、型が

1517
02:58:03,700 --> 02:58:10,260
職歴は未定義にできますが、これは未定義を受け付けません。

1518
02:58:10,260 --> 02:58:18,180
そこで、ここではドットドット値を削除し、代わりに職務経験を明示的に渡します。

1519
02:58:18,180 --> 02:58:26,580
を明示的に渡すことにする。

1520
02:58:26,580 --> 02:58:33,380
ストリップが文句を言わないように、未定義の値をフィルタリングしたい。

1521
02:58:33,380 --> 02:58:42,500
がundefinedと等しくないことをチェックし、value dot work
experiencesが再びundefinedである場合は

1522
02:58:42,500 --> 02:58:49,700
空文字列を追加しても文句を言われなくなった。

1523
02:58:49,700 --> 02:58:56,660
そのためにreactフックフォームでフィールド配列フックを使います。

1524
02:58:56,660 --> 02:59:04,260
フックを使うことで、動的にフィールドを追加したり削除したりすることができます。

1525
02:59:04,260 --> 02:59:10,100
このフックの使い方を説明します。

1526
02:59:10,100 --> 02:59:17,780
reactフックフォームからuse field arrayを呼び出します。

1527
02:59:18,740 --> 02:59:23,780
括弧 中括弧 これにフォームコントロール

1528
02:59:23,780 --> 02:59:34,420
と、オートコンプリートの作業経験を取得する配列の名前を渡します。

1529
02:59:34,420 --> 02:59:41,060
フィールドを見つけることができます。

1530
02:59:41,060 --> 02:59:50,900
この配列とフォームに新しいフィールドを追加することができます。

1531
02:59:50,900 --> 03:00:02,900
mx auto、スペースy6で、他のフォームと同じようにdiffを返します。

1532
03:00:02,900 --> 03:00:14,500
センターで、h2の見出しテキストをexcelのフォントzimmiboltにレンダリングします。

1533
03:00:14,500 --> 03:00:26,260
という段落のテキストをsmテキストミュートフォアグラウンドにレンダリングしています。

1534
03:00:27,860 --> 03:00:36,580
を好きなだけ追加する。

1535
03:00:36,580 --> 03:00:46,580
フォームの値をスペースy3で小文字のfにする。

1536
03:00:46,580 --> 03:00:54,500
以前にも何度かやったことがあるが、今回の違いは、1つのフォームフィールドをハードコードしていないことだ。

1537
03:00:54,500 --> 03:01:01,380
このフィールドの値はuseフィールド配列から取得します。

1538
03:01:01,380 --> 03:01:06,740
そこで、これらのフィールドをそれぞれ1つのフォーム・フィールドにマッピングする。

1539
03:01:06,740 --> 03:01:15,300
各フィールドを通過してコンポーネントを返す。

1540
03:01:15,300 --> 03:01:25,140
このコンポーネントを、組織機能の職務経験項目用の別の関数に入れ、今は単に

1541
03:01:25,140 --> 03:01:32,980
というdiffを返すだけにしておこう。

1542
03:01:32,980 --> 03:01:40,260
これは配列なので、一意のキーを追加する必要がある。

1543
03:01:40,260 --> 03:01:47,380
これはreactのフックフォームによって生成されます。

1544
03:01:47,380 --> 03:01:53,700
これを保存して、この新しいフォームをパンくずリストに追加するためにステップファイルに入れてみましょう。

1545
03:01:53,700 --> 03:02:04,020
ここに別のオブジェクトを追加します。

1546
03:02:04,020 --> 03:02:15,380
キーは 「work minus experience 」です。

1547
03:02:15,380 --> 03:02:22,420
開発サーバーを再起動したので、ページをリフレッシュする必要がありますが、これで3つ目のステップwork
experienceができました。

1548
03:02:22,420 --> 03:02:28,660
しかし、ここにはまだ要素がありません。

1549
03:02:29,460 --> 03:02:36,500
このため、就業体験フォームに戻り、このマップ呼び出しの下にまだフォームの中にある

1550
03:02:36,500 --> 03:02:48,100
の大文字のbボタンを配置します。

1551
03:02:48,100 --> 03:02:54,340
componentsフォルダから大文字のbボタンを配置します。

1552
03:02:54,340 --> 03:02:59,540
ボタンがフォームを送信してしまうからです。

1553
03:02:59,540 --> 03:03:06,180
を追加することができます。

1554
03:03:06,180 --> 03:03:12,660
新しいフィールドをフィールド配列に追加する。

1555
03:03:12,660 --> 03:03:17,780
を追加し、これらすべての異なる職歴にデフォルト値を設定しなければなりません。

1556
03:03:17,780 --> 03:03:23,380
フィールドにデフォルト値を設定しなければなりません。

1557
03:03:23,380 --> 03:03:34,340
会社空文字列 開始日空文字列 終了日空文字列 説明

1558
03:03:34,340 --> 03:03:46,420
このボタンタグを閉じると、職歴の追加と表示されます。

1559
03:03:46,420 --> 03:03:52,660
このボタンをクリックすると、職歴の項目が追加されます。

1560
03:03:52,660 --> 03:03:58,900
フォーム・フィールドを配置する必要があります。

1561
03:03:58,900 --> 03:04:08,820
そのため、インターフェイスを作成します。

1562
03:04:08,820 --> 03:04:15,940
フォームフィールドに接続するために必要なので、use formフックにあるフォーム値が必要です。

1563
03:04:15,940 --> 03:04:24,740
を渡す必要があります。そして、use form returnという戻り値があります。

1564
03:04:24,740 --> 03:04:29,940
型職務経験値の戻り値

1565
03:04:29,940 --> 03:04:38,340
それから、現在の要素のインデックスも必要です。

1566
03:04:39,780 --> 03:04:45,860
各項目にはremoveボタンがあり、それをクリックするとコールバックが発生します。

1567
03:04:45,860 --> 03:04:51,700
要素のインデックスを送り返すことで、配列からその要素を削除することができます。

1568
03:04:51,700 --> 03:05:00,180
そして、これらの小道具を再構築します。

1569
03:05:02,820 --> 03:05:11,700
キーの後にインデックスを渡します。

1570
03:05:11,700 --> 03:05:18,420
これをこのコンポーネントに転送します。

1571
03:05:18,420 --> 03:05:30,660
removeとremoveはこの使用フィールド配列フックの別の関数です。

1572
03:05:31,380 --> 03:05:37,540
コンマで区切って、remove関数を各アイテムに渡します。

1573
03:05:37,540 --> 03:05:45,620
そして、この職務経験項目にフォームフィールドをレンダリングします。

1574
03:05:45,620 --> 03:05:56,100
このテキストを削除し、このdivをスペースy3でスタイルし、各アイテムにボーダーをつけ、ボーダーを丸くします。

1575
03:05:56,100 --> 03:06:02,100
デフォルトでは背景が透明なので、背景色も設定します。

1576
03:06:02,100 --> 03:06:08,580
パディングを3つ追加します。

1577
03:06:08,580 --> 03:06:19,300
ここに別のdivをフレックス・ジャスティファイで挟み、ギャップを2にします。

1578
03:06:21,700 --> 03:06:29,540
そして、この内側のdivにspanをレンダリングし、フォントをセミボールドにします。

1579
03:06:29,540 --> 03:06:36,980
インデックスがゼロから始まるので、インデックスに1を足したものをレンダリングします。

1580
03:06:36,980 --> 03:06:44,180
インデックスはゼロから始まるが、最初の要素には1としたい。

1581
03:06:44,180 --> 03:06:51,380
スクリプトの水平レシート・アイコンをレンダリングします。

1582
03:06:52,660 --> 03:06:59,700
カーソルの大きさを5にしてスタイルを設定し、カーソルを乗せるとこのようになる。

1583
03:06:59,700 --> 03:07:06,820
このカーソルはこのクラスのためのものです。

1584
03:07:06,820 --> 03:07:12,100
ミュートされた前景色にして目立たなくしたい。

1585
03:07:12,100 --> 03:07:18,740
ドラッグ・アンド・ドロップはまだ実装していないので、これはまだ機能しませんが、すでにいい感じです。

1586
03:07:18,740 --> 03:07:26,260
フォームフィールドを配置します。

1587
03:07:26,260 --> 03:07:34,020
名前を割り当て、中カッコとバックスティック文字列を追加します。

1588
03:07:34,020 --> 03:07:39,700
というのも、これらのフィールド配列では、次のように名前を渡しているからだ。

1589
03:07:39,700 --> 03:07:47,300
次にドットを追加し、次にインデックスを追加する。

1590
03:07:48,340 --> 03:07:53,300
そしてその中にあるフィールドにアクセスします。

1591
03:07:53,300 --> 03:08:00,980
各仕事経験アイテムの位置入力フィールドです。

1592
03:08:00,980 --> 03:08:09,380
レンダー関数でフィールドを再構築し、いつものようにフォーム項目をレンダリングします。

1593
03:08:11,620 --> 03:08:19,060
フォーム項目には役職名を保存するフォームラベルを入れます。

1594
03:08:19,060 --> 03:08:28,740
フォームのコントロールに大文字のiを入力します。

1595
03:08:28,740 --> 03:08:33,620
フィールドの値を広げ、オートフォーカスに設定します。

1596
03:08:36,020 --> 03:08:43,540
フォームコントロールの下にフォームメッセージと入力フィールドがあります。

1597
03:08:43,540 --> 03:08:50,260
この配列要素に入力フィールドがあります。

1598
03:08:50,260 --> 03:09:02,020
このフォームフィールド全体を複製しましょう。

1599
03:09:02,980 --> 03:09:09,940
そして、オートフォーカスを外して、2つの入力フィールドを1行にまとめましょう。

1600
03:09:09,940 --> 03:09:15,860
下にdivを置き、グリッドを2つ、ギャップを3つにします。

1601
03:09:15,860 --> 03:09:23,780
そして、ここにもう2つのフォームフィールドを入れます。

1602
03:09:25,460 --> 03:09:35,460
ラベルには開始日と書いてある。

1603
03:09:35,460 --> 03:09:44,260
今回は日付型なので、日付入力になりますが、値を明示的に設定する必要があります。

1604
03:09:44,260 --> 03:09:55,060
このフィールドのドット・バリュー・ドット・スライスのように、スライスに0,10を渡すと、時刻が削除されます。

1605
03:09:55,060 --> 03:10:00,340
データベースに保存する日付には時刻も含まれているからだ。

1606
03:10:00,340 --> 03:10:07,060
しかし、この入力フィールドには、時刻を含まない日付しか渡すことができない。

1607
03:10:07,060 --> 03:10:13,300
このスライス関数は、日付の最初の10文字だけを保持する。

1608
03:10:13,300 --> 03:10:21,620
4 5 6 7 8 9 10 10文字が日付になります。

1609
03:10:24,660 --> 03:10:34,180
これを終了日付に変更し、ラベルも変更する。

1610
03:10:34,180 --> 03:10:45,140
フォームの説明をもうひとつ追加したい。

1611
03:10:45,140 --> 03:10:53,060
終了日が空だと現在進行中であることを意味するからだ。

1612
03:10:54,660 --> 03:11:01,540
そこで、これをspanで囲み、このwrap with abbreviation bs
codeコマンドを使います。

1613
03:11:01,540 --> 03:11:06,100
を使えば、これを別のタグに折り返すことができますが、もちろん手動で書くこともできます。

1614
03:11:06,100 --> 03:11:15,060
スパンにフォントを半太字にすると、このようになり、フォームの説明は

1615
03:11:15,060 --> 03:11:21,940
の下にもう一つフォームフィールドが必要です。

1616
03:11:21,940 --> 03:11:32,980
フォームの説明文の下にコピーして、ドット・インデックス・ドット

1617
03:11:32,980 --> 03:11:45,460
を入力すると、ラベルに「説明」と表示されます。

1618
03:11:46,340 --> 03:11:53,780
入力フィールドをテキストエリアに変更します。

1619
03:11:53,780 --> 03:12:00,420
テキストエリアは入力フィールドが大きくなる。

1620
03:12:00,420 --> 03:12:06,420
というのも、説明文は通常何行にもわたるからだ。

1621
03:12:06,420 --> 03:12:12,740
ボタンをクリックして、この最後のフォーム・フィールドの下に置いた配列から、この職歴を削除する。

1622
03:12:13,540 --> 03:12:21,540
大文字のbボタンが破壊され、赤くなったので、タイプをボタンに設定し直した。

1623
03:12:21,540 --> 03:12:24,020
クリックすると

1624
03:12:24,020 --> 03:12:31,380
このremove関数を呼び出し、インデックスを渡す。

1625
03:12:31,380 --> 03:12:40,900
このようにすると、このボタンはremoveと表示される。

1626
03:12:42,420 --> 03:12:47,780
ここでremoveをクリックすれば、あとは3つの作業経験を残すだけだ。

1627
03:12:47,780 --> 03:12:57,060
正しいエントリーを削除したことを確認するために、1番をここに置いてみましょう。

1628
03:12:57,060 --> 03:13:05,300
2番と3番を削除して、1番と3番を残しましょう。

1629
03:13:05,300 --> 03:13:12,660
左から1番を削除し、3番を削除する。

1630
03:13:12,660 --> 03:13:19,220
もちろん、ここで作業しているのであれば、すべて保存しておこう。

1631
03:13:19,220 --> 03:13:25,300
この 「ai 」ボタンもそうですが、今は教育ステップを追加したいのです。

1632
03:13:25,300 --> 03:13:31,700
スキーマに入り、educationというモデルを作成します。

1633
03:13:33,220 --> 03:13:37,700
というモデルを作成します。

1634
03:13:37,700 --> 03:13:46,900
そして、ここに保存したいフィールドの数々。

1635
03:13:46,900 --> 03:13:51,060
そしてまた、開始日と終了日だ。

1636
03:13:51,060 --> 03:14:01,700
をコピーして、履歴書モデルに参照しよう。

1637
03:14:02,740 --> 03:14:11,220
このマップをeducationsと呼ぶことにする。

1638
03:14:11,220 --> 03:14:21,860
これは教育オブジェクトの配列です。

1639
03:14:21,860 --> 03:14:29,220
npx prisma db
pushでこれらの変更をデータベースにプッシュし、新しいprismaクライアントを生成します。

1640
03:14:30,100 --> 03:14:38,100
そしてdevを再度実行し、次にバリデーションtsファイルで新しいスキーマを設定します。

1641
03:14:38,100 --> 03:14:48,660
職歴スキーマの下に新しいスキーマを設定します。

1642
03:14:48,660 --> 03:14:59,460
educationsと呼ぶ配列が含まれている。

1643
03:15:00,420 --> 03:15:07,140
括弧で囲み、各教育のフィールドは学位となります。

1644
03:15:07,140 --> 03:15:11,700
任意の文字列 学校

1645
03:15:11,700 --> 03:15:18,020
任意文字列、開始日と終了日

1646
03:15:23,860 --> 03:15:30,180
そして、このeducations配列全体をオプションにします。

1647
03:15:30,180 --> 03:15:45,620
そして、いつものように型を生成する。

1648
03:15:45,620 --> 03:15:53,380
を生成し、それを履歴書スキーマに追加します。

1649
03:15:53,380 --> 03:16:03,540
履歴書の値に自動的に追加されます。

1650
03:16:03,540 --> 03:16:13,220
formsフォルダでeducational form dot tsxを右クリックします。

1651
03:16:13,220 --> 03:16:19,780
デフォルト関数educational formをエクスポート

1652
03:16:22,980 --> 03:16:27,380
これはいつものようにエディターフォームプロップスを受け取ります

1653
03:16:27,380 --> 03:16:36,740
そして、divを返します。とりあえずこれを保存して、stepsファイルに入れましょう。

1654
03:16:36,740 --> 03:16:51,380
ステップでは、educationというタイトルのオブジェクトを追加します。

1655
03:16:53,380 --> 03:16:57,620
キーは小文字のeducationです

1656
03:16:57,620 --> 03:17:07,620
教育フォームコンポーネントに戻って、この設定を終わらせましょう。

1657
03:17:07,620 --> 03:17:12,660
比較のために右側に実務経験フォームを置きましょう。

1658
03:17:12,660 --> 03:17:23,140
もう一度、education型の値を持つconst form equals use
formが必要です。

1659
03:17:23,140 --> 03:17:34,260
リゾルバにはZotリゾルバを使用し、教育スキーマを渡します。

1660
03:17:36,580 --> 03:17:46,020
そして、デフォルト値educationsをレジュメデータのeducationsか空の配列に設定します。

1661
03:17:46,020 --> 03:17:55,860
次に、同じuse effectとuse
field配列が必要なので、これをすべてコピーしてここに置きます。

1662
03:17:55,860 --> 03:18:05,780
もちろん、ここではeducationsにドットeducationsを設定します。

1663
03:18:05,780 --> 03:18:13,540
この変数の名前をeducationの略であるeduに変更しよう。

1664
03:18:13,540 --> 03:18:18,900
をインポートする必要がある。

1665
03:18:18,900 --> 03:18:27,940
次に、教育項目のコンポーネントが必要です。

1666
03:18:29,860 --> 03:18:36,020
と同じように、同じ小道具が必要です。

1667
03:18:36,020 --> 03:18:47,780
education item props import use form
returnと名前を変えて、education valuesとします。

1668
03:18:47,780 --> 03:18:59,620
そして、これらの小道具をここで再構築します education item props form
index remove

1669
03:19:00,100 --> 03:19:10,020
レイアウトはとても似ているので、この最初の行をコピーします。

1670
03:19:10,020 --> 03:19:18,500
を閉じ、グリップの水平線とタイトルのこの部分もここに貼り付けます。

1671
03:19:18,500 --> 03:19:28,180
しかし、これをeducationにリネームし、このアイコンをインポートします。

1672
03:19:28,180 --> 03:19:34,500
githubのリポジトリを見て、この部分のブランチをチェックしよう。

1673
03:19:34,500 --> 03:19:40,820
このフォームフィールドをここからコピーしてみよう。

1674
03:19:40,820 --> 03:19:44,020
これらのフォームコンポーネントをすべてインポートする

1675
03:19:52,420 --> 03:20:03,540
これはeducations dot degreeで、最初のフィールドです。

1676
03:20:03,540 --> 03:20:13,220
もちろん、オートフォーカスを維持したまま、このフォームフィールドを複製します。

1677
03:20:15,220 --> 03:20:22,660
エデュケーション・ドット・スクールでは、ラベルにスクールと表示し、オートフォーカスを外す。

1678
03:20:22,660 --> 03:20:32,820
そしてまたその下に、グリッドを使ったdiffを置き、tourを呼び出す。

1679
03:20:32,820 --> 03:20:40,740
そしてここにも開始日と終了日がある。

1680
03:20:40,740 --> 03:20:49,860
フォームフィールドをコピーしてここに貼り付けます。

1681
03:20:49,860 --> 03:20:58,660
あとは同じでいいはずだ。

1682
03:20:58,660 --> 03:21:06,500
削除ボタンが必要なので、これもコピーします。

1683
03:21:09,380 --> 03:21:15,860
そして、この空の差分があるところに、教育項目をマッピングする必要がある。

1684
03:21:15,860 --> 03:21:23,700
職歴フォームもよく似ています。

1685
03:21:23,700 --> 03:21:28,900
この差分全体をここに貼り付けます。

1686
03:21:31,700 --> 03:21:39,700
フォームコンポーネントをインポートして、教育項目にします。

1687
03:21:39,700 --> 03:21:44,500
educationと入力します。

1688
03:21:44,500 --> 03:21:57,220
そしてテキストには好きなだけeducationsを追加してくださいと表示されます。

1689
03:21:57,220 --> 03:22:03,220
returnステートメントを追加するのを忘れていたようだ。

1690
03:22:03,220 --> 03:22:13,460
新しい項目を追加するとき、異なるフィールドがありますよね。

1691
03:22:13,460 --> 03:22:19,620
学校、開始日と終了日

1692
03:22:22,500 --> 03:22:31,380
そして、これは学歴の追加と言うべきで、これでうまくいくはずです。

1693
03:22:31,380 --> 03:22:36,580
フォームコンポーネントを閉じて、ページを更新する必要があるかもしれません。

1694
03:22:36,580 --> 03:22:45,700
に切り替えて、ここにも学歴を追加することができます。

1695
03:22:45,700 --> 03:22:52,900
というのも、私は頭がいいほうではないからだ。

1696
03:22:52,900 --> 03:23:01,140
私自身は頭が良い方ではないので、これを教育値と呼ぶことにした。

1697
03:23:01,140 --> 03:23:07,300
フォームの次のステップはスキルです。

1698
03:23:07,300 --> 03:23:12,500
入力フィールドに文字列を入力するだけなので、もっとシンプルになる。

1699
03:23:13,380 --> 03:23:18,740
とはいえ、スキーマに追加しなければなりません。

1700
03:23:18,740 --> 03:23:27,780
履歴書モデルに新しいフィールドを追加するだけです。

1701
03:23:27,780 --> 03:23:34,260
という新しいカラムを追加するだけです。

1702
03:23:38,500 --> 03:23:43,380
次に、教育値の下にバリデーションスキーマを追加します。

1703
03:23:43,380 --> 03:23:53,460
エクスポート const skills schema equals c dot object

1704
03:23:53,460 --> 03:24:00,740
ここにスキルのキーを入れます。

1705
03:24:01,300 --> 03:24:10,580
文字列の配列でなければならない。

1706
03:24:10,580 --> 03:24:17,380
文字列をトリミングし、未定義になるようにオプショナルにします。

1707
03:24:17,380 --> 03:24:29,540
そして、このスキルの値の型をエクスポートします c dot infer type of skill
schema

1708
03:24:31,540 --> 03:24:35,540
そして忘れてはならないのが、この値をレジュメスキーマに追加することです。

1709
03:24:35,540 --> 03:24:39,780
スキルスキーマのドットシェイプを広げます。

1710
03:24:39,780 --> 03:24:48,900
しかし、オプションの位置がおかしいので、スキルのオプションのドットを

1711
03:24:48,900 --> 03:24:55,460
を切り取り、最後の閉じ括弧の後にこれを置きます。

1712
03:24:55,460 --> 03:25:03,620
コンポーネントが必要です。

1713
03:25:03,620 --> 03:25:18,820
エディター・フォームの小道具を、いつものようにレジュメ・データとセット・レジュメ・データ関数で受け取ります。

1714
03:25:19,860 --> 03:25:27,620
では、これをセットアップしてみましょう。const form equals use form
いつものようにスキル値をセットアップします。

1715
03:25:27,620 --> 03:25:34,260
リゾルバはスキルスキーマを渡すゾットリゾルバです。

1716
03:25:34,260 --> 03:25:43,940
デフォルト値を設定し、スキルにレジュームデータドットスキルまたは空の配列を設定します。

1717
03:25:43,940 --> 03:25:48,020
すでに何度かやったことなので、もう一度すべてを説明するつもりはない。

1718
03:25:48,020 --> 03:25:54,900
では、学歴フォームや職歴フォームの使用効果をコピーしてみましょう。

1719
03:25:54,900 --> 03:26:01,700
または職歴フォームからコピーしてここに貼り付けましょう。

1720
03:26:01,700 --> 03:26:13,700
しかし、学歴の代わりにスキルを渡し、これをドットスキルの値に代入します。

1721
03:26:15,860 --> 03:26:21,460
そして、未定義のものをフィルタリングしなければならない。

1722
03:26:21,460 --> 03:26:27,540
そこで、各スキルを取り出し、スキルが未定義と等しくないことをチェックする。

1723
03:26:27,540 --> 03:26:39,780
各スキルをこのようにマップし、skill dot trimでトリミングする。

1724
03:26:41,300 --> 03:26:47,540
これはまた空白を削除するもので、例えばスキルにカンマを1つ入力し、その後にスペースを1つ入力する。

1725
03:26:47,540 --> 03:26:52,740
スキル2 冒頭の空白を削除したい。

1726
03:26:52,740 --> 03:27:00,980
そして、そのすぐ後に別のフィルターコールを追加します。

1727
03:27:00,980 --> 03:27:09,300
スキルが空の文字列と等しくないことをチェックします。

1728
03:27:09,300 --> 03:27:16,260
コンマ・スペース・コンマと入力することもできますが、この2つのコンマの間に空のフィールドがある場合、これは実際のスキルではありません。

1729
03:27:16,260 --> 03:27:22,180
をフィルタリングする必要がある。

1730
03:27:22,180 --> 03:27:27,140
つまり、この演算子は未定義である可能性があり、もし未定義であれば、次のようになる。

1731
03:27:27,140 --> 03:27:33,940
もしこれが未定義なら、また空の配列に戻ってしまう。

1732
03:27:33,940 --> 03:27:43,780
は入力フィールドを1つだけ含むので、通常の最大幅xl

1733
03:27:43,780 --> 03:27:47,540
mx auto、スペース y 6

1734
03:27:47,540 --> 03:27:58,980
ここにdiffを置き、スペースyを1.5、テキストを中央に置き、見出しをh2とする。

1735
03:28:01,060 --> 03:28:12,420
2xl semi bold スキルと段落テキスト sm muted foreground

1736
03:28:12,420 --> 03:28:17,860
そしてこれには「得意なことは何ですか？

1737
03:28:17,860 --> 03:28:25,300
とりあえずこれを保存して、ステップファイルのsteps tsに入れよう。

1738
03:28:29,220 --> 03:28:40,660
タイトルは「skills component skills
form」、キーは小文字の「skills」です。

1739
03:28:40,660 --> 03:28:47,300
これを更新すると、新しいパンくずが表示されます。

1740
03:28:47,300 --> 03:28:52,340
スキルフォームコンポーネントに戻って、テキストエリアを1つ追加します。

1741
03:28:54,580 --> 03:29:02,260
この内側のdiffの下に大文字のfフォームを置き、フォームの値を広げます。

1742
03:29:02,260 --> 03:29:10,420
小文字のフォームをここに入れる。

1743
03:29:10,420 --> 03:29:17,620
フォーム・フィールドを追加するのに飽きてきたので、フォーム・コントロールとつなげます。

1744
03:29:19,140 --> 03:29:24,820
そしてフォームコンポーネントをレンダリングします。

1745
03:29:24,820 --> 03:29:31,460
いつものように

1746
03:29:31,460 --> 03:29:34,420
フォーム項目

1747
03:29:34,420 --> 03:29:40,500
フォームラベル.........これにはまたskillsと書きます

1748
03:29:40,500 --> 03:29:48,740
フォームコントロールと、ここにまたテキストエリアを追加します。

1749
03:29:49,460 --> 03:29:56,820
このテキストエリアに複数行にわたって入力できるように、フィールドの値を広げる必要があります。

1750
03:29:56,820 --> 03:30:04,020
プレースホルダーを設定することで、ユーザーがここに何を入力できるかを知ることができます。

1751
03:30:04,020 --> 03:30:16,260
例：react js comma node js comma graphic design
comma dot dot dot。

1752
03:30:16,260 --> 03:30:24,580
次に、変更時のコールバックを実装します。

1753
03:30:24,580 --> 03:30:29,780
この変更イベントを過ぎて、中かっこで矢印関数を追加します。

1754
03:30:29,780 --> 03:30:39,380
バリデーションスキーマのスキルは文字列の配列ですが、この入力フィールドは1つの文字列です。

1755
03:30:39,380 --> 03:30:44,900
入力フィールドは1つの大きな文字列です。

1756
03:30:44,900 --> 03:30:50,820
ここに何かを入力するたびに、コンマで単語を分割し

1757
03:30:50,820 --> 03:30:57,780
で単語を分割して文字列の配列にしたい。

1758
03:30:57,780 --> 03:31:08,980
コン・スキル・イコールeドット・ターゲット・ドット・バリューを作成する。

1759
03:31:08,980 --> 03:31:17,860
を作成し、変更時にフィールドドットを呼び出し、スキル配列を渡します。

1760
03:31:17,860 --> 03:31:25,780
フォームには文字列の配列が入力されます。

1761
03:31:25,780 --> 03:31:32,420
文字列の配列ですが、テキストエリアは実際に文字列の配列を受け入れます。

1762
03:31:32,420 --> 03:31:38,340
と思っていたのだが、配列を渡すことができるのだ。

1763
03:31:39,300 --> 03:31:47,620
スキル1 カンマ スキル2 見ての通り、これは配列になり、自動的に次のようになる。

1764
03:31:47,620 --> 03:31:54,740
カンマごとに自動的に分割されますが、空白とカンマを残すと、フィルタリングされて

1765
03:31:54,740 --> 03:32:00,980
空白とカンマを残すとフィルタリングされ、空の文字列はなくなります。

1766
03:32:00,980 --> 03:32:07,620
ここではすでにスキルが保存されているので、少し不要だが、スクリーン・リーダーにはまだいい。

1767
03:32:07,620 --> 03:32:14,900
しかし、スクリーン・リーダーにとっては、何を入力すればいいのかがわかるようにするのは良いことだ。

1768
03:32:14,900 --> 03:32:20,020
をフォームラベルに追加して非表示にします。

1769
03:32:20,020 --> 03:32:25,940
そして、この下にフォームの説明を書きます。

1770
03:32:25,940 --> 03:32:34,020
ユーザーが混乱しないように、各スキルをコンマで区切ってテキストを記述します。

1771
03:32:35,140 --> 03:32:42,340
そして、その下には、ユーザーが混乱しないように、各スキルをカンマで区切ってテキストでフォームの説明を書き、さらにその下には、エラーメッセージが適切に表示されるように、バリデーションを追加したい場合のフォームメッセージを書きます。

1772
03:32:42,340 --> 03:32:48,340
エラーメッセージが適切に表示されるようにします。

1773
03:32:48,340 --> 03:32:55,700
はサマリーフォームで、これも入力フィールドは1つだけです。

1774
03:32:55,700 --> 03:33:07,300
スキルの値の下にあるバリデーションファイルへ移動します。

1775
03:33:07,300 --> 03:33:16,980
zオブジェクトをエクスポートします。

1776
03:33:18,020 --> 03:33:26,500
イコールcドットでサマリースキーマのタイプを推測し、履歴書スキーマに追加します。

1777
03:33:26,500 --> 03:33:30,340
サマリースキーマのドットシェイプ

1778
03:33:30,340 --> 03:33:42,500
次に、フォームフォルダ内のサマリーフォームを右クリックします。

1779
03:33:43,380 --> 03:33:45,380
それで

1780
03:33:45,380 --> 03:33:52,420
エディターフォームプロップス

1781
03:33:52,420 --> 03:34:00,740
で、これがエディタ用に設定する最後のフォームになります。

1782
03:34:00,740 --> 03:34:08,420
const formはuse formに等しいので、ドリルサマリーの値はすでに知っている

1783
03:34:11,380 --> 03:34:18,180
リゾルバサマリースキーマをソートし、デフォルト値

1784
03:34:18,180 --> 03:34:25,540
をレジュームデータのドットサマリー、もしくはフォールバックとして空の文字列に設定します。

1785
03:34:25,540 --> 03:34:35,780
使用するエフェクトが必要なので、個人情報フォームからコピーして、ここに貼り付けましょう。

1786
03:34:37,620 --> 03:34:41,940
今回は特別な方法で処理しなければならない配列がないからだ。

1787
03:34:41,940 --> 03:34:45,780
次にレイアウトの差分を返す

1788
03:34:45,780 --> 03:34:53,620
最大幅 xl mx 自動スペース y6

1789
03:34:53,620 --> 03:35:03,780
diff with space y 1.5 text center

1790
03:35:05,620 --> 03:35:10,740
h2フォントの半太字テキストをエクセルへ

1791
03:35:10,740 --> 03:35:16,260
プロフェッショナル・サマリー

1792
03:35:16,260 --> 03:35:26,740
そして段落のテキストはsmのミュートフォアグラウンドで書く。

1793
03:35:29,140 --> 03:35:40,100
または、入力されたデータからaiが履歴書を生成します。

1794
03:35:40,100 --> 03:35:45,060
ここに要約を生成するaiボタンがあります。

1795
03:35:45,060 --> 03:35:49,860
は最後のステップで、この他のすべての入力を考慮して要約を生成します。

1796
03:35:49,860 --> 03:35:56,900
そのためにはまず他のすべての情報が必要です。

1797
03:35:58,900 --> 03:36:15,860
小文字のフォームと1つのフォームフィールド

1798
03:36:24,260 --> 03:36:27,540
以下の手順に従ってください

1799
03:36:27,540 --> 03:36:28,660
フォーム項目

1800
03:36:28,660 --> 03:36:35,540
フォーム・ラベル プロフェッショナル・サマリー

1801
03:36:35,540 --> 03:36:42,500
フォームコントロールと、これもテキストエリア

1802
03:36:42,500 --> 03:36:47,540
フィールドの値を

1803
03:36:49,300 --> 03:36:59,380
そして、プレースホルダーを追加し、あなた自身についての簡単な魅力的なテキストとフォームメッセージを下に追加します。

1804
03:36:59,380 --> 03:37:10,020
そして、それをステップファイルに入れる必要があります。

1805
03:37:10,020 --> 03:37:18,980
タイトル要約コンポーネント要約フォーム

1806
03:37:20,340 --> 03:37:28,020
そして、キーとなるサマリーを入力し、別のステップとしてここに入力します。

1807
03:37:28,020 --> 03:37:34,420
スキルのページでやったように、このラベルも非表示にできるかもしれない。

1808
03:37:34,420 --> 03:37:40,340
というのも、ここにはすでに見出しがあるからだ。

1809
03:37:40,340 --> 03:37:45,780
フォームのラベルにSR専用クラスを追加しましょう。

1810
03:37:46,820 --> 03:37:50,420
ページファイル

1811
03:37:50,420 --> 03:38:03,700
これですべてのフォームの準備ができたので、データを取得してページに保存します。

1812
03:38:03,700 --> 03:38:09,620
ファイルを作成し、このデータをjsonの代わりにレジュメとしてレンダリングします。

1813
03:38:10,580 --> 03:38:17,300
履歴書プレビューア.tsxと呼びます。

1814
03:38:17,300 --> 03:38:32,020
このコンポーネントはもちろん履歴書プレビューの小道具が必要です。

1815
03:38:32,020 --> 03:38:38,260
これはresume values型で、すべてのフォームフィールドのデータを含んでいます。

1816
03:38:39,060 --> 03:38:45,140
また、このオプションのクラス名を渡すことで、このコンポーネントのスタイルを変更することができます。

1817
03:38:45,140 --> 03:38:51,060
そしていつものように、これらの小道具を再構築します。

1818
03:38:51,060 --> 03:38:54,740
レジュメデータとクラス名

1819
03:38:54,740 --> 03:39:04,100
そして、divを返します。このdivにクラス名を追加しますが、中かっこで囲みます。

1820
03:39:05,060 --> 03:39:10,660
これはlibsフォルダからのインポートです。

1821
03:39:10,660 --> 03:39:18,660
この関数はutilsファイルの中にあり、先ほどshadcnがコマンドでshadcn
initを実行したときに追加されたものです。

1822
03:39:18,660 --> 03:39:24,580
この関数は次のように使います。

1823
03:39:24,580 --> 03:39:30,660
第一引数として通常のクラス名を、第二引数として文字列を渡します。

1824
03:39:30,660 --> 03:39:36,580
このコンポーネントに渡すオプションのクラス名を渡します。

1825
03:39:36,580 --> 03:39:42,340
クラスが既存のtailwindクラスを上書きすることを確認します。

1826
03:39:42,340 --> 03:39:48,580
background redがあるときにbackground greenを渡すと、背景色が変更されて

1827
03:39:48,580 --> 03:39:54,260
なぜなら、これらのクラスの順番は重要ではないからだ。

1828
03:39:54,260 --> 03:40:00,820
greenを2番目の値として渡しただけでは、background
redを上書きすることは保証されません。

1829
03:40:00,820 --> 03:40:06,820
このcn関数がこれを処理してくれるが、背景色を赤にしたくない。

1830
03:40:06,820 --> 03:40:11,460
なぜなら、これは紙を表しているからだ。

1831
03:40:11,460 --> 03:40:16,500
同様にテキストも常に黒でなければならない。

1832
03:40:18,420 --> 03:40:26,100
次に、高さをfit、幅をfullに設定し、アスペクト比をハードコードします。

1833
03:40:26,100 --> 03:40:32,500
アスペクト・マイナスと書き、角括弧で囲む。

1834
03:40:32,500 --> 03:40:44,020
210 スラッシュ 297 これはA4用紙の縦横比です。

1835
03:40:44,020 --> 03:40:51,220
もちろん、これらの値を3で割ることもできる。

1836
03:40:51,220 --> 03:40:59,860
もちろん、これらの値を3で割って70÷99と書くこともできるが、私はこのようにしている。

1837
03:40:59,860 --> 03:41:05,460
というのも、これはa4用紙の実際のミリメートルだからだ。

1838
03:41:06,180 --> 03:41:16,900
パディング6、テキスト3xl、フォント太字のh1見出しを置くと、次のようになる。

1839
03:41:16,900 --> 03:41:27,140
このテキストは、コンテナdiffのサイズに合わせて変更する必要があります。

1840
03:41:27,140 --> 03:41:33,460
をレンダリングすることになりますが、今はこのテキストをハードコードして、このテキストのサイズを変更する方法を考えたいと思います。

1841
03:41:33,460 --> 03:41:40,500
これは履歴書のプレビューです。

1842
03:41:40,500 --> 03:41:47,140
コンポーネントも作成したい。

1843
03:41:47,140 --> 03:41:52,820
エディタフォルダに新しいコンポーネントを作成しましょう。

1844
03:41:52,820 --> 03:41:59,860
ここで使用するので、新しいコンポーネントを作成しましょう。

1845
03:42:00,500 --> 03:42:07,780
[タイピング］

1846
03:42:07,780 --> 03:42:09,220
これも小道具が必要です。

1847
03:42:09,220 --> 03:42:18,020
レジュメプレビューでレンダリングするために、レジュメデータを渡す必要があります。

1848
03:42:18,020 --> 03:42:24,820
また、この中に2つのボタンがあります。

1849
03:42:24,820 --> 03:42:30,500
と原色を変更することができます。

1850
03:42:30,500 --> 03:42:38,660
つまり、レジュメデータを更新する必要があります。

1851
03:42:38,660 --> 03:42:48,100
値を受け取り、何も返さない場合、これらのプロップを再構築します。

1852
03:42:48,100 --> 03:43:01,300
セクションのprops resume dataとset resume dataでdiffを返します。

1853
03:43:01,300 --> 03:43:12,340
レジュームエディタを開いてみましょう。

1854
03:43:12,340 --> 03:43:20,900
現在レンダリングしているjsonから、このdiffのクラス名を切り取って、ここに貼り付けます。

1855
03:43:20,900 --> 03:43:27,300
そして、このプリタグのついた差分全体を削除し、代わりにレジュメのプレビューセクションをレンダリングします。

1856
03:43:27,300 --> 03:43:34,340
セクションをレンダリングします。このセクションには、フォームコンポーネントと同じプロパティを渡す必要があります。

1857
03:43:34,340 --> 03:43:42,260
このファイルを保存して、このファイルを閉じましょう。

1858
03:43:42,260 --> 03:43:52,820
diffの中に、flex width full justify center overflow y
auto

1859
03:43:52,820 --> 03:44:03,060
bg secondary、パディングは3、背景はグレーで、レジュメのプレビューを表示します。

1860
03:44:03,060 --> 03:44:10,660
プレビューを中央に配置し、レジュメがページの高さより長い場合はスクロールバーを表示します。

1861
03:44:10,660 --> 03:44:15,940
履歴書がページの高さより長い場合はスクロールバーが表示されます。

1862
03:44:15,940 --> 03:44:26,340
レジューム・データを必要とするこのファイルを、最大幅を2xlに設定してスタイルを設定します。

1863
03:44:26,340 --> 03:44:34,740
に設定し、シャドウmdを付けます。

1864
03:44:34,740 --> 03:44:42,180
プロパティを追加し、この白い差分のスタイルを上書きします。

1865
03:44:42,180 --> 03:44:48,660
コンテナはすでに適切に拡大縮小されています。

1866
03:44:48,660 --> 03:44:56,900
見ての通り、常にA4用紙の大きさになっています。

1867
03:44:56,900 --> 03:45:03,940
のサイズはそのままなので、これが小さくてもテキストは大きいままです。

1868
03:45:03,940 --> 03:45:10,020
このテキストをコンテナの寸法に合わせて拡大縮小することで、この用紙が常に

1869
03:45:10,020 --> 03:45:15,940
どのサイズでも同じように見えるようにしたい。

1870
03:45:15,940 --> 03:45:22,020
cssコードだけでは実現できない。javascriptを使う必要がある。

1871
03:45:22,020 --> 03:45:29,220
コンテナdiffのサイズを計算し、このdiff内のコンテンツにズームを適用します。

1872
03:45:29,220 --> 03:45:36,820
のサイズを計算するためにこうしましょう。

1873
03:45:36,820 --> 03:45:44,020
shedcnが最初に作成したhooksフォルダがあります。

1874
03:45:44,020 --> 03:45:53,620
もしなければ、新規ファイルを右クリックし、このフックをuse dimensions.tsと呼びます。

1875
03:45:56,900 --> 03:46:04,900
デフォルトの関数use dimensionsをエクスポートします。

1876
03:46:04,900 --> 03:46:11,540
スタック・オーバーフローの助けを借りて、このフックのコードを思いついた。

1877
03:46:11,540 --> 03:46:23,540
コンテナrefと呼ばれる1つの引数で、これはhtml要素型のreactドットrefオブジェクトです。

1878
03:46:24,100 --> 03:46:32,420
を角括弧で囲んで、このように入力する。

1879
03:46:32,420 --> 03:46:38,420
そしてその寸法を計算し、この寸法をstateに格納する。

1880
03:46:38,420 --> 03:46:46,820
この寸法をstateに格納します。つまり、const dimensionsとz
dimensions、dimensionsは単に幅と高さを意味します。

1881
03:46:48,020 --> 03:46:54,740
を持つオブジェクトを初期値として入れます。

1882
03:46:54,740 --> 03:46:58,580
幅ゼロ、高さゼロ

1883
03:46:58,580 --> 03:47:03,460
そしてここにuse effectを入れる。

1884
03:47:03,460 --> 03:47:14,420
これは実際の計算を行うもので、const current refが必要である。

1885
03:47:15,540 --> 03:47:23,300
container ref dot currentを代入し、get
dimensionsという関数を作成する。

1886
03:47:23,300 --> 03:47:32,260
ここで、新しい幅と高さを含むオブジェクトを返します。

1887
03:47:32,260 --> 03:47:40,580
というオブジェクトを返します。このオブジェクトは、current ref dot offset
widthから取得します。

1888
03:47:40,580 --> 03:47:51,220
高さは現在の参照ドットオフセットの高さかゼロです。

1889
03:47:51,220 --> 03:47:57,540
この関数の下に、const resize observerを作成する。

1890
03:47:57,540 --> 03:48:05,700
これを新しいリサイズ・オブザーバーに割り当てます。

1891
03:48:05,700 --> 03:48:11,380
デフォルトでは、このクラスはどのパッケージにも属していません。

1892
03:48:11,380 --> 03:48:18,980
そして、そのエントリーが観測する要素である。

1893
03:48:18,980 --> 03:48:24,420
そこで、entries配列から最初の要素を取り出す必要がある。

1894
03:48:24,420 --> 03:48:31,860
そして、これが未定義でないことをチェックしなければならない。

1895
03:48:31,860 --> 03:48:37,540
refの場合、ここには要素がないので、念のため次のifチェックを追加する。

1896
03:48:37,540 --> 03:48:44,340
エントリーが定義され、リサイズ・オブザーバーがトリガーされた場合。

1897
03:48:44,340 --> 03:48:50,100
コンテナの寸法が変更されたら、状態を更新したい。

1898
03:48:50,100 --> 03:48:57,700
これをset dimensionsで行い、これにget dimensions関数を渡す。

1899
03:48:59,060 --> 03:49:04,900
この関数を呼び出すと、コンテナrefから現在の寸法が読み込まれる。

1900
03:49:04,900 --> 03:49:12,820
が定義されているかどうかをチェックする。

1901
03:49:12,820 --> 03:49:20,740
refが定義されているかどうかをチェックします。

1902
03:49:21,700 --> 03:49:28,180
そして、現在のrefを渡します。

1903
03:49:28,180 --> 03:49:34,900
こうすることで、このリサイズ・オブザーバーをアタッチした時点で、すでに最新の寸法を取得している。

1904
03:49:34,900 --> 03:49:41,140
差分がリサイズされるまで待つ必要はない。

1905
03:49:41,140 --> 03:49:48,020
この行で処理されるのだが、使用効果は複数回実行される可能性がある。

1906
03:49:48,020 --> 03:49:53,620
リサイズ・オブザーバを増やしたくない。

1907
03:49:53,620 --> 03:50:00,580
先に説明したように、関数を返すことでユースエフェクトをクリーンアップすることができます。

1908
03:50:00,580 --> 03:50:07,780
ここでは、use effectからarrow関数を返します。

1909
03:50:07,780 --> 03:50:14,180
useエフェクトが再び実行される前に実行されるarrow関数を返します。

1910
03:50:14,180 --> 03:50:20,660
で詳しく説明しています。codingとflow.comのスラッシュreactベストプラクティスの下にあります。

1911
03:50:20,660 --> 03:50:29,140
現在の参照オブジェクトが定義された後、resize observer dot
unobserveを呼び出す。

1912
03:50:29,140 --> 03:50:36,260
このオブザーバーを無効にし、再びこのrefを渡す必要がある。

1913
03:50:36,260 --> 03:50:44,340
を呼び出す必要がある。

1914
03:50:44,340 --> 03:50:50,260
を渡さなければならない。これが、ここで文句を言われる理由である。

1915
03:50:50,260 --> 03:50:57,060
を見つけ、依存配列を第2引数として渡さなければならない。

1916
03:50:57,060 --> 03:51:03,860
そして最後に、フックから寸法を返したい。

1917
03:51:03,860 --> 03:51:10,100
コンポーネントでこのフックを使って寸法を取得できるようにするためだ。

1918
03:51:10,100 --> 03:51:18,980
それでは、レジュメプレビューコンポーネントに移動して、このフックを使ってみましょう。

1919
03:51:18,980 --> 03:51:25,060
まず最初に、このコンテナ参照が必要です。

1920
03:51:25,060 --> 03:51:31,140
これはhtml diff要素タイプで、これをnullで初期化します。

1921
03:51:32,900 --> 03:51:36,980
そして、計測したいdiffは、この背景色が白のものだ。

1922
03:51:36,980 --> 03:51:42,660
そこで、このrefをこのref propに追加します。

1923
03:51:42,660 --> 03:51:49,460
を呼び出し、use dimensionsフックを再構築します。

1924
03:51:49,460 --> 03:51:56,100
コンテナのrefを渡すと、ここで幅と高さがわかります。

1925
03:51:56,100 --> 03:52:04,580
このdiffの幅を常に取得します。

1926
03:52:04,580 --> 03:52:08,180
見出しをこの内側のdiffにラップします。

1927
03:52:08,180 --> 03:52:16,260
そして、このdiffにstyle propを追加し、このstyle
propに2つ目のペアを追加します。

1928
03:52:16,260 --> 03:52:23,460
中括弧は、javascriptオブジェクトを想定しているためです。

1929
03:52:23,460 --> 03:52:29,620
クールなのは、ここでtailwindクラスでは機能しない計算ができることです。

1930
03:52:29,620 --> 03:52:36,500
幅を使用して、この幅に応じてこの要素のスケーリングを変更できます。

1931
03:52:36,500 --> 03:52:42,420
scaleクラスを使うこともできますが、私の経験では、これは空白を残してしまうのであまりうまくいきません。

1932
03:52:42,420 --> 03:52:47,460
cssプロパティであるzoom値の方がうまくいきます。

1933
03:52:49,300 --> 03:52:59,540
そして、ズームレベルを括弧1÷剛体の幅の794倍に設定します。

1934
03:52:59,540 --> 03:53:08,740
この794はどこから来ているかというと、210ミリメートルのピクセル数である。

1935
03:53:08,740 --> 03:53:16,900
この用紙のデフォルト・サイズのデフォルト幅は210ミリメートルです。

1936
03:53:16,900 --> 03:53:24,900
というのは、これはA4用紙1枚を表しているはずだからだ。

1937
03:53:24,900 --> 03:53:31,700
ピクセルで割って横幅と掛け合わせれば、常にa4用紙のように見える。

1938
03:53:31,700 --> 03:53:38,260
しかし、この差分に追い風クラスを追加したい。

1939
03:53:38,260 --> 03:53:46,740
また、ここでもcn関数を使い、最初の文字列としてスペース

1940
03:53:46,740 --> 03:53:53,380
y6を渡すと、この履歴書の異なるセクションの間にスペースが追加されます。

1941
03:53:53,380 --> 03:54:01,940
カンマと、このcn関数はクラス名をコンポーネントに渡すのに便利なだけでなく、次のような式も追加できる。

1942
03:54:01,940 --> 03:54:07,380
からもどってくる幅と高さのデフォルト値を覚えておくと便利です。

1943
03:54:07,380 --> 03:54:14,820
use dimensions
フックはゼロであり、リサイズオブザーバーがリサイズするまでの短い間、これはゼロになる。

1944
03:54:14,820 --> 03:54:22,100
が実際の寸法を測定する前にゼロになってしまう。

1945
03:54:22,100 --> 03:54:27,940
でないと、一瞬間違ったサイズで表示されてしまうので、ここでは幅がゼロかどうかをチェックします。

1946
03:54:27,940 --> 03:54:35,140
感嘆符の幅がゼロかどうかをチェックします。

1947
03:54:35,140 --> 03:54:41,540
そして、この差分の寸法を測定し、zoomプロパティでコンテンツのサイズを変更します。

1948
03:54:41,540 --> 03:54:48,980
zoomプロパティを使って、コンテナのサイズに関連してコンテンツのサイズを変更します。

1949
03:54:48,980 --> 03:54:54,900
ご覧のように、テキストサイズは小さくなり、コンテナのサイズに合わせてリサイズされます。

1950
03:54:54,900 --> 03:55:03,380
これで、画面サイズに関係なく、すべてが均整のとれたサイズになりました。

1951
03:55:03,380 --> 03:55:09,860
この差分は履歴書のすべてのコンテンツを包み込みます。

1952
03:55:09,860 --> 03:55:16,260
見出しをプレースホルダーに置き換える必要があります。

1953
03:55:16,260 --> 03:55:24,020
履歴書データから、これを別のコンポーネントに整理します。

1954
03:55:24,020 --> 03:55:32,420
コンポーネントの下にレジュメセクションプロップスというインターフェイスを作成します。

1955
03:55:32,420 --> 03:55:40,180
履歴書セクションはすべて同じプロップを使用し、履歴書データを必要とします。

1956
03:55:40,180 --> 03:55:47,060
そして、その下に別のコンポーネント関数を作成します。

1957
03:55:47,060 --> 03:55:53,700
ファイルに書き出すこともできますが、私は同じファイルに書き出したいです。

1958
03:55:53,700 --> 03:55:59,220
履歴書プレビューでは、まず人事情報ヘッダーと呼ばれるものがあります。

1959
03:56:02,020 --> 03:56:10,180
そしてもちろん、履歴書データを見つけることができる履歴書セクションの小道具を取得します。

1960
03:56:10,180 --> 03:56:20,100
履歴書データを再構築してみましょう。

1961
03:56:20,100 --> 03:56:25,780
ここではもう少し読みやすいと思います。

1962
03:56:25,780 --> 03:56:30,420
このセクションの個人情報のヘッダーには写真が表示されます。

1963
03:56:32,100 --> 03:56:44,820
姓、名、役職、都市、国、電話、Eメールです。

1964
03:56:44,820 --> 03:56:54,260
写真はファイルでも文字列でも構わない。

1965
03:56:54,260 --> 03:57:01,540
ファイルストレージに保存していた場合は、ファイルではなく画像のURLを返すので、この両方のケースを処理する必要がある。

1966
03:57:01,540 --> 03:57:07,540
そのため、この両方のケースに対応する必要があります。

1967
03:57:07,540 --> 03:57:19,620
これをuse状態で初期化します。

1968
03:57:19,620 --> 03:57:27,140
デフォルト値は写真のURLで、文字列の場合はそのURL、ファイルの場合はそのファイル名となります。

1969
03:57:27,140 --> 03:57:32,500
デフォルト値をここに入れたくないのです。

1970
03:57:32,500 --> 03:57:40,180
そこで、photoがfileのインスタンスであるかどうかをチェックし、空の文字列を代入します。

1971
03:57:40,180 --> 03:57:47,300
そうでない場合は、photoに割り当てます。

1972
03:57:47,860 --> 03:57:56,820
に代入します。これは、photoがファイルでないか、未定義またはnullであるためです。

1973
03:57:56,820 --> 03:58:03,380
を文字列に変換します。

1974
03:58:03,380 --> 03:58:12,900
ファイルであり、まだurlでない場合は、ここでconstオブジェクトのurlを作成し、ここで再度、写真かどうかをチェックします。

1975
03:58:13,780 --> 03:58:22,340
がファイルのインスタンスである場合、url.createobjecturlを呼び出します。

1976
03:58:22,340 --> 03:58:28,100
に写真ファイルを渡します。そうでない場合は、空の文字列を代入します。

1977
03:58:28,100 --> 03:58:35,060
このcreateobjecturl関数を使用すると、ファイルを文字列に変換することができます。

1978
03:58:35,060 --> 03:58:39,060
つまり、このファイルのプレビューをレンダリングします。

1979
03:58:41,060 --> 03:58:48,020
オブジェクトurlが定義されているか、空でないかをチェックします。

1980
03:58:48,020 --> 03:58:54,660
もし空でなければ、写真のsrcをこのオブジェクトurlに設定します。

1981
03:58:54,660 --> 03:59:06,580
nullとは、写真が選択されていないことを意味します。

1982
03:59:06,580 --> 03:59:12,580
後で、フォームに写真を削除するボタンを設置します。

1983
03:59:12,580 --> 03:59:18,660
このような場合、写真をnullに設定します。

1984
03:59:18,660 --> 03:59:26,580
を空の文字列に戻してプレビューを削除します。

1985
03:59:26,580 --> 03:59:32,580
効果に入れたのは、このようなオブジェクトURLをどんどん作り続けると、それを一掃しなければならないからです。

1986
03:59:33,220 --> 03:59:38,820
例えば、このロジックをコンポーネントのレンダリングボディに直接記述します。

1987
03:59:38,820 --> 03:59:42,500
メモリリークを起こすので、それをクリーンアップする必要がある。

1988
03:59:42,500 --> 03:59:53,060
これを通常通り、useエフェクトのリターン関数で行います。

1989
03:59:53,060 --> 04:00:00,820
を呼び出し、同じオブジェクトurlを渡して、これをクリーンアップします。

1990
04:00:00,820 --> 04:00:06,500
エフェクトの依存配列に写真を渡す必要があります。

1991
04:00:06,500 --> 04:00:15,300
要約すると、もし写真がすでにURLであれば、それをこのphoto srcの状態に置くだけです。

1992
04:00:15,300 --> 04:00:22,100
写真がファイルの場合は、まずこの関数で写真をurlに変換する必要があります。

1993
04:00:22,100 --> 04:00:28,020
なぜなら、create object urlを何度も何度も実行するとメモリリークが発生するからです。

1994
04:00:28,020 --> 04:00:34,820
を何度も実行するとメモリリークが発生し、アプリの動作が遅くなるからです。

1995
04:00:34,820 --> 04:00:40,900
を生成し、それを画面にレンダリングします。

1996
04:00:40,900 --> 04:00:46,500
を返します。

1997
04:00:46,500 --> 04:00:56,580
ここでphoto srcが定義されているかどうかをチェックします。

1998
04:00:57,060 --> 04:01:05,140
そこで、まず写真のsrcを指定します。

1999
04:01:05,140 --> 04:01:08,980
幅と高さを100にハードコードします。

2000
04:01:08,980 --> 04:01:17,620
altテキストを例えばauthor photoに設定します。

2001
04:01:17,620 --> 04:01:25,060
そして、幅と高さが常に同じになるように、aspect squareでスタイルを設定します。

2002
04:01:26,100 --> 04:01:33,140
そして、もしこれが完全な長方形でない場合は、画像を中央で切り抜くオブジェクトカバーを設定します。

2003
04:01:33,140 --> 04:01:38,340
この画像のボーダー半径をカスタマイズできるようになりますが、今はこのままにしておきます。

2004
04:01:38,340 --> 04:01:48,100
そして、この写真のsrzブロックの下に、スペースyを2.5にした別のdivを置きます。

2005
04:01:48,100 --> 04:01:53,940
そしてここにスペースy1で別のdivを置きます。

2006
04:01:54,900 --> 04:02:03,540
そしてここに、テキスト3xl、フォント太字の段落タグをレンダリングします。

2007
04:02:03,540 --> 04:02:09,460
そしてここに、姓と名をスペースで区切ってレンダリングします。

2008
04:02:09,460 --> 04:02:17,380
続ける前に、このセクションを履歴書のプレビューに入れてみましょう。

2009
04:02:18,980 --> 04:02:27,540
h1の見出しを削除し、履歴書データを必要とする個人情報ヘッダーを設置しました。

2010
04:02:27,540 --> 04:02:37,380
名前を変更すると、プレビューでその名前が表示されます。

2011
04:02:37,380 --> 04:02:43,220
名前の段落タグの下に、別の段落をレンダリングします。

2012
04:02:45,380 --> 04:02:50,660
中フォントで職種を表示する

2013
04:02:50,660 --> 04:03:00,180
フルスタックデベロッパーです。

2014
04:03:00,180 --> 04:03:10,660
次に、この内側のdivの下に、テキストxsで別の段落タグを配置します。

2015
04:03:11,620 --> 04:03:18,740
背景は常に白なので、テキストの色をハードコードしていることを覚えておいてください。

2016
04:03:18,740 --> 04:03:23,780
テーマによってテキストの色を変えたくないからです。

2017
04:03:23,780 --> 04:03:31,300
というのも、このdivも常に白だからです。

2018
04:03:31,300 --> 04:03:37,540
そして、ここではアドレスフィールドをレンダリングしています。

2019
04:03:37,540 --> 04:03:46,740
そして、このデータをここにレンダリングします。

2020
04:03:46,740 --> 04:03:57,060
次にカンマが必要ですが、これは都市と国が定義されている場合のみです。

2021
04:03:57,060 --> 04:04:03,700
cityが定義されていて空でないこと、countryが定義されていて空でないことをチェックする。

2022
04:04:05,060 --> 04:04:12,500
カンマがなければ空文字列をレンダリングしたい。

2023
04:04:12,500 --> 04:04:19,940
少し小さいですが、コンマがあるのがわかると思います。

2024
04:04:19,940 --> 04:04:27,700
カンマの後には空白が必要です。

2025
04:04:30,740 --> 04:04:35,620
次にまた中括弧を追加します。

2026
04:04:35,620 --> 04:04:46,180
または国が定義され、空でなく、括弧の電話番号または電子メールに値がある。

2027
04:04:46,180 --> 04:04:53,780
ここに箇条書きを入れたいのですが、私のキーボードでは箇条書きの書き方がわかりません。

2028
04:04:53,780 --> 04:05:00,100
そこで、グーグルで箇条書きのアイコンを検索して、このアイコンをコピーした。

2029
04:05:01,060 --> 04:05:09,540
このアイコンをコピーしてここに置き、その横にスペースを2つ入れます。

2030
04:05:09,540 --> 04:05:16,420
この箇条書きは、電話番号かメールアドレスのどちらかがある場合のみ表示されます。

2031
04:05:16,420 --> 04:05:23,220
メールアドレスがない場合は、箇条書きの文字列は表示されません。

2032
04:05:23,220 --> 04:05:29,540
そして最後に、電話番号とメールアドレスをレンダリングし、別の箇条書きで分割したい。

2033
04:05:29,540 --> 04:05:36,500
箇条書きにしたいので、この下に別の式を入れ、クズ括弧で配列を追加する。

2034
04:05:36,500 --> 04:05:44,500
空でないものだけを残すようにフィルターをかける。

2035
04:05:44,500 --> 04:05:51,380
このフィルタのように、ここでは大文字のbのブール値を渡す。

2036
04:05:51,380 --> 04:05:58,580
を移動させ、何か入力されたものだけを残すようにする。

2037
04:05:59,780 --> 04:06:03,940
このように2つの空白を含む箇条書きで結合します。

2038
04:06:03,940 --> 04:06:10,900
電話番号とメールアドレスが箇条書きで分割されています。

2039
04:06:10,900 --> 04:06:16,020
2つ目の箇条書きがなくなり、ここでも同様に、常に見栄えが良くなるようにする。

2040
04:06:16,020 --> 04:06:23,780
画像を選択してプレビューに表示することもできます。

2041
04:06:23,780 --> 04:06:30,500
これでオブジェクトのURLから作成されました。

2042
04:06:30,500 --> 04:06:37,860
要約はこのフォームの最後の部分であり、一番上に表示されるべきである。

2043
04:06:37,860 --> 04:06:43,940
ここに何かを入力し、同じファイルに別のコンポーネントを作成します。

2044
04:06:43,940 --> 04:06:49,460
関数サマリーセクション

2045
04:06:52,180 --> 04:06:58,660
この関数もまた、履歴書データのある履歴書セクションの小道具を受け取ります。

2046
04:06:58,660 --> 04:07:05,460
再度、このレジュメデータを再構築しますが、今回はサマリーだけが必要です。

2047
04:07:05,460 --> 04:07:16,020
サマリーが未定義または空の場合は、何もレンダリングせず、nullを返します。

2048
04:07:18,260 --> 04:07:22,180
サマリーが定義されている場合は、フラグメントをレンダリングします。

2049
04:07:22,180 --> 04:07:31,300
このhrタグで区切り線を作成し、それを少し太くする。

2050
04:07:31,300 --> 04:07:38,820
ボーダーツールを使って、このタグを自閉タグにし、その下にdivを配置します。

2051
04:07:38,820 --> 04:07:44,900
これをプレビューの一番上に置くと、個人情報ヘッダーの下に

2052
04:07:46,580 --> 04:07:53,780
サマリーセクションをレンダリングします。

2053
04:07:53,780 --> 04:08:00,180
これは要約に何かを入力した場合のみ表示されます。

2054
04:08:00,180 --> 04:08:07,460
この区切り線の色は後で変更できます。

2055
04:08:07,460 --> 04:08:16,420
そしてここに、テキストlg、フォントzimmiboldの段落を入れます。

2056
04:08:16,420 --> 04:08:21,620
これはプロフェッショナル・プロフィールの見出しです

2057
04:08:21,620 --> 04:08:31,700
そして、入力の書式を維持するために、改行と空白を維持するために、空白のpre-lineを持つdivを配置します。

2058
04:08:31,700 --> 04:08:40,900
改行と空白はそのままに、テキストを少し小さくして、ここに要約を表示します。

2059
04:08:40,900 --> 04:08:50,180
これで要約が表示され、改行もすべてそのままです。

2060
04:08:50,180 --> 04:08:57,380
この見出しと要約そのものを包むdivには、さらにbreakと呼ばれるクラスがある。

2061
04:08:57,940 --> 04:09:05,780
というcss属性を追加するものである。

2062
04:09:05,780 --> 04:09:13,060
このクラスは、後でこの履歴書を印刷するときに、このdivが分割されないようにするものです。

2063
04:09:13,060 --> 04:09:19,460
このようにすることで、印刷時にこのdivを1つにまとめることができます。

2064
04:09:19,460 --> 04:09:25,300
また、この区切りはavoid classの中で他のセクションでも何度か使用します。

2065
04:09:26,900 --> 04:09:31,300
次のセクションは職歴のセクションです。

2066
04:09:31,300 --> 04:09:39,940
ここでも履歴書の小道具を受け取ります。

2067
04:09:39,940 --> 04:09:47,860
ここから職歴の配列を再構築します。

2068
04:09:51,140 --> 04:09:57,540
このセクションをレンダリングするのは、実際にデータを含む職務経歴がある場合だけにしたい。

2069
04:09:57,540 --> 04:10:03,940
というのも、このように空の職務経歴を追加すると、配列は空ではなくなります。

2070
04:10:03,940 --> 04:10:09,860
まだ何も入力していないので、区切り線などは描画したくない。

2071
04:10:09,860 --> 04:10:21,460
この配列の下に、空ではないconst work experiencesを作成します。

2072
04:10:21,460 --> 04:10:30,660
少なくとも1つの入力フィールドに何か入力されているものだけを残したい。

2073
04:10:30,660 --> 04:10:38,740
フィールドをひとつひとつチェックするのではなく

2074
04:10:38,740 --> 04:10:46,100
フィールドをひとつずつチェックするのではなく、このようにオブジェクトのドット値を使って一度にチェックすることができる。

2075
04:10:46,100 --> 04:10:51,700
このようにして、このオブジェクトのすべての異なる値の配列を取得します。

2076
04:10:51,700 --> 04:10:58,180
職名、日付、説明の配列が得られる。

2077
04:10:58,180 --> 04:11:02,900
そして、空または未定義でないものだけを保持する boolean を渡します。

2078
04:11:03,940 --> 04:11:10,340
この配列の長さが0より大きければ、少なくとも1つの

2079
04:11:10,340 --> 04:11:16,260
この配列の長さがゼロより大きければ、入力フィールドの少なくともひとつが正しく定義されていることになる。

2080
04:11:16,260 --> 04:11:19,540
を作成する。

2081
04:11:19,540 --> 04:11:30,820
以下では、感嘆符のついた職務経験が空でないかどうかをチェックする。

2082
04:11:30,820 --> 04:11:36,420
が未定義かゼロの場合、何もレンダリングせず、NULLを返します。

2083
04:11:36,420 --> 04:11:45,620
そうでなければ、空のフラグメントを返します。

2084
04:11:45,620 --> 04:11:53,380
そしてスペースy3のdiv

2085
04:11:55,540 --> 04:12:03,940
ここにまた、段落タグのテキストlgeフォントzimmiboldの形で見出しを入れます。

2086
04:12:03,940 --> 04:12:13,620
そして、その下に仕事経験と書いてある。

2087
04:12:13,620 --> 04:12:21,380
空でないものだけをマッピングしたい。

2088
04:12:22,020 --> 04:12:27,620
このようにインデックスも必要です。

2089
04:12:27,620 --> 04:12:33,940
括弧はコンポーネントを返したいからです。

2090
04:12:33,940 --> 04:12:40,020
インデックスが必要なのは、インデックスがキーになるからだ。

2091
04:12:40,020 --> 04:12:48,340
インデックスがキーになるので、インデックスが必要になる。

2092
04:12:48,340 --> 04:13:03,780
ページとスペースy1の間に別のdivを置き、テキストsmの間にflex item center
justifyを入れます。

2093
04:13:03,780 --> 04:13:12,340
このdivを閉じ、divの閉じタグを追加します。

2094
04:13:13,460 --> 04:13:20,020
とりあえず保存して、履歴書プレビューの3番目のセクションに入れます。

2095
04:13:20,020 --> 04:13:24,580
職歴のセクションを作成します。

2096
04:13:24,580 --> 04:13:32,180
仕切り線が表示されるはずですが、何かを入力したときだけ表示されます。

2097
04:13:32,180 --> 04:13:37,860
このように、何も入力されていない場合は何も表示されない。

2098
04:13:37,860 --> 04:13:45,140
しかし、職歴もレンダリングしなければならない。

2099
04:13:45,140 --> 04:13:48,580
職種 会社名

2100
04:13:48,580 --> 04:13:58,580
開始日と終了日を入力し、画面にレンダリングします。

2101
04:13:58,580 --> 04:14:02,580
このdivの中に

2102
04:14:04,820 --> 04:14:11,380
まず、職歴の位置をspanで囲みます。

2103
04:14:11,380 --> 04:14:16,500
これが職種名です。

2104
04:14:16,500 --> 04:14:25,620
その下に、経験の開始日が定義されているかどうかをチェックします。

2105
04:14:25,620 --> 04:14:30,420
を別のスパンの形でambersandscienceの括弧にレンダリングします。

2106
04:14:32,820 --> 04:14:38,500
ここでformat dateを呼び出したいが、自動インポートが機能しないので、手動でインポートする。

2107
04:14:38,500 --> 04:14:46,820
最初にインストールしたdate fnsから中括弧をインポートする。

2108
04:14:46,820 --> 04:14:54,180
そしてこの中にformat date関数がある。

2109
04:14:57,300 --> 04:15:04,900
フォーマット・デートにドット開始日を渡し、2番目の引数に

2110
04:15:04,900 --> 04:15:13,380
大文字のmを2つ並べたスラッシュy y yで月を表示したい。

2111
04:15:13,380 --> 04:15:21,780
で年を表示し、その後にこの条件の後に閉じ中括弧の後に

2112
04:15:21,780 --> 04:15:28,660
空白、マイナス、中かっこ、そして空文字列を書く。

2113
04:15:28,660 --> 04:15:35,140
空白を1つ入れると、左側に空白を含むマイナス、右側に空白を含むマイナスが作成されます。

2114
04:15:35,140 --> 04:15:41,380
文字列の条件として空白を入れる必要がある。

2115
04:15:41,380 --> 04:15:49,220
私のように入力して、まず終了日が定義されているかどうかをチェックする。

2116
04:15:49,220 --> 04:15:54,740
次に、もう一度format dateを呼び出す。

2117
04:15:54,740 --> 04:15:58,740
と同じ文字列を渡す。

2118
04:15:58,740 --> 04:16:08,180
しかし、終了日が未定義の場合は、現在のテキストをレンダリングしたい。

2119
04:16:08,180 --> 04:16:14,740
終了日が空の場合は、現在ここで働いていることを意味する。

2120
04:16:15,780 --> 04:16:22,580
開始日を削除すると、何も表示されなくなる。

2121
04:16:22,580 --> 04:16:29,220
なぜなら開始日がなければ無効だからだ。

2122
04:16:29,220 --> 04:16:35,460
を削除すると「現在」と表示され、さらに勤務先とその説明も表示されます。

2123
04:16:35,460 --> 04:16:38,340
この差分の下に

2124
04:16:40,820 --> 04:16:47,540
テキストをxs、フォントをzimmiboltとした段落をもうひとつ追加する。

2125
04:16:47,540 --> 04:16:55,540
この職歴の会社をレンダリングする。

2126
04:16:55,540 --> 04:17:06,500
空白行を前行に置き、再びテキストxsを使用して、経験の説明をレンダリングします。

2127
04:17:07,700 --> 04:17:14,820
diffを閉じるタグがないので、このタグを複製して保存する。

2128
04:17:14,820 --> 04:17:21,220
そして2つ目に何かを入力すると、同様に表示されます。

2129
04:17:21,220 --> 04:17:28,580
あとで、この仕事体験の順番を入れ替えることができる。

2130
04:17:28,580 --> 04:17:38,180
教育セクションを作成しよう。

2131
04:17:38,180 --> 04:17:43,380
いつものように、履歴書セクションの小道具を再構築します。

2132
04:17:43,380 --> 04:17:52,100
履歴書データから学歴を取得します。

2133
04:17:54,100 --> 04:18:02,500
ここでも空ではない配列を作成します。

2134
04:18:02,500 --> 04:18:12,580
educationsが空でなければ、educations配列にフィルターをかける。

2135
04:18:12,580 --> 04:18:23,540
educationの場合、この配列が空かどうかをチェックする。

2136
04:18:24,020 --> 04:18:31,780
そうでない場合はnullを返します。

2137
04:18:31,780 --> 04:18:37,860
このreturn文を丸ごとコピーしてもいいかもしれない。

2138
04:18:37,860 --> 04:18:48,340
ここでは、この内容で空のフラグメントを返します。

2139
04:18:50,100 --> 04:18:55,860
もちろん、educationsは空ではありません。

2140
04:18:55,860 --> 04:19:01,540
このスパンはedu.degreeをレンダリングします。

2141
04:19:01,540 --> 04:19:09,140
教育には説明がないので、説明を削除します。

2142
04:19:09,140 --> 04:19:16,580
の代わりに学校をレンダリングします。

2143
04:19:16,580 --> 04:19:19,780
スパン内をすべて削除してみましょう。

2144
04:19:19,780 --> 04:19:30,100
edu.startDateが定義されているかどうかをチェックする式を追加します。

2145
04:19:30,100 --> 04:19:36,580
バックティック文字列をこのようにレンダリングします。

2146
04:19:36,580 --> 04:19:45,700
ここでformatDateを呼び出し、edu.startDateを渡します。

2147
04:19:45,700 --> 04:19:55,620
書式はmm/とし、yを4つ並べます。

2148
04:19:55,620 --> 04:20:03,540
終了日が定義されていない場合は、レンダリングしたくないので、スペースと別の式を入れます。

2149
04:20:03,540 --> 04:20:09,300
というのは、通常、学歴は過去のものであり、あなたはすでに社会人だからです。

2150
04:20:09,300 --> 04:20:14,820
ですから、終了日が定義されていない場合は、presentの代わりに何もレンダリングしないようにします。

2151
04:20:14,820 --> 04:20:23,300
そこで、edu.endDateが定義されているかどうかをチェックし、次のようなバックティック文字列をレンダリングする。

2152
04:20:23,300 --> 04:20:28,260
そうでなければ、空の文字列をレンダリングする。

2153
04:20:28,260 --> 04:20:36,900
ここにダッシュ・スペースと別の式を入れたい。

2154
04:20:36,900 --> 04:20:42,900
コードがわかりにくくなってきたら、いつでもこの部分のリポジトリとブランチを見ることができる。

2155
04:20:42,900 --> 04:20:48,660
コードをコピーペーストすることもできます。

2156
04:20:48,660 --> 04:20:55,380
を呼び出して、edu.endDatesを同じ日付フォーマットでフォーマットしています。

2157
04:20:55,380 --> 04:21:06,180
どこかにタイプミスがなければ、これで終わりです。

2158
04:21:06,820 --> 04:21:13,700
何か入力するとすぐにプレビューにレンダリングされます。

2159
04:21:13,700 --> 04:21:22,260
この行を複製しましょう。

2160
04:21:22,260 --> 04:21:28,820
この学位は空なので何も表示されません。

2161
04:21:28,820 --> 04:21:36,100
開始日だけを設定すると、開始日だけが表示されます。

2162
04:21:36,100 --> 04:21:41,780
終了日も設定すれば、終了日も表示されます。

2163
04:21:41,780 --> 04:21:47,300
もちろん、さらに教育を追加することもできるし、削除することもできる。

2164
04:21:47,300 --> 04:21:53,940
最後のセクションはスキルセクションです。

2165
04:21:53,940 --> 04:22:01,380
最後のセクションはスキルのセクションです。

2166
04:22:04,340 --> 04:22:13,460
ここにも履歴書セクションの小道具があり、ここで履歴書データを見つけることができます。

2167
04:22:13,460 --> 04:22:18,180
を履歴書データから再構築します。

2168
04:22:18,180 --> 04:22:24,340
skills.lengthが未定義かどうかをチェックする。

2169
04:22:24,340 --> 04:22:31,220
何もレンダリングしたくない場合は、フラグメントを再度レンダリングする。

2170
04:22:32,020 --> 04:22:34,020
ボーダーツアー付きhr

2171
04:22:34,020 --> 04:22:39,540
とdiv

2172
04:22:39,540 --> 04:22:47,220
breakをavoidとspace y3で囲みます。

2173
04:22:47,220 --> 04:22:59,620
この中に段落があり、テキストはlg、フォントはzimmiboltで、skillsと書かれている。

2174
04:22:59,860 --> 04:23:09,460
skillsと書かれたdivの下に、flexでスタイルを設定します。

2175
04:23:09,460 --> 04:23:18,340
フレックスラップと2つの空白を入れ、各スキルごとにレンダリングしたい。

2176
04:23:18,340 --> 04:23:23,700
というのは、フォームでこの処理を行ったからです。

2177
04:23:24,500 --> 04:23:30,420
というわけで、スキルだけを取り出して、ここにマッピングすることができます。

2178
04:23:30,420 --> 04:23:33,140
そして

2179
04:23:33,140 --> 04:23:42,820
uiフォルダのshadcnから来るバッチ大文字のbバッチをレンダリングしたい。

2180
04:23:42,820 --> 04:23:47,940
インデックスがキーです。

2181
04:23:47,940 --> 04:23:53,220
スタイル設定する前に、ここでスキルをレンダリングしよう。

2182
04:23:55,220 --> 04:24:00,420
これを保存して、レジュメのプレビューに入れます。

2183
04:24:00,420 --> 04:24:05,300
スキルセクション 履歴書データ

2184
04:24:05,300 --> 04:24:09,220
に入力してみましょう。

2185
04:24:09,220 --> 04:24:18,740
スキル1を空欄にすると、自動的にフィルタリングされます。

2186
04:24:19,540 --> 04:24:28,180
so we have here skill one skill two and so on this
is how these batches look by default

2187
04:24:28,180 --> 04:24:36,180
しかし、デフォルトではバッチの色がテーマによって変わるので、少しスタイルを変えたい。

2188
04:24:36,180 --> 04:24:43,540
しかしもちろん、常に同じ色であるべきではないので、ここで色をハードコードします。

2189
04:24:44,340 --> 04:24:52,340
後で背景色をカスタマイズできるようになるので、丸みを帯びたmdに設定したい。

2190
04:24:52,340 --> 04:24:59,140
後でボーダーの半径を変更することもできますが、今のところ重要な違いは、テーマを変更したときに

2191
04:24:59,140 --> 04:25:05,700
テーマを変更しても、これらのバッチはその色を維持することです。

2192
04:25:05,700 --> 04:25:12,580
これは最新バージョンのコンポーネントの変更に違いない。

2193
04:25:12,580 --> 04:25:19,700
ホバーしたときに色が変わっているようなので、これも上書きしよう。

2194
04:25:19,700 --> 04:25:28,660
そうすれば、このエフェクトを取り除くことができます。

2195
04:25:28,660 --> 04:25:34,900
画像とスキルタグのボーダー半径をカスタマイズできるようにしたい。

2196
04:25:34,900 --> 04:25:41,460
オプションはどのフォームにも含まれていません。

2197
04:25:41,460 --> 04:25:47,300
履歴書プレビューセクションに2つのボタンを設置し、ボーダー半径と色をカスタマイズできるようにしたい。

2198
04:25:47,300 --> 04:25:55,540
この2つの値は、履歴書の値型の一部となる必要があります。

2199
04:25:55,540 --> 04:26:02,900
履歴書スキーマに2つの新しい値を追加したいのです。

2200
04:26:02,900 --> 04:26:08,980
最初の値はcolor hexと呼ばれるもので、オプションの文字列です。

2201
04:26:10,740 --> 04:26:18,740
そしてボーダースタイルもオプションの文字列です。

2202
04:26:18,740 --> 04:26:24,420
バックエンドでもスキーマを使って入力を検証します。

2203
04:26:24,420 --> 04:26:30,500
履歴書スキーマに追加することで、正しい値を受け取ることができます。

2204
04:26:30,500 --> 04:26:39,300
履歴書スキーマに追加することで、正しい値を受け取ることができます。

2205
04:26:39,300 --> 04:26:47,700
そして、この2つの値をレジューム値の型に追加したことで、次のことができるようになった。

2206
04:26:47,700 --> 04:26:56,580
これらの値をレイアウトに適用することができます。

2207
04:26:56,580 --> 04:27:03,620
をレイアウトに適用することができますが、もちろんどこかに設定しなければなりません。

2208
04:27:03,620 --> 04:27:13,060
エディターフォルダーに新しいコンポーネントを作成しましょう。

2209
04:27:13,060 --> 04:27:19,300
このコンポーネント関数をここにエクスポートします

2210
04:27:19,300 --> 04:27:29,620
このカラーピッカーを作成するには、最初にインストールしたreact
colorパッケージを使用します。

2211
04:27:29,620 --> 04:27:36,500
このtwitterピッカーを使い、チャットCとポップオーバーを組み合わせます。

2212
04:27:36,500 --> 04:27:39,540
ボタンをクリックしたときにこのカラーピッカーを表示できるようにします。

2213
04:27:39,540 --> 04:27:50,020
このコンポーネントには小道具のカラーピッカーが必要です。

2214
04:27:50,020 --> 04:27:59,220
これはreact colorパッケージのcolor型かundefinedになります。

2215
04:27:59,220 --> 04:28:05,940
16進数の文字列を受け入れるので、これを文字列にすることもできると思いますが、このカラークラスには16進数の文字列が含まれていると思います。

2216
04:28:05,940 --> 04:28:12,580
文字列を含むので、このようにすることで、後でreact color

2217
04:28:12,580 --> 04:28:22,340
カラーピッカーに適用するときに、後で型をアサートする必要がなくなります。

2218
04:28:22,340 --> 04:28:29,460
react colorからの別のインポートです。

2219
04:28:29,460 --> 04:28:38,820
次に、このコンポーネントで

2220
04:28:38,820 --> 04:28:49,860
show popoverとset show
popoverはカラーピッカーのポップアップが現在表示されているかどうかを定義します。

2221
04:28:50,500 --> 04:28:57,780
この状態をfalseで初期化し、コンポーネントからポップオーバーを返します。

2222
04:28:57,780 --> 04:29:09,700
このフォルダに、ポップオーバーの表示状態であるオープン状態と、オープン時の変化を渡します。

2223
04:29:09,700 --> 04:29:18,660
を呼び出すコールバックを渡します。このようにしてポップオーバーを表示したり隠したりします。

2224
04:29:18,660 --> 04:29:25,460
このコンポーネントの構造と使い方はshadcとドキュメントで説明されています。
ポップオーバートリガーをレンダリングします。

2225
04:29:25,460 --> 04:29:30,340
をレンダリングしますが、ボタンをレンダリングしたいので、再び子プロップとして使います。

2226
04:29:30,340 --> 04:29:42,900
このボタンにはlucid reactパッケージのパレットアイコンが含まれます。

2227
04:29:46,420 --> 04:29:52,580
そして、サイズを5に設定します。

2228
04:29:52,580 --> 04:29:59,060
レジュームプレビューセクションに配置します。

2229
04:29:59,060 --> 04:30:06,500
このhiddenクラスを持つ外側のdivに移動し、相対配置に設定します。

2230
04:30:06,500 --> 04:30:15,140
このdivの中に、カラーピッカーを含む別のdivを自己閉じタグで囲みます。

2231
04:30:16,260 --> 04:30:24,340
レジュームデータのドットカラー16進数から取得した色が必要です。

2232
04:30:24,340 --> 04:30:30,580
この変更時のコールバックでは、エラー関数を渡して新しい色を受け取ります。

2233
04:30:30,580 --> 04:30:38,260
そして、この関数で何をしたいかというと、set resume
dataを呼び出して、色の値を変更したいのです。

2234
04:30:38,260 --> 04:30:44,820
ページに保存しているレジュームデータの状態を変更します。

2235
04:30:44,820 --> 04:30:53,460
括弧 中括弧 既存のレジュメデータを拡散します。

2236
04:30:53,460 --> 04:30:59,140
16進数の色を変更し、新しい色に設定します。

2237
04:30:59,140 --> 04:31:08,020
ボタンができましたが、まだ正しく見えません。

2238
04:31:08,020 --> 04:31:14,340
レジュメのプレビューアの横に置くのではなく、その上に置くべきです。

2239
04:31:14,340 --> 04:31:22,740
にクラス名を追加します。

2240
04:31:22,740 --> 04:31:30,740
を付けて、フレックスボックスにしてフレックスカラムにします。

2241
04:31:30,740 --> 04:31:37,620
というのも、この中に2つ目のボタンを入れるからです。

2242
04:31:37,620 --> 04:31:45,620
コンテナが縮小してもボタンの大きさは変わらないようにします。

2243
04:31:45,620 --> 04:31:54,980
このように左3つ、上3つでパディングを3つに増やします。

2244
04:31:54,980 --> 04:32:02,020
したがって、lgブレークポイントの下の小さな画面ではパディングを1にし、大きな画面ではパディングを3にします。

2245
04:32:02,020 --> 04:32:07,940
大きな画面ではパディングが3つになります。

2246
04:32:07,940 --> 04:32:13,940
実際にはマージンですが、大きな画面では余裕があるのでマージンを3にしています。

2247
04:32:13,940 --> 04:32:22,020
これを保存して、カラーピッカーに戻りましょう。

2248
04:32:22,020 --> 04:32:30,260
バリアントをアウトラインに設定するとこのようになり、ライトモードではこのようになります。

2249
04:32:31,860 --> 04:32:36,580
不要なパディングを削除するために、サイズもアイコンに設定します。

2250
04:32:36,580 --> 04:32:44,580
スクリーン・リーダーに便利なタイトルを設定することができます。

2251
04:32:44,580 --> 04:32:53,460
このボタンにカーソルを合わせると、タイトルが表示されます。

2252
04:32:53,460 --> 04:32:59,860
ボタンにカーソルを合わせるとタイトルが表示されます。

2253
04:32:59,860 --> 04:33:09,140
ボタンをクリックすると、ポップオーバーを表示するハンドラが呼び出されます。

2254
04:33:09,140 --> 04:33:17,140
カラー・ピッカーを表示するにはtrueを指定します。

2255
04:33:17,140 --> 04:33:22,980
階層を実装するときに、まず正しい購読があるかどうかをチェックし、それからポップオーバーを表示します。

2256
04:33:22,980 --> 04:33:29,380
そうでない場合は、このプレミアムダイアログを表示します。

2257
04:33:30,420 --> 04:33:32,260
ポップオーバーコンテンツ

2258
04:33:32,260 --> 04:33:40,180
そしてここでtwitterピッカーをレンダリングします。

2259
04:33:40,180 --> 04:33:47,700
に現在選択されている色と変更時のコールバックを渡す必要があります。

2260
04:33:47,700 --> 04:33:57,380
を渡す必要があります。

2261
04:33:58,180 --> 04:34:02,980
をクリックすると、twitterのカラーピッカーが表示されます。

2262
04:34:02,980 --> 04:34:12,340
の背景が残っているので、ポップオーバーのコンテンツにクラス名を追加してこれを削除しましょう。

2263
04:34:12,340 --> 04:34:18,340
border noneで背景を透明にし、シャドウも削除します。

2264
04:34:18,340 --> 04:34:21,700
これで背景は見えなくなりました

2265
04:34:24,020 --> 04:34:33,060
また、このポップオーバーのalign propをendに設定します。

2266
04:34:33,060 --> 04:34:37,860
twitterピッカーの左上に小さな四角形があります。

2267
04:34:37,860 --> 04:34:45,140
rectangleと呼ばれるtwitterピッカーの別のプロップで右上に置くことができます。

2268
04:34:45,140 --> 04:34:52,180
この三角形はボタンと正しく配置され、色を変更すると

2269
04:34:52,180 --> 04:34:58,980
色を変更すると、これがページに渡されます。

2270
04:34:58,980 --> 04:35:05,780
履歴書プレビューにはまだこれらの値を適用していません。

2271
04:35:05,780 --> 04:35:11,700
個人情報のヘッダーと、16進数の色を使って履歴書をカスタマイズしてみましょう。

2272
04:35:11,700 --> 04:35:18,980
姓と名の段落から始めましょう。

2273
04:35:18,980 --> 04:35:25,780
javascriptの変数からcssの値をカスタマイズしたい場合は、このスタイルプロップを使ってください。

2274
04:35:25,780 --> 04:35:32,820
これはtailwindクラスでは動作しないので、ここでは色をカスタマイズすることができます。

2275
04:35:32,820 --> 04:35:39,060
レジュメデータから再構築した16進数色に設定します。

2276
04:35:39,060 --> 04:35:44,500
この名前の色はここで選択したものに変わります。

2277
04:35:45,700 --> 04:35:48,820
好きな16進数を選ぶことができます。

2278
04:35:48,820 --> 04:35:57,300
では、他のテキストも続けてみましょう。

2279
04:35:57,300 --> 04:36:04,420
そして役職の段落タグに貼り付けます。

2280
04:36:04,420 --> 04:36:11,860
このテキストではなく、このグレーのままの方が見栄えが良いと思います。

2281
04:36:11,860 --> 04:36:18,420
この下にあるサマリー・セクションに行き、ここでもカラー・ヘックスを再構築します。

2282
04:36:18,420 --> 04:36:26,100
ボーダースタイルは後で処理します。

2283
04:36:26,100 --> 04:36:36,660
propを追加しますが、ここでは枠線の色を設定します。

2284
04:36:36,660 --> 04:36:44,660
このプロフェッショナル・プロフィールという見出しも変更したいので、ここに貼り付けます。

2285
04:36:44,660 --> 04:36:51,860
ここでもまた、六角形の色を再構築する。

2286
04:36:51,860 --> 04:37:02,900
ボーダーカラーで色付けし、職歴と書かれたテキストも同様に色付けする。

2287
04:37:05,620 --> 04:37:12,100
そして、それぞれの職歴の一番上の行に、職名と日付を記入する。

2288
04:37:12,100 --> 04:37:22,180
職位と日付を含むdivをここに貼り付けます。

2289
04:37:22,180 --> 04:37:29,700
スタイルプロップも貼り付けて、これらにも色を付けます。

2290
04:37:30,580 --> 04:37:36,580
hrの区切り線の色を16進数で指定します。

2291
04:37:36,580 --> 04:37:42,420
教育テキストのボーダーカラー

2292
04:37:42,420 --> 04:37:47,140
そしてこのdiv

2293
04:37:47,140 --> 04:37:53,540
スキル

2294
04:37:56,820 --> 04:38:00,660
16進数色にします。

2295
04:38:00,660 --> 04:38:12,020
スキルというテキストとバッジの背景色をスタイリングしたい。

2296
04:38:12,020 --> 04:38:16,660
バッジの背景色を指定します。

2297
04:38:16,660 --> 04:38:25,380
これで、バッジが緑色になり、履歴書がよりかっこよくなりました。

2298
04:38:27,060 --> 04:38:32,020
次に、画像の境界線の半径を変更できるボタンを追加します。

2299
04:38:32,020 --> 04:38:37,780
次に、画像の境界線の半径を変更できるボタンを追加したいと思います。

2300
04:38:37,780 --> 04:38:45,940
それをborder style button dot tsxと呼びます。

2301
04:38:45,940 --> 04:38:50,980
このコンポーネントをここにエクスポートします

2302
04:38:53,700 --> 04:38:55,620
そしてもちろん、これは小道具が必要です

2303
04:38:55,620 --> 04:39:06,900
現在選択されているボーダー・スタイルをこのコンポーネントに渡す必要があります。

2304
04:39:06,900 --> 04:39:14,740
これは単純な文字列かundefinedになります。

2305
04:39:14,740 --> 04:39:21,860
変更されないコールバックがあり、そこで新しいボーダースタイルを文字列として親に返します。

2306
04:39:22,260 --> 04:39:26,260
そして、これらのプロップをここで再構築します

2307
04:39:26,260 --> 04:39:40,420
一番上にhandle clickという関数を置き、今は空にしておきます。

2308
04:39:40,420 --> 04:39:48,580
そしてその下に、バリアント・アウトラインを持つボタン大文字のbを返します。

2309
04:39:50,260 --> 04:40:00,820
このボタンをクリックすると、私たちの

2310
04:40:00,820 --> 04:40:07,860
クリック・コールバックを処理し、このボタンの内部では、とりあえずlucidのスクリュー・アイコンをレンダリングする。

2311
04:40:07,860 --> 04:40:15,460
のアイコンをレンダリングしている。

2312
04:40:15,460 --> 04:40:22,980
このアイコンを保存して、レジュメのプレビュー・セクションのカラー・ピッカーの隣に配置します。

2313
04:40:22,980 --> 04:40:32,740
この絶対差分ボーダースタイル・ボタンの内側には、現在選択されているボーダースタイルが表示されます。

2314
04:40:32,740 --> 04:40:39,940
これは履歴書データから取得したもので、単なる文字列です。

2315
04:40:41,060 --> 04:40:46,500
を呼び出します。

2316
04:40:46,500 --> 04:40:56,980
履歴データを更新したいので、履歴データを呼び出します。

2317
04:40:56,980 --> 04:41:08,980
そして、このボタンタグを閉じなければなりません。

2318
04:41:08,980 --> 04:41:15,060
がレジュメの一部を隠しています。

2319
04:41:15,060 --> 04:41:21,140
この2つのボタンをデフォルトで透明にしたいのです。

2320
04:41:21,140 --> 04:41:27,540
デフォルトではこの2つのボタンを透明にし、レジュメプレビューセクションにカーソルを置いたときに表示するようにします。

2321
04:41:27,540 --> 04:41:34,340
この外側の差分にグループクラスを追加します。

2322
04:41:34,340 --> 04:41:40,820
この大きな差分の状態が変化したときに、これらのボタンのスタイルを変更することができます。

2323
04:41:40,820 --> 04:41:46,580
を完全な不透明度で表示したいからです。

2324
04:41:46,580 --> 04:41:55,300
次に、この内側の差分（絶対配置の差分）に移動し、不透明度を 50 に設定します。

2325
04:41:55,300 --> 04:42:02,900
デフォルトでこれらのボタンを透明にします。

2326
04:42:02,900 --> 04:42:09,940
不透明度を100に戻し、大きな画面では常に完全な不透明度にします。

2327
04:42:09,940 --> 04:42:16,260
小さな画面では50透過になり、group hoverモディファイアを使うことができます。

2328
04:42:16,260 --> 04:42:21,700
を使用することができます。これは、このグループ（この外側の差分全体）の上にカーソルを置くとトリガーされます。

2329
04:42:21,700 --> 04:42:30,420
ここにカーソルを置くと、不透明度を10対100ではなく、100に戻したい。

2330
04:42:30,420 --> 04:42:37,060
この差分の上にカーソルを置くと、ボタンは完全な不透明度で表示される。

2331
04:42:37,060 --> 04:42:44,980
トランジション・オペシティ・クラスで適用できる小さなトランジション・アニメーションも追加したい。

2332
04:42:44,980 --> 04:42:52,340
大きな画面では常に完全な不透明度で表示される。

2333
04:42:52,340 --> 04:42:58,660
しかし、小さな画面では、このように透明になっている。

2334
04:42:58,660 --> 04:43:03,780
でももちろん、このボタンはまだ何もしません。

2335
04:43:03,780 --> 04:43:11,220
ボーダースタイル・ボタン・コンポーネントに戻り、一番上にある

2336
04:43:11,220 --> 04:43:19,380
というオブジェクトをエクスポートしたいと思います。

2337
04:43:19,380 --> 04:43:24,580
文字列をハードコードする必要がない。

2338
04:43:24,580 --> 04:43:31,380
定数の命名規則は大文字なので、最初の定数はsquareで

2339
04:43:31,380 --> 04:43:42,100
これをsquareという文字列に代入し、次にcircle、squircleという3つのオプションを指定する。

2340
04:43:42,100 --> 04:43:50,340
この定数の下にボーダーの半径を指定するために、別の定数を作成する。

2341
04:43:50,340 --> 04:43:56,980
ここで、このオブジェクトを配列にしたい。

2342
04:43:56,980 --> 04:44:06,580
オブジェクトのドット値でこれを行うことができます。

2343
04:44:06,580 --> 04:44:13,140
この3つの文字列を含む配列ができました。

2344
04:44:13,140 --> 04:44:23,140
この配列の項目を循環させるには、次のようにします。

2345
04:44:23,140 --> 04:44:30,180
このボーダー・スタイルの文字列が定義されているかどうかをチェックします。

2346
04:44:30,180 --> 04:44:35,860
のインデックスを求めます。

2347
04:44:37,220 --> 04:44:45,940
そこで、ボーダースタイルに疑問符をつけ、sを複数形にして、ボーダースタイルのインデックスを単数形にします。

2348
04:44:45,940 --> 04:44:52,900
現在のインデックスが未定義の場合は、インデックスをゼロに設定し、最初の項目から開始するようにします。

2349
04:44:52,900 --> 04:45:03,860
次のインデックスは現在のインデックスに1を足したものに等しい。

2350
04:45:03,860 --> 04:45:12,260
モジュラス演算子を使います。これはパーセント記号で、ボーダースタイルのドット長を書きます。

2351
04:45:12,260 --> 04:45:18,340
次のインデックスが最後の要素を超えないようにし、代わりに最初の要素に戻るようにする。

2352
04:45:18,340 --> 04:45:23,460
例えば、これが4で、3つの項目しかないので無効なインデックスだとすると

2353
04:45:23,460 --> 04:45:30,340
とすると、4モジュラス3は1となり、最初のインデックスからやり直すことになる。

2354
04:45:30,340 --> 04:45:35,620
ギベットはこのロジックを考え出した。

2355
04:45:35,620 --> 04:45:42,740
冗長な方法ですが、意味はあります。そして、大文字のcでchangeコールバックを呼び出しました。

2356
04:45:42,740 --> 04:45:50,980
そして、次のインデックスでボーダースタイルを渡します。

2357
04:45:50,980 --> 04:45:58,660
このようにして、異なるボーダー半径の間を循環させることができる。

2358
04:45:58,660 --> 04:46:04,900
現在のボーダー半径に応じてレンダリングするアイコンを入れ替えたい。

2359
04:46:04,900 --> 04:46:10,100
アイコンを作成しますが、大文字のiを使用します。

2360
04:46:10,100 --> 04:46:21,220
そしてレンダリングし、ボーダーのスタイルが正方形かどうかをチェックします。

2361
04:46:21,220 --> 04:46:29,540
そうでなければ、ボーダー・スタイルが円であるかどうかをチェックする。

2362
04:46:29,540 --> 04:46:37,940
そうでなければ、円のアイコンを格納する。

2363
04:46:37,940 --> 04:46:46,180
そしてこのアイコンを動的にレンダリングする。

2364
04:46:46,180 --> 04:46:50,820
このロジックをセットアップする最もスマートな方法かどうかは正直わからない。

2365
04:46:50,820 --> 04:46:56,020
このボーダースタイルを履歴書プレビューに適用してみましょう。

2366
04:46:56,020 --> 04:47:03,460
履歴書プレビューコンポーネントに戻って、個人情報ヘッダーまで行ってみましょう。

2367
04:47:03,460 --> 04:47:10,900
この画像にボーダースタイルを適用します。

2368
04:47:10,900 --> 04:47:19,940
この画像に適用したいので、ここにスタイルプロパティを追加します。

2369
04:47:19,940 --> 04:47:26,260
現在選択されているボーダースタイルをチェックします。

2370
04:47:26,260 --> 04:47:31,940
定数を使用することができます。

2371
04:47:31,940 --> 04:47:38,660
ボーダースタイルが正方形であるかどうかをチェックする。

2372
04:47:38,660 --> 04:47:48,820
そうでなければ、ボーダー・スタイルがボーダー・スタイル・ドットの場合は、ボーダー半径をゼロ・ピクセルに設定する。

2373
04:47:48,820 --> 04:47:58,020
円形の場合、これを完全な円にしたい。

2374
04:47:58,020 --> 04:48:03,140
そうでない場合は、スクエアを作りたい。

2375
04:48:03,140 --> 04:48:07,540
試しに画像を追加してみましょう。

2376
04:48:07,540 --> 04:48:16,260
を追加してみましょう。デフォルトでは、境界線の半径が10パーセントの四角形ですが、次のように切り替えることができます。

2377
04:48:16,260 --> 04:48:21,700
アイコンとボタンが変わるだけでなく

2378
04:48:21,700 --> 04:48:26,260
アイコンとボタンが変わるだけでなく、背景のボーダー半径も変化する。

2379
04:48:26,260 --> 04:48:33,300
この下にあるスキルも同じようにしたいので、スキルバッジを検索してみましょう。

2380
04:48:33,300 --> 04:48:41,140
ここでもボーダースタイルを再構築する必要があります。

2381
04:48:42,900 --> 04:48:49,380
このスタイルブロック全体をコピーしましょう。

2382
04:48:49,380 --> 04:48:56,900
もう一度書く必要がないように、このスタイルブロック全体をコピーしましょう。

2383
04:48:56,900 --> 04:49:02,180
この背景色を切り取ってここに置き、この重複を削除します。

2384
04:49:02,180 --> 04:49:09,940
しかし、ここでは10ピクセルを使いたくない。

2385
04:49:09,940 --> 04:49:19,220
を8ピクセルに設定します。そうすることで、長方形の丸い円形になります。

2386
04:49:19,220 --> 04:49:27,060
で、常に同期している。

2387
04:49:27,060 --> 04:49:32,900
この機能はプレミアム購読の裏側に隠しますが、今は誰でも使うことができます。

2388
04:49:32,900 --> 04:49:38,580
この写真のインポートの隣にあるボタンで、この画像を削除することができます。

2389
04:49:38,580 --> 04:49:45,780
もう一度、個人情報フォームコンポーネントに入りましょう。

2390
04:49:45,780 --> 04:49:56,180
returnステートメントの上に、ファイル入力写真入力のrefが必要なので、それを

2391
04:49:56,180 --> 04:50:06,420
初期値はnullです。

2392
04:50:07,140 --> 04:50:15,300
をファイル入力にアタッチします。

2393
04:50:15,300 --> 04:50:22,340
これにより、例えば直接クリックしなくても入力フィールドの値を変更できるようになります。

2394
04:50:22,340 --> 04:50:31,060
次にこのフォームコントロールをフレックスでスタイルされたdiffにラップします。

2395
04:50:31,700 --> 04:50:39,540
item center and gap tourでスタイルを設定します。

2396
04:50:39,540 --> 04:50:44,580
フォームコントロールの下に配置します。

2397
04:50:44,580 --> 04:50:54,420
セカンダリのバリアントでタイプをボタンに設定します。

2398
04:50:56,500 --> 04:51:01,860
arrow関数を渡すon clickハンドラを追加します。

2399
04:51:01,860 --> 04:51:12,100
この関数を処理する前に、ボタンタグを閉じましょう。

2400
04:51:12,100 --> 04:51:20,740
タグが生成されなかったので、ここではremoveというテキストだけにしています。

2401
04:51:20,740 --> 04:51:27,380
これをクリックしたら、ファイル入力の値をundefinedではなくnullに設定したい。

2402
04:51:27,380 --> 04:51:34,180
というのは、undefinedは画像が選択されていないことを意味しますが、nullは実際には画像の削除を意味するからです。

2403
04:51:34,180 --> 04:51:39,460
後でバックエンドでこの2つのケースを区別して、nullを渡すときに

2404
04:51:39,460 --> 04:51:45,620
写真の場合、ファイルストレージから写真を削除する必要があります。

2405
04:51:45,620 --> 04:51:52,820
このクリックハンドラの内部で、フィールド値を呼び出します。

2406
04:51:52,820 --> 04:52:05,860
このレンダー関数から渡されるものなので、変更時にフィールド値ドットを呼び出します。

2407
04:52:05,860 --> 04:52:13,540
nullを渡し、さらにこの入力フィールドから値を削除します。

2408
04:52:15,300 --> 04:52:22,020
この写真入力refはnullである可能性があります。そのため、写真入力refがdot
currentであるかどうかをチェックする必要があります。

2409
04:52:22,020 --> 04:52:32,980
これが定義されている場合は、photo input ref current
dotの値を取り、次のように空文字列に設定します。

2410
04:52:32,980 --> 04:52:40,020
を空文字列に設定します。こうすることで、この入力から値が取り除かれます。

2411
04:52:41,300 --> 04:52:49,140
例えば、ここで画像を選択して、removeをクリックすると、その画像が削除される。

2412
04:52:49,140 --> 04:52:55,460
をクリックすると、その画像が削除されます。

2413
04:52:55,460 --> 04:53:01,540
容量の無駄になってしまうので、常に削除しています。

2414
04:53:01,540 --> 04:53:08,100
エディターの応答性を改善したい。

2415
04:53:08,100 --> 04:53:13,700
レジュメのプレビューを見ることができない。

2416
04:53:13,700 --> 04:53:20,020
小さな画面で履歴書プレビューの表示・非表示を切り替えられるようにするためです。

2417
04:53:20,020 --> 04:53:33,140
コンポーネントに2つの新しいプロップを追加する必要があります。

2418
04:53:33,140 --> 04:53:45,060
というコールバックを設定します。

2419
04:53:45,060 --> 04:53:50,660
はブール値を渡す。

2420
04:53:50,660 --> 04:54:00,020
そして、この値をトグルできるボタンを真ん中に置きたい。

2421
04:54:00,020 --> 04:54:07,860
前のステップと次のステップのボタンがあります。

2422
04:54:07,860 --> 04:54:18,660
このボタンの中にアイコンを描画します。

2423
04:54:18,660 --> 04:54:27,300
もしこの値がtrueであれば、パンラインアイコンをレンダリングします。

2424
04:54:27,300 --> 04:54:38,260
アイコンを表示します。

2425
04:54:38,260 --> 04:54:45,860
アイコンはlucid.dev/iconsで検索することができる。

2426
04:54:45,860 --> 04:54:51,700
一番気に入ったものを選んだら、この2つになった。

2427
04:54:52,660 --> 04:55:00,180
このボタンの小道具をいくつか変更したい。

2428
04:55:00,180 --> 04:55:07,460
このボタンをクリックすると、プレビューの表示／非表示を切り替えたい。

2429
04:55:07,460 --> 04:55:15,700
stateセッター関数で、現在の値の反対を設定したい。

2430
04:55:17,700 --> 04:55:24,260
このボタンはmdブレイクポイント以上では非表示にし、小さいスクリーンにだけ表示したい。

2431
04:55:24,260 --> 04:55:30,100
このボタンは小さい画面でのみ表示したい。

2432
04:55:30,100 --> 04:55:38,260
また、このボタンにカーソルを合わせたときにヒントが表示されるように、タイトルを追加しましょう。

2433
04:55:38,260 --> 04:55:44,340
タイトルのプロパティをここに追加します。

2434
04:55:44,340 --> 04:55:53,540
もしこれがtrueなら、入力フォームを表示する、もしこれがfalseなら

2435
04:55:53,540 --> 04:56:02,020
履歴書のプレビューを表示と表示されているはずなので、ここにカーソルを合わせると、履歴書のプレビューを表示と表示されます。

2436
04:56:02,020 --> 04:56:10,340
次に、履歴書プレビューセクションの表示・非表示を設定します。

2437
04:56:10,340 --> 04:56:15,940
このボタンの状態に応じて、オプションのクラス名をここに渡すことで実現できます。

2438
04:56:15,940 --> 04:56:22,420
このクラス名をオプションでないものにすることもできますが、クラス名をオプションにするのが慣例です。

2439
04:56:22,420 --> 04:56:30,420
オプションにするのが通例である。

2440
04:56:30,420 --> 04:56:37,460
クラス名の文字列全体を中かっこで囲み、括弧で囲んで、cn

2441
04:56:37,460 --> 04:56:45,140
関数の第2引数にクラス名を渡します。

2442
04:56:45,140 --> 04:56:51,860
しかし、この最初の文字列にはwidth fullも追加する。

2443
04:56:51,860 --> 04:56:58,340
というのも、小さな画面では幅いっぱいに表示され、mdブレークポイント以上では幅の半分に設定されるからです。

2444
04:56:58,340 --> 04:57:07,540
この文字列を変更し、レジュメエディターでレジュメの下にある

2445
04:57:07,540 --> 04:57:18,420
履歴書データの上部にある履歴書エディターで、履歴書プレビューを表示します。

2446
04:57:18,420 --> 04:57:26,740
この状態をfalseで初期化します。

2447
04:57:26,740 --> 04:57:33,460
パンくずをラップする差分を検索します。

2448
04:57:33,460 --> 04:57:42,340
を中括弧で囲み、cn関数に追加します。

2449
04:57:42,340 --> 04:57:54,100
もしshow sm resume previewがtrueなら、この左半分を非表示にしたい。

2450
04:57:54,100 --> 04:58:00,820
mdブレークポイントと、より大きなブレークポイントの両方を常に表示したいので、このクラス名の文字列の中に入り、mdブロックも追加します。

2451
04:58:00,820 --> 04:58:10,020
さらにmdブロックを追加して、この値がmdブレークポイントとbiggerのどちらにあっても、常にこの要素を表示するようにします。

2452
04:58:10,020 --> 04:58:18,100
この要素を常に表示し、また、レジュメ・プレビュー・セクションを表示します。

2453
04:58:18,100 --> 04:58:27,380
セクションにクラス名の文字列を渡しています。

2454
04:58:27,380 --> 04:58:35,300
プレビューがtrueの場合、この要素を表示します。

2455
04:58:35,300 --> 04:58:43,780
しかし、大きな画面ではフォームの半分と同じように常に表示します。

2456
04:58:43,780 --> 04:58:50,500
新しい小道具を写真に渡して、この状態をsmレジュームプレビューを表示する状態に切り替えます。

2457
04:58:50,500 --> 04:59:03,140
を設定し、show sm resume previewを設定します。

2458
04:59:03,140 --> 04:59:09,780
フォームと履歴書プレビューの切り替えができるようになりました。

2459
04:59:09,780 --> 04:59:15,780
しかし、これはまだ機能していて、色や境界線の半径を変更することができます。

2460
04:59:15,780 --> 04:59:23,940
フォームに戻ることもできますし、ウィンドウを再び大きくすることもできます。

2461
04:59:23,940 --> 04:59:29,780
携帯電話やタブレットでもウェブサイトを使うことができます。

2462
04:59:29,780 --> 04:59:37,780
フィールド配列のドラッグ・アンド・ドロップ機能を実装したい。

2463
04:59:37,780 --> 04:59:44,740
リアクトのための最高のドラッグ・アンド・ドロップ・ライブラリだと思う。

2464
04:59:44,740 --> 04:59:50,740
framer reorderも試してみた。

2465
04:59:50,740 --> 04:59:56,500
画面の境界を超えると自動的に上下にスクロールする。

2466
04:59:56,500 --> 05:00:04,740
これはdndキットの大きな問題だ。

2467
05:00:04,740 --> 05:00:09,940
コードを書かなければなりませんが、ステップ・バイ・ステップでどう動くかお見せしましょう。

2468
05:00:09,940 --> 05:00:15,860
もちろん全てはドキュメントに書かれていますし、必要なパッケージはすでにインストール済みです。

2469
05:00:15,860 --> 05:00:23,620
それでは実装してみましょう。

2470
05:00:23,620 --> 05:00:33,060
まず、フィールド配列を使用するところまでスクロールします。

2471
05:00:33,060 --> 05:00:39,460
フォームの項目を別の場所に移動できるようにするためです。

2472
05:00:39,460 --> 05:00:48,900
useフィールド配列の下にconsensorsを作り、use sensorsと呼びます。

2473
05:00:48,900 --> 05:00:57,780
しかし、手動でインポートしなければならないようなので、中かっこをdnd kit
coreからインポートしてください。

2474
05:00:58,900 --> 05:01:05,940
この中でuse sensorsを見つけ、これを複数インポートし、下にスクロールします。

2475
05:01:05,940 --> 05:01:11,060
この括弧を

2476
05:01:11,060 --> 05:01:20,820
にuse sensor singularを渡して、これもdnd kitからインポートする。

2477
05:01:20,820 --> 05:01:29,940
コアパッケージからインポートし、これにpointer sensorを渡す。

2478
05:01:29,940 --> 05:01:39,780
そして2つ目のuse sensorで、今度はkeyboard sensorを渡します。

2479
05:01:39,780 --> 05:01:50,100
カンマで囲み、この座標ゲッター・フィールドをソート可能に設定する。

2480
05:01:50,100 --> 05:02:02,660
を手動でインポートする必要がある。

2481
05:02:02,660 --> 05:02:11,220
ソート可能なキーボードの座標を見つける必要があります。

2482
05:02:11,220 --> 05:02:19,380
これはマウス・ポインターのポインター・イベントに反応する役割を担っている。

2483
05:02:19,380 --> 05:02:25,220
携帯電話では指の動きに反応する。

2484
05:02:25,220 --> 05:02:30,820
キーボードを越えてドラッグ＆ドロップしたい場合だと思う。

2485
05:02:30,820 --> 05:02:37,220
マウスを持っていない人がアクセシビリティのために必要なのでしょうが、普通はマウスを使います。

2486
05:02:37,220 --> 05:02:44,660
もちろんマウスを使いますが、その場合、下にhandle dragという関数が必要になります。

2487
05:02:44,660 --> 05:02:51,380
この関数はアイテムをドラッグした後に離すときに実行されます。

2488
05:02:51,380 --> 05:02:59,300
これはdnd kit coreからのインポートです。

2489
05:02:59,300 --> 05:03:09,220
ドラッグしているアイテムがアクティブで、その下にあるアイテムがアクティブです。

2490
05:03:09,220 --> 05:03:15,460
このアクティブなアイテムをオーバーアイテムの位置に移動させます。

2491
05:03:15,460 --> 05:03:22,420
overが定義されているかどうかをチェックします。

2492
05:03:22,420 --> 05:03:29,540
というのも、overが定義されているかどうかをチェックするからです。

2493
05:03:29,540 --> 05:03:40,660
が定義されている場合のみ、active ideaがover
ideaと等しくないかどうかを比較したい。

2494
05:03:40,660 --> 05:03:46,740
もし同じなら、同じ位置に落としただけなので、何かを移動させなければならない。

2495
05:03:46,740 --> 05:03:54,500
アクティブなアイテムとオーバーしたアイテムのインデックスを見つける必要がある。

2496
05:03:55,620 --> 05:04:01,460
というのも、これは並び替えるリストだからだ。

2497
05:04:01,460 --> 05:04:11,460
後でこのリストをdndキットに渡すので、fields dot find
indexを呼び出して、各フィールドを通過させる。

2498
05:04:11,460 --> 05:04:20,020
フィールド・ドット・アイデアとアクティブ・ドット・アイデアを比較する必要がある。

2499
05:04:20,020 --> 05:04:32,740
アクティブなアイテムを見つけたら、また新しいインデックスを作る。

2500
05:04:32,740 --> 05:04:40,900
フィールドのアイデアとオーバーアイテムのidを比較する。

2501
05:04:43,460 --> 05:04:50,180
そのために、フィールド配列を使ってこの移動関数を呼び出します。

2502
05:04:50,180 --> 05:04:57,460
次に新しいインデックスを渡す。

2503
05:04:57,460 --> 05:05:05,140
これはdnd kitのsortableからインポートしたもので、以下のフィールドを渡します。

2504
05:05:06,660 --> 05:05:13,860
古いインデックスと新しいインデックスを渡します。

2505
05:05:13,860 --> 05:05:19,700
に並び替えを伝える役割を担っています。

2506
05:05:19,700 --> 05:05:25,460
この行はdnd kitに変更を伝える役割を担っている。

2507
05:05:25,460 --> 05:05:35,700
それから下にスクロールして、formタグの下に行き、ここにdnd contextを置きます。

2508
05:05:35,700 --> 05:05:44,660
これもdnd kit coreからインポートしたもので、これを閉じて、fields dot
mapの下に置きます。

2509
05:05:44,660 --> 05:05:52,180
dndコンテキストに、すでに用意した小道具やセンサーを渡します。

2510
05:05:52,180 --> 05:05:59,620
次に衝突判定を渡す。

2511
05:06:02,260 --> 05:06:07,380
次に、ドラッグしてコールバックすると、設定したハンドルのドラッグと関数が呼び出されます。

2512
05:06:07,380 --> 05:06:16,580
そしてモディファイアに配列を渡し、ここでは縦軸に制限を渡している。

2513
05:06:16,580 --> 05:06:29,060
もうひとつのインポートは、add dnd kit modifiersからのインポート。

2514
05:06:29,060 --> 05:06:34,020
これは、この要素を上下にしか動かせないようにするものです。

2515
05:06:34,020 --> 05:06:43,220
水平方向と下方向には動かせない。

2516
05:06:43,220 --> 05:06:52,900
そして、dndコンテキストの下に、ソート可能なコンテキストを置く。

2517
05:06:52,900 --> 05:06:59,700
フィールド・ドット・マップをその中に入れ、ここでもいくつかの値を渡す必要がある。

2518
05:06:59,700 --> 05:07:04,340
を渡す必要があります。

2519
05:07:04,340 --> 05:07:13,220
そして垂直リストソートのストラテジーです。

2520
05:07:13,220 --> 05:07:20,180
dnd kitのドキュメントに記載されている。

2521
05:07:20,180 --> 05:07:25,940
そして、作業経験項目コンポーネントに移動します。

2522
05:07:25,940 --> 05:07:33,700
まず最初に、constを再構築して、use sortableと呼びます。

2523
05:07:33,700 --> 05:07:43,540
このアイテムのidを文字列としてコンポーネントに渡す必要があります。

2524
05:07:43,540 --> 05:07:54,660
としてコンポーネントに渡す必要があります。

2525
05:07:54,660 --> 05:08:03,140
フィールドのidなので、ここでの比較もうまくいく。

2526
05:08:03,140 --> 05:08:10,980
dndキットに使うidとフィールドのidは同じだからだ。

2527
05:08:11,860 --> 05:08:21,220
ここで、たくさんの値属性のリスナー・セット・ノード・リファレンスを再構築する必要がある。

2528
05:08:21,220 --> 05:08:33,540
変形トランジションで、ドラゴンはこれらすべてをデストラクチャーする。

2529
05:08:33,540 --> 05:08:40,820
グリップの水平アイコンをクリックし、このアイテムをドラッグ・アンド・ドロップできるようにする。

2530
05:08:40,820 --> 05:08:45,300
このアイテムをクリックするとドラッグ＆ドロップできるようにしたい。

2531
05:08:45,300 --> 05:08:54,740
そのために、このようなアトリビュートを分散させ、リスナーも分散させました。

2532
05:08:54,740 --> 05:09:01,860
これはいわばドラッグ＆ドロップをこのハンドルにアタッチするものです。

2533
05:09:01,860 --> 05:09:07,220
このハンドルだけを動かしたいわけではなく、div全体を動かしたいのです。

2534
05:09:07,220 --> 05:09:13,780
を移動させたいので、この外側の差分にある

2535
05:09:13,780 --> 05:09:23,220
このset node ref関数を追加しなければならない。

2536
05:09:23,220 --> 05:09:29,460
つ目のアイテムを追加すると、これはすでに機能している。

2537
05:09:29,460 --> 05:09:34,740
マウスを離すと、一番上に2番と表示されます。

2538
05:09:34,740 --> 05:09:40,900
は機能しますが、このアイテムをドラッグしていることがわかりません。

2539
05:09:40,900 --> 05:09:48,500
styleプロップにtransformを渡して、このアイテムを画面上で移動させます。

2540
05:09:48,500 --> 05:09:56,900
そして、ここではcssを大文字で渡しています。これもdnd
kitからのインポートですが、やはり自動インポーターはありません。

2541
05:09:56,900 --> 05:10:10,340
それでは手動でインポートしてみましょう。

2542
05:10:10,340 --> 05:10:19,460
ユーティリティを手で入力してみよう。

2543
05:10:23,140 --> 05:10:31,300
ここでcss dot transformを大文字のtで文字列に変換する。

2544
05:10:31,300 --> 05:10:38,100
を変換する値であり、カンマの後にスタイルを指定する2番目の値として transition

2545
05:10:38,100 --> 05:10:45,620
を渡します。この値は、このアイテムを引き寄せるときのアニメーションを処理します。

2546
05:10:45,620 --> 05:10:52,340
保存すると、このアイテムを上下に動かすことができます。

2547
05:10:52,340 --> 05:11:00,900
このアイテムを視覚的に移動させるのに必要なcssコードを適用します。

2548
05:11:00,900 --> 05:11:06,740
このブーリアンは、このアイテムをドラッグしていることを示します。

2549
05:11:06,740 --> 05:11:12,500
は現在ドラッグが有効であることを示すので、この外側の差分にクラス名を追加したい。

2550
05:11:12,500 --> 05:11:17,060
これを中括弧で囲んでcn関数に入れよう。

2551
05:11:18,260 --> 05:11:24,260
そして第2引数に式を追加し、ドラッグがtrueかどうかをチェックする。

2552
05:11:24,260 --> 05:11:32,020
これがtrueの場合のみ、シャドウxlを設定し、これをzインデックスで昇格させる。

2553
05:11:32,020 --> 05:11:39,540
zインデックスを50にして、常に他の要素より上になるようにします。

2554
05:11:39,540 --> 05:11:45,860
影はあるのですが、まだ他のアイテムの下にあります。

2555
05:11:46,900 --> 05:11:52,820
影ができ、このアイテムは常に他のアイテムの上に表示されます。

2556
05:11:52,820 --> 05:11:58,260
マウスをドラッグハンドルの上に置くと、このようなGに切り替わります。

2557
05:11:58,260 --> 05:12:04,420
カーソルに切り替わりますが、水平方向に動かすと通常のカーソルに戻ってしまいます。

2558
05:12:04,420 --> 05:12:09,860
通常のカーソルに戻ってしまうのだ。

2559
05:12:10,500 --> 05:12:17,140
ドラッグがtrueのとき、このグラブカーソルのクラスを外側のdiffに追加したい。

2560
05:12:17,140 --> 05:12:23,220
マウスを押したままでも同じカーソルが表示されます。

2561
05:12:23,220 --> 05:12:29,380
しかし、zインデックスを機能させるためには、相対クラスを追加する必要があると思います。

2562
05:12:29,380 --> 05:12:36,900
を追加する必要があると思います。

2563
05:12:37,540 --> 05:12:43,540
そして、ドラッグしているアイテムが常に他の要素の上に来るようにします。

2564
05:12:43,540 --> 05:12:48,580
ドラッグハンドルのアウトラインを削除することができます。

2565
05:12:48,580 --> 05:12:54,820
グリップの水平アイコンに別のクラス名を追加します。

2566
05:12:54,820 --> 05:13:02,740
フォーカス・モディファイアを使い、コロンにフォーカスを当て、アウトラインを「なし」に設定します。

2567
05:13:04,020 --> 05:13:10,100
これでアウトラインはなくなりました。

2568
05:13:10,100 --> 05:13:15,380
リアクトフックフォームとdndキットでドラッグ＆ドロップ機能を実装しました。

2569
05:13:15,380 --> 05:13:23,220
画面を分割して、職歴フォームを右側に置きましょう。

2570
05:13:23,220 --> 05:13:30,180
dnd kitのimport文をコピーすることから始めましょう。

2571
05:13:31,380 --> 05:13:32,420
こちらも同じように

2572
05:13:32,420 --> 05:13:36,500
ここに貼り付ける

2573
05:13:36,500 --> 05:13:48,820
次に、use zensourceが必要です。これをuseフィールド配列の下に貼り付けてください。

2574
05:13:48,820 --> 05:13:54,740
そして、useフィールド配列からmove関数を再構築する必要がある。

2575
05:13:57,460 --> 05:14:01,540
ハンドルのドラッグエンドも同じです。

2576
05:14:01,540 --> 05:14:08,100
次に、dndコンテキストが必要だ。

2577
05:14:08,100 --> 05:14:16,980
とソート可能なコンテキストが必要なので、これらもコピーしてここに置く。

2578
05:14:16,980 --> 05:14:24,660
fields.mapの下にコピーして、教育項目までスクロールする。

2579
05:14:25,860 --> 05:14:31,700
を必要とする。

2580
05:14:31,700 --> 05:14:41,620
をコンポーネントに渡す。

2581
05:14:41,620 --> 05:14:46,180
をコピーします。

2582
05:14:50,100 --> 05:14:56,500
まずこのdivをcnにラップします。

2583
05:14:56,500 --> 05:15:09,540
ここに同じ条件を渡してドラッグします。

2584
05:15:12,100 --> 05:15:21,060
をここに割り当て、同じ値でstyle propを設定します。

2585
05:15:21,060 --> 05:15:34,580
水平のアイコンとフォーカスの輪郭なしを同じアイコンのクラス名に割り当てます。

2586
05:15:34,580 --> 05:15:40,660
いいえ、これで全部です。このファイルをすべて保存して閉じ、ここでも試してみましょう。

2587
05:15:41,780 --> 05:15:52,340
教育1 教育2 そしてブーム ドラッグ・アンド・ドロップ とてもクール
さて、ドラッグ・アンド・ドロップがどのように機能するか、おわかりいただけただろうか？

2588
05:15:52,340 --> 05:15:57,060
ドラッグ・アンド・ドロップがどのように機能するかがわかったので、あとはこれを他のプロジェクトにコピー・ペーストするだけです。

2589
05:15:57,060 --> 05:16:03,060
次に自動保存フックを実装したい。

2590
05:16:03,060 --> 05:16:09,460
自動保存フックを実装したい。

2591
05:16:09,460 --> 05:16:14,900
キャラクターを変更するたびに保存をトリガーしたくない。

2592
05:16:14,900 --> 05:16:20,340
というのも、毎回バックエンドにリクエストしてしまうからだ。

2593
05:16:20,340 --> 05:16:27,140
これはデバウンスと呼ばれている。

2594
05:16:27,140 --> 05:16:32,740
これを処理するために新しいフックを作り、hooksフォルダに入れる。

2595
05:16:32,740 --> 05:16:43,380
debounce.tsと呼び、同じ名前の関数をエクスポートします。

2596
05:16:43,380 --> 05:16:51,940
このフックが機能するのは、ここに値を入れ、同じ値を返すからである。

2597
05:16:51,940 --> 05:16:58,740
このフックを再利用可能に保つために、ここにどんな値でも渡せるように汎用的なものにした。

2598
05:16:58,740 --> 05:17:04,740
そこで、use debounceと括弧の間に角括弧を作り、ここに

2599
05:17:04,740 --> 05:17:11,620
そしてこのフックの第一引数としてtier型の値を渡す。

2600
05:17:11,620 --> 05:17:18,900
コンマ）、そしてディレイのタイプはnumberで、デフォルトの値は250ミリ秒です。

2601
05:17:18,900 --> 05:17:26,500
しかし、このデフォルト値を変更することもできる。

2602
05:17:26,500 --> 05:17:33,060
デバウンスを使用する値として任意のタイプを渡すことができます。

2603
05:17:33,060 --> 05:17:39,620
もしここに文字列を入れれば、このフックの中に文字列が戻ってきます。

2604
05:17:39,620 --> 05:17:50,660
constデバウンス値とzデバウンス値を作成する。

2605
05:17:51,700 --> 05:17:57,460
このフックは実はとてもシンプルで、この値を変更するたびに

2606
05:17:57,460 --> 05:18:03,540
この値を変更するたびに、同じ値を返したい。

2607
05:18:03,540 --> 05:18:12,420
このユースエフェクトの依存関係は、値と遅延である。

2608
05:18:12,420 --> 05:18:19,220
そして、ここではタイムアウトを使います。

2609
05:18:20,020 --> 05:18:26,020
これはjavascriptの関数で、これにarrow関数を渡します。

2610
05:18:26,020 --> 05:18:32,580
この関数のボディでz debounced valueを呼び出し、最新の値を渡します。

2611
05:18:32,580 --> 05:18:41,940
z timeoutの2番目の引数はdelayで、デフォルトでは250です。

2612
05:18:41,940 --> 05:18:49,300
ミリ秒の間、入力値にデバウンス値を設定し、値が変化するたびに実行する。

2613
05:18:49,300 --> 05:18:56,900
しかし、このタイムアウトをクリーンアップしなければならない。

2614
05:18:56,900 --> 05:19:03,620
このタイムアウトをクリーンアップする必要があります。

2615
05:19:03,620 --> 05:19:12,020
使用効果のクリーンアップ関数では、clear timeoutを呼び出す関数を返します。

2616
05:19:12,020 --> 05:19:18,020
ハンドラーを渡すと、このタイムアウトがキャンセルされる。

2617
05:19:18,020 --> 05:19:26,980
このタイムアウトをキャンセルするのは、値が変更された場合だけです。

2618
05:19:26,980 --> 05:19:33,540
値を変更しなくなった場合、これはキャンセルされず、最終的にデバウンスされた値が入力値に設定されます。

2619
05:19:33,540 --> 05:19:40,340
そして最後に、デバウンスされた値を返す。

2620
05:19:40,340 --> 05:19:49,620
コンポーネントで使用できるようにするためです。

2621
05:19:49,620 --> 05:19:55,380
変更が保存される前にページをリフレッシュしようとしたときに、まだ未保存の変更があるという警告が必要です。

2622
05:19:55,380 --> 05:20:00,900
という警告が必要です。

2623
05:20:00,900 --> 05:20:06,500
保存がトリガーされる前にf5キーを押して、このようなメッセージを表示します。

2624
05:20:06,500 --> 05:20:11,460
他のウェブサイトでも見たことがあるかもしれませんが、これは未保存の変更があることを示すメッセージです。

2625
05:20:11,460 --> 05:20:16,900
変更が保存されるまでページを更新しないようにするためです。

2626
05:20:16,900 --> 05:20:23,060
ここで設定した遅延時間である1.5秒待つと、変更が保存され、ページを更新できる。

2627
05:20:23,060 --> 05:20:33,540
そのために、hooksフォルダにuse unload
warning.tsという別のフックを作成します。

2628
05:20:33,540 --> 05:20:38,260
この関数をここにエクスポートします

2629
05:20:38,260 --> 05:20:44,260
この関数に

2630
05:20:46,180 --> 05:20:53,700
何も渡さなければ、デフォルトでtrueに設定されます。

2631
05:20:53,700 --> 05:20:58,740
falseを渡すとこのメッセージは表示されません。

2632
05:20:58,740 --> 05:21:02,180
ここにuseエフェクトを入れます。

2633
05:21:02,180 --> 05:21:11,140
このuseエフェクトの中で、まず条件がfalseかどうかをチェックします。

2634
05:21:11,140 --> 05:21:18,740
もし条件がtrueなら、リスナーを作成します。

2635
05:21:18,740 --> 05:21:28,340
を関数として作成する。

2636
05:21:28,340 --> 05:21:34,980
これは矢印の関数で、e.prevent defaultを呼び出します。

2637
05:21:36,900 --> 05:21:42,500
これはページを閉じるのを防ぎ、代わりにこの警告を表示します。

2638
05:21:42,500 --> 05:21:50,500
window.addEventListenerでこのリスナーをアクティブにします。

2639
05:21:50,500 --> 05:21:56,420
これは、ページを更新または閉じようとしたときに呼び出されるもので、リスナー

2640
05:21:56,420 --> 05:22:03,300
が2番目の引数で、このフックが再び実行されるときには、前のリスナーを削除しなければなりません。

2641
05:22:03,300 --> 05:22:10,580
を再び呼び出す関数を返します。

2642
05:22:10,580 --> 05:22:16,820
を呼び出す関数を返します。

2643
05:22:16,820 --> 05:22:23,540
constに格納するのは、この関数を両方の関数に渡せるようにするためだ。

2644
05:22:23,540 --> 05:22:28,420
reactでは、これをuseエフェクトの中で行う必要があります。

2645
05:22:28,420 --> 05:22:35,140
リスナーを追加するようなエフェクトが必要だが、エフェクトは複数回実行できるので、常に前のリスナーをクリーンアップする必要がある。

2646
05:22:35,140 --> 05:22:41,700
をクリーンアップする必要があります。

2647
05:22:41,700 --> 05:22:49,860
第2引数として依存関係の配列を渡す必要があります。

2648
05:22:49,860 --> 05:22:57,220
何も返す必要はありません。これを保存して、レジュームエディターで試してみましょう。

2649
05:22:58,900 --> 05:23:06,980
アンロード警告を使い、条件をtrueのままにしておきます。

2650
05:23:06,980 --> 05:23:14,180
これでページを更新するたびにこの警告が表示されます。

2651
05:23:14,180 --> 05:23:21,380
もちろん、この警告を表示したいのは未保存の変更があるときだけです。

2652
05:23:21,380 --> 05:23:27,140
このフックはレジュームエディタでのみ使用されるので、自動保存をトリガーするフックを作成します。

2653
05:23:27,140 --> 05:23:34,980
という名前のフックを作成します。

2654
05:23:34,980 --> 05:23:51,860
このフックに、保存したいレジュメデータを渡します。

2655
05:23:52,900 --> 05:23:59,300
しかし、この入力をデバウンスしたいので、const debounced resume
dataを作成します。

2656
05:23:59,300 --> 05:24:06,500
を作成し、debounceを使用するように割り当てます。

2657
05:24:06,500 --> 05:24:12,980
秒に設定したい。

2658
05:24:12,980 --> 05:24:18,420
オートセーブを発動させたいのは、実際に何かを変更した場合だけだ。

2659
05:24:18,420 --> 05:24:23,060
このため、ここに別の状態を追加した。

2660
05:24:23,060 --> 05:24:30,020
セッターは最後に保存したデータをセットする。

2661
05:24:30,020 --> 05:24:38,660
で初期化し、ここで構造化クローンを呼び出します。

2662
05:24:38,660 --> 05:24:44,100
これはどのパッケージからもインポートされたものではなく、ブラウザ上で利用可能なものです。

2663
05:24:44,100 --> 05:24:51,060
この関数にレジュメデータを渡します。

2664
05:24:51,060 --> 05:24:57,860
これにより、レジュメデータを変更しても、最後に保存したデータは変更されません。

2665
05:24:57,860 --> 05:25:02,900
レジュメデータのクローンを作成することで、レジュメデータを変更した際に、最後に保存したデータも変更されないようにすることができます。

2666
05:25:02,900 --> 05:25:09,060
レジュメデータのクローンを作成する必要があります。

2667
05:25:09,060 --> 05:25:16,580
この関数は、レジュームデータのクローンを最後に保存したデータの中に作成します。

2668
05:25:16,580 --> 05:25:22,740
新しいレジュメデータが最後に保存されたデータと異なる場合、保存のトリガーとなります。

2669
05:25:22,740 --> 05:25:30,580
さらに、state is savingとset is
savingを作成し、保存テキストを表示できるようにします。

2670
05:25:30,580 --> 05:25:38,500
また、並列に複数回保存しないように、これをfalseで初期化します。

2671
05:25:39,860 --> 05:25:47,300
次に、実際の保存をトリガーするuse effectを下に置きます。

2672
05:25:47,300 --> 05:25:54,900
このユースエフェクトは、デバウンスされたレジュームデータが変更されるたびにトリガーされる必要があります。

2673
05:25:54,900 --> 05:26:01,700
依存配列をこのフックに追加し、saveという非同期関数を追加します。

2674
05:26:04,260 --> 05:26:12,260
この関数の最初に引数は必要ありません。

2675
05:26:12,260 --> 05:26:19,780
そして、実際の保存のトリガーとなる、バックエンドへの呼び出しを行う。

2676
05:26:19,780 --> 05:26:26,740
エンドポイントを設定するのは後回しにして、ここでは保存しているふりをしたい。

2677
05:26:26,740 --> 05:26:34,420
新しいプロミスを待つことで、人工的な遅延を作ることができます。

2678
05:26:34,420 --> 05:26:43,060
resolveを呼び出し、1500ミリ秒の遅延を設定する。

2679
05:26:43,060 --> 05:26:48,660
秒待つことになる。

2680
05:26:48,660 --> 05:26:56,980
保存が成功したら、最後に保存したデータを構造化クローンで更新しなければならない。

2681
05:26:56,980 --> 05:27:04,820
そのクローンにはデバウンスされたレジュームデータが含まれている。

2682
05:27:04,820 --> 05:27:12,740
最後に保存をfalseに戻します。

2683
05:27:14,100 --> 05:27:19,620
このフックがわかりにくいと思われるかもしれないが、心配はいらない。

2684
05:27:19,620 --> 05:27:25,780
すべての問題やレースコンディションを解決するまで、何度も実験を繰り返した。

2685
05:27:25,780 --> 05:27:32,580
数日間実験した結果、こうなった。

2686
05:27:32,580 --> 05:27:39,060
関数の下にあるuseエフェクトの中にある。

2687
05:27:39,060 --> 05:27:50,260
未保存の変更があるときだけ、このsave関数を呼び出したい。

2688
05:27:50,260 --> 05:27:57,140
デバウンスされたレジュームデータが最後に保存したデータと異なっていれば、未保存の変更があることがわかります。

2689
05:27:57,140 --> 05:28:03,060
フィールドや配列を含めて比較する最も簡単な方法は、それらを文字列にすることです。

2690
05:28:03,060 --> 05:28:08,180
この方法であれば、多くのロジックを記述することなく、すべての内容を比較することができるからです。

2691
05:28:09,140 --> 05:28:15,460
と等しくないことをチェックします。

2692
05:28:15,460 --> 05:28:24,100
文字列化された最後に保存されたデータと等しくないことをチェックします。

2693
05:28:24,100 --> 05:28:33,700
保存関数を実行したいので、保存関数を呼び出したい。

2694
05:28:34,500 --> 05:28:42,260
保存されていない変更がある場合のみ、保存関数を呼び出したい。

2695
05:28:42,260 --> 05:28:48,020
というのも、初めてこのフックを呼び出すときには、まだこのフックには値がないからだ。

2696
05:28:48,020 --> 05:28:54,580
保存をトリガーしたくないからです。

2697
05:28:54,580 --> 05:29:01,780
この値がfalseに戻るまで、別のセーブを実行したくない。

2698
05:29:01,780 --> 05:29:12,500
この2つの値を依存関係としてユースエフェクトに渡す必要がある。

2699
05:29:12,500 --> 05:29:19,380
このフックはかなり複雑だが、いろいろ試した結果、このフックを思いついた。

2700
05:29:19,380 --> 05:29:26,260
このフックから、外部で必要な値を持つオブジェクトを返します。

2701
05:29:26,260 --> 05:29:32,500
レジュメエディターの外側で必要な値を持つオブジェクトを返します。

2702
05:29:32,500 --> 05:29:40,820
また、未保存の変更がある場合、アンロード警告を出すことができます。

2703
05:29:40,820 --> 05:29:48,100
ここでもjson.stringifyを使いますが、今回は比較する必要があります。

2704
05:29:48,100 --> 05:29:56,420
デバウンスされたデータではなく、通常のレジュームデータと文字列化された最後に保存されたデータを比較しなければなりません。

2705
05:29:56,420 --> 05:30:05,780
このフックをレジュメエディターで使ってみましょう。

2706
05:30:05,780 --> 05:30:12,100
もちろん、実際にはまだ何も保存していません。

2707
05:30:12,100 --> 05:30:18,980
このロジックが機能するかどうかを確認することができます。

2708
05:30:18,980 --> 05:30:28,180
ここで、履歴データを必要とするuse autosave
resumeフックを呼び出すために、constを再構築します。

2709
05:30:28,180 --> 05:30:34,100
そして、ここではもちろん、保存されており、未保存の変更があることがわかります。

2710
05:30:36,100 --> 05:30:42,580
以下に、アンロード警告を使用することを呼び出したいと思います。

2711
05:30:42,580 --> 05:30:49,380
未保存の変更がある場合のみトリガーされるようにします。

2712
05:30:49,380 --> 05:30:55,620
この1.5秒の間にページを更新しようとすると、この警告が表示されるはずです。

2713
05:30:55,620 --> 05:31:02,260
この警告が表示されるはずだ。

2714
05:31:02,260 --> 05:31:08,340
秒半待ってからもう一度更新すると、この警告は表示されます。

2715
05:31:08,340 --> 05:31:14,180
しかし、まだ実際には何も保存されていない。

2716
05:31:14,180 --> 05:31:22,020
フッターのtsxファイルに行きましょう。

2717
05:31:22,020 --> 05:31:29,540
このために、このコンポーネントにis savingという別のpropを追加します。

2718
05:31:29,540 --> 05:31:34,020
これは単純なブール値です。

2719
05:31:34,020 --> 05:31:46,260
そしてこれらのクラス名をzn関数にラップし、2番目のドキュメントとして条件を追加します。

2720
05:31:46,260 --> 05:31:53,540
保存がtrueのとき、不透明度を100に戻したい。

2721
05:31:55,540 --> 05:32:04,020
このテキストを見えるようにするために、これを保存し、レジュームエディタでこのブール値を渡します。

2722
05:32:04,020 --> 05:32:10,820
これはuse autosaveフックから来ています。

2723
05:32:10,820 --> 05:32:19,860
何かを変更すると、is savingのテキストが表示されます。

2724
05:32:19,860 --> 05:32:24,500
1秒半後にテキストが表示され、さらに1秒半後にテキストが消えるはずです。

2725
05:32:24,500 --> 05:32:32,180
試しに文字を入力してみると、保存中の文字は消えてしまう。

2726
05:32:32,180 --> 05:32:40,020
少なくとも1.5秒の間隔が空くまで、テキストを保存することはない。

2727
05:32:40,020 --> 05:32:46,820
しかし今回の保存はなぜか発動しなかった。

2728
05:32:46,820 --> 05:32:53,620
というのも、以前と同じ入力があるからだ。

2729
05:32:54,260 --> 05:32:59,220
変更を実際にデータベースに保存するには、サーバーエンドポイントが必要です。

2730
05:32:59,220 --> 05:33:05,620
next.jsでサーバーエンドポイントを作る一番簡単な方法は、サーバーアクションを使うことです。

2731
05:33:05,620 --> 05:33:12,660
next.jsでサーバーエンドポイントを作る一番簡単な方法は、サーバーアクションを使うことです。

2732
05:33:12,660 --> 05:33:19,460
このサーバーアクションファイルの命名規則はactions.tsですが、この名前は何でもかまいません。

2733
05:33:19,460 --> 05:33:26,980
しかし、サーバーアクションにするために好きな名前をつけることができます。

2734
05:33:26,980 --> 05:33:34,900
ディレクティブを追加し、ここでエクスポートするすべての関数はサーバーエンドポイントを作成します。

2735
05:33:34,900 --> 05:33:42,340
関数をエクスポートします。

2736
05:33:42,340 --> 05:33:49,300
通常のデータを渡すことができることです。

2737
05:33:49,300 --> 05:33:55,940
データを送信する場合、それをjsonやフォームデータ、ブロブなどに変換して

2738
05:33:55,940 --> 05:34:03,380
しかし、ここでは通常のjavascriptオブジェクトを渡すことができます。

2739
05:34:03,380 --> 05:34:09,380
シリアライズされ、next.jsによって自動的にデシリアライズされる。

2740
05:34:09,380 --> 05:34:16,020
next.jsによって自動的にシリアライズされ、デシリアライズされる。

2741
05:34:16,900 --> 05:34:24,340
まず最初に、これらの値からアイデアを再構築したい。

2742
05:34:24,340 --> 05:34:32,180
既存のレジュメを編集する場合、この値を知っておく必要があります。

2743
05:34:32,180 --> 05:34:41,460
次に、バックエンドに送信するデータをconsole.logに記録します。

2744
05:34:41,460 --> 05:34:47,220
機能的には必要ないのですが、実際に正しいデータを送信しているか確認するために必要です。

2745
05:34:47,220 --> 05:34:55,380
というわけで、console.logに値を記録し、この入力を検証します。

2746
05:34:55,380 --> 05:35:00,660
関数のように見えても、これはサーバーエンドポイントを作成し、理論的にはサーバーエンドポイントを呼び出して

2747
05:35:00,660 --> 05:35:05,940
理論的には、サーバーエンドポイントを呼び出して好きなデータを送ることができます。

2748
05:35:05,940 --> 05:35:13,140
これが、私たちが作成したレジュメスキーマです。

2749
05:35:13,140 --> 05:35:19,140
このスキーマには、フォームのすべて、16進数の色、ボーダーのスタイルが含まれています。

2750
05:35:19,140 --> 05:35:27,540
このスキーマを使用して、入力の検証を行うことができます。

2751
05:35:28,340 --> 05:35:35,620
を呼び出し、値を渡します。

2752
05:35:35,620 --> 05:35:41,540
データが正しくない場合はエラーとなり、データが正しい場合は検証された値を見つけることができる。

2753
05:35:41,540 --> 05:35:50,980
ここで、ファイルや未定義の写真を再構築し、仕事の経験を再構築します。

2754
05:35:51,780 --> 05:35:58,340
ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・ドット・履歴書

2755
05:35:58,340 --> 05:36:04,100
というのも、これらの値は少し違った扱いをしなければならないからだ。

2756
05:36:04,100 --> 05:36:10,660
ファイルとこの2つは配列である。

2757
05:36:10,660 --> 05:36:17,140
レジュメは常に特定のユーザー権限に属しているので、そのユーザーが誰なのかを知る必要がある。

2758
05:36:17,140 --> 05:36:26,500
ロックされているユーザーを知るには、clerkからのインポートであるwait
offを呼び出せばいい。

2759
05:36:26,500 --> 05:36:34,260
ロックされていないユーザーがサーバーアクションを呼び出そうとした場合、エラーをスローする必要があります。

2760
05:36:34,260 --> 05:36:40,740
これは保護されたサーバーアクションなので、ロックされているユーザーしか呼び出すことができません。

2761
05:36:40,740 --> 05:36:49,220
ユーザーIDが未定義の場合、新しいエラーを投げます。

2762
05:36:49,220 --> 05:36:55,300
という新しいエラーを投げます。

2763
05:36:55,300 --> 05:36:59,860
を呼び出すことができる。

2764
05:36:59,860 --> 05:37:09,780
というコメントをここに書きました。

2765
05:37:09,780 --> 05:37:17,540
プレミアム・ユーザー以外のレジューム・カウントをチェックしたい。

2766
05:37:17,540 --> 05:37:24,900
まだstripeを実装していないので、後でこれを行うためにここにto doコメントを残しておきます。

2767
05:37:24,900 --> 05:37:31,380
idがあれば、新規に履歴書を作成することも、すでにある履歴書の変更を保存することもできます。

2768
05:37:31,380 --> 05:37:38,660
ここでidを渡すと、このレジュメをデータベースから取得する必要があります。

2769
05:37:38,660 --> 05:37:47,220
idが定義されているかチェックします。

2770
05:37:47,220 --> 05:37:55,300
idが定義されていれば、データベースからidを取得します。

2771
05:37:55,300 --> 05:38:03,620
idとユーザーidを渡して、このユーザーが実際にロードする権限があることを確認します。

2772
05:38:03,620 --> 05:38:10,740
もしidが未定義の場合は、既存のレジュメをnullに設定します。

2773
05:38:10,740 --> 05:38:16,020
idが未定義の場合、既存のレジュメをnullに設定します。

2774
05:38:16,020 --> 05:38:26,260
もしidが未定義の場合は、既存のレジュメをnullにします。

2775
05:38:26,260 --> 05:38:31,540
が未定義の場合、何か問題があります。

2776
05:38:32,500 --> 05:38:39,460
その場合、レジュメが見つからないというエラーが発生します。

2777
05:38:39,460 --> 05:38:48,580
そして、この履歴書データをデータベースに挿入する前に、この写真をBLOBにアップロードする必要があります。

2778
05:38:48,580 --> 05:38:54,020
ストレージにアップロードする必要があります。

2779
05:38:54,020 --> 05:38:59,700
をブロブストレージにアップロードする必要があります。

2780
05:38:59,700 --> 05:39:05,780
もちろん、ドキュメントにはどのように動作するかが書かれている。

2781
05:39:05,780 --> 05:39:08,500
しかし、私はあなたにすべてをお見せします

2782
05:39:08,500 --> 05:39:19,060
以下に、newer photo urlというletを作成します。

2783
05:39:19,060 --> 05:39:28,740
という名前のletを作成し、これをundefinedで初期化します。

2784
05:39:28,740 --> 05:39:34,420
nullは現在の写真を削除したいことを意味します。

2785
05:39:34,420 --> 05:39:42,580
このようにnullとundefinedを区別することで、以下では再構築された写真かどうかをチェックします。

2786
05:39:42,580 --> 05:39:51,300
履歴書の値から、photoがfileのインスタンスであるかどうかをチェックします。

2787
05:39:51,300 --> 05:39:57,780
というのも、これはファイルか未定義だからだ。

2788
05:39:58,820 --> 05:40:04,740
しかし、もしこれがファイルであれば、このファイルをブロブにアップロードすることになります。

2789
05:40:04,740 --> 05:40:11,220
ストレージにアップロードしたいのですが、このレジュメにすでに写真がある場合は、まず古い写真を削除してから

2790
05:40:11,220 --> 05:40:16,500
新しい写真をアップロードする前に、古い写真を削除します。

2791
05:40:16,500 --> 05:40:25,700
そのため、このレジュメに既に写真が保存されている場合は、resume.photo.urlをチェックします。

2792
05:40:26,980 --> 05:40:31,620
を呼び出します。

2793
05:40:31,620 --> 05:40:41,940
を手動でインポートする必要があります。

2794
05:40:41,940 --> 05:40:51,940
deleteを呼び出し、既存のresume.photo.urlを渡す。

2795
05:40:53,300 --> 05:41:00,020
その後、この内側のifブロックの後に、新しい画像をアップロードするために

2796
05:41:00,020 --> 05:41:09,060
await.putを呼び出します。これはzell blobからの別のインポートです。

2797
05:41:09,060 --> 05:41:14,420
パスとファイル名を渡し、これをバックティック文字列にする。

2798
05:41:14,420 --> 05:41:22,980
ここでresume_photos/と書き、フォルダを作成し、ファイル名を指定する。

2799
05:41:23,540 --> 05:41:28,420
.extnameにphpを渡します。

2800
05:41:28,420 --> 05:41:40,420
.extnameにphoto.nameを渡す。

2801
05:41:40,420 --> 05:41:47,460
拡張子だけで、このファイルには名前がない。

2802
05:41:47,460 --> 05:41:52,900
ファイル名が実際にどのように見えるかは後で見てみよう。

2803
05:41:52,900 --> 05:41:58,660
第3引数にはコンフィギュレーションを指定する。

2804
05:41:58,660 --> 05:42:05,780
アクセスをpublicに設定していますが、実はpublicしかありません。

2805
05:42:05,780 --> 05:42:12,100
つまり、blobストレージに入れた画像はすべて公開され、他のユーザーが見ることができます。

2806
05:42:12,100 --> 05:42:18,500
他のユーザーが見ることができ、非公開にする方法はありません。

2807
05:42:18,500 --> 05:42:24,660
今のところ非公開にする方法はありませんが、これらのURLはガス抜きもできないので、それを知らなければ他のユーザーの画像を見つけることはできません。

2808
05:42:24,660 --> 05:42:32,020
このblobから、新しい写真に割り当てたい画像のURLを取得します。

2809
05:42:32,020 --> 05:42:42,260
url blob.url これはアップロードされた写真のURLです。

2810
05:42:42,260 --> 05:42:48,740
まず古い写真を削除し、次に新しい写真をアップロードします。

2811
05:42:48,740 --> 05:42:55,860
nullを送信した場合は、既存の写真を削除することを意味します。

2812
05:42:55,860 --> 05:43:04,100
写真がnullであるかどうかをチェックします。

2813
05:43:04,100 --> 05:43:10,580
なぜならnullは削除を意味するからです。

2814
05:43:10,580 --> 05:43:14,740
が定義されているかどうかを確認します。

2815
05:43:19,940 --> 05:43:27,700
そして、新しい写真のurlをnullに設定し、データベースに保存できるようにします。

2816
05:43:27,700 --> 05:43:33,460
最後に、これらの変更をデータベースに保存します。

2817
05:43:33,460 --> 05:43:39,060
ここで、idが定義されているかどうかをチェックし、updateオペレーションを呼び出します。

2818
05:43:39,060 --> 05:43:48,500
idが定義されていない場合は、新しいエントリーをデータベースに挿入します。

2819
05:43:50,100 --> 05:43:58,980
prisma.resume.update括弧中括弧を追加し、idを渡すwhere句を追加しました。

2820
05:43:58,980 --> 05:44:04,500
を渡しています。dataには更新したいすべてのフィールドを渡しています。

2821
05:44:04,500 --> 05:44:12,660
更新したいすべてのフィールドを渡します。

2822
05:44:12,660 --> 05:44:18,820
をデータベースに保存します。

2823
05:44:18,820 --> 05:44:25,140
という文字列をデータベースに保存します。

2824
05:44:25,140 --> 05:44:32,180
写真のURLは文字列として扱われ、履歴書の値には含まれません。

2825
05:44:32,180 --> 05:44:38,740
これは重要なことです。なぜなら、履歴書テーブルはファイルを受け付けず、写真のURLを必要とするからです。

2826
05:44:39,300 --> 05:44:44,820
を渡す必要があるからです。

2827
05:44:44,820 --> 05:44:52,500
これらの配列も特別な処理が必要です。

2828
05:44:52,500 --> 05:44:57,540
単なる配列ではなく、完全に独立したテーブルだからです。

2829
05:44:57,540 --> 05:45:06,180
そのため、最初の引数としてjavascriptオブジェクトを渡す必要があります。

2830
05:45:06,180 --> 05:45:12,820
コロン、そして中かっこを空にしてください。

2831
05:45:12,820 --> 05:45:18,580
そして、バックエンドに送信する新しいテーブルを挿入します。

2832
05:45:18,580 --> 05:45:25,700
ここでcreateコロンにすべての実務経験を渡します。

2833
05:45:25,700 --> 05:45:33,540
を渡したいのですが、日付が文字列なのでエラーになります。

2834
05:45:33,540 --> 05:45:39,860
そのため、work experiences dot mapと呼ぶことにする。

2835
05:45:39,860 --> 05:45:47,620
ここで、それぞれの職歴を過去のものとして、括弧で囲んで返します。

2836
05:45:47,620 --> 05:45:56,180
新しいオブジェクトを返すために、ここでは職歴の値を広げ、開始日だけを変更します。

2837
05:45:56,180 --> 05:46:03,140
日付文字列を日付オブジェクトにラップする必要がある。

2838
05:46:03,140 --> 05:46:10,740
ドット開始日が定義されているかどうかをチェックする。

2839
05:46:10,740 --> 05:46:18,900
しかしこれが未定義の場合は、未定義を保存することになる。

2840
05:46:18,900 --> 05:46:26,500
ここで終了日を渡し、終了日が定義されているかどうかをチェックする。

2841
05:46:26,500 --> 05:46:33,620
を日付オブジェクトにラップします。学歴についても同じようにします。

2842
05:46:33,620 --> 05:46:44,180
経験ブロックをコピーして下に貼り付けます。

2843
05:46:44,180 --> 05:46:53,380
をeducationsにマッピングしたい。

2844
05:46:53,380 --> 05:47:00,660
そして最後に、educationsの後にもうひとつカンマを追加する。

2845
05:47:00,660 --> 05:47:08,340
そしてupdated atの値を現在の日付に設定します。

2846
05:47:08,340 --> 05:47:16,900
updatedのタイムスタンプは自動的に更新されるはずなのだが。

2847
05:47:16,900 --> 05:47:22,900
を自動的に更新するべきだと思っていたのですが、もしかしたらうまくいかなかったのかもしれません。

2848
05:47:22,900 --> 05:47:29,540
というのも、このupdated at
timestampとelseはどのような場合でも更新されるからだ。

2849
05:47:29,540 --> 05:47:35,380
ブロックでは、新しいレジュメを作成する必要があることを意味します。

2850
05:47:35,380 --> 05:47:44,900
プリズマドット・レジュメを返し、ドット・クリエイトを呼び出します。

2851
05:47:44,900 --> 05:47:51,940
このデータブロックを見てみよう。

2852
05:47:51,940 --> 05:47:59,780
タイムスタンプは不要なので削除しましょう。

2853
05:47:59,780 --> 05:48:06,980
このレジュメは新しいレジュメなので、この行を削除しましょう。

2854
05:48:06,980 --> 05:48:14,820
新しいレジュメを作成する際にはユーザーIDを渡す必要があります。

2855
05:48:14,820 --> 05:48:20,260
どのレジュメがどのユーザーのものかを知ることができます。

2856
05:48:20,260 --> 05:48:26,260
どのレジュメがどのユーザーのものかを知ることができます。

2857
05:48:26,260 --> 05:48:33,140
レジュメを実際に更新するために呼び出せるサーバーエンドポイントができました。

2858
05:48:33,140 --> 05:48:41,460
次の設定ファイルに行って、この設定に何かを追加してみましょう。

2859
05:48:42,100 --> 05:48:49,060
server actions 中括弧コロンと、ボディサイズの上限を4MBに設定したい。

2860
05:48:49,060 --> 05:48:56,020
に設定したい。そうすれば、4メガバイトまでの画像をサーバーアクションに送ることができる。

2861
05:48:56,020 --> 05:49:03,220
デフォルト値は1MBかそれ以下だと思う。

2862
05:49:03,220 --> 05:49:09,540
next.jsのサーバーレス関数に送信できる最大値なので、例えば動画ファイルや複数の画像を送信したい場合

2863
05:49:09,540 --> 05:49:14,420
next.jsでサーバーレス関数に送信できる最大値は4メガバイトである。

2864
05:49:14,420 --> 05:49:20,900
フロントエンドで画像が4メガバイトを超えないかチェックすることも覚えておこう。

2865
05:49:20,900 --> 05:49:26,660
フロントエンドとバックエンドで、画像が4メガバイトを超えないことを確認しています。

2866
05:49:26,660 --> 05:49:34,020
次に、appフォルダのルート・レイアウトtsxに移動してみましょう。

2867
05:49:34,020 --> 05:49:40,740
テーマ・プロバイダの中に、componentsフォルダからトースターを置いてみましょう。

2868
05:49:40,740 --> 05:49:47,380
エラー発生時の自動保存レジュームフックで表示したいトーストメッセージを表示するためです。

2869
05:49:47,380 --> 05:49:54,580
このトースターはもちろんshazianのものである。

2870
05:49:54,580 --> 05:50:03,140
ここでは新しい値をたくさん必要とする。

2871
05:50:03,140 --> 05:50:12,420
params を作成し、use search params フックを呼び出す。

2872
05:50:12,420 --> 05:50:16,260
関数を再構築します。

2873
05:50:16,260 --> 05:50:21,380
デバウンスされたレジュームデータの後に、新しい状態を作りたい。

2874
05:50:21,380 --> 05:50:25,780
を作成したい。

2875
05:50:30,100 --> 05:50:36,020
これをuseステートで初期化し、レジュームデータdot ideaを渡します。

2876
05:50:36,020 --> 05:50:43,620
新しいレジュメを作成するか、既存のレジュメを追加するかによって、定義される場合とされない場合があります。

2877
05:50:43,620 --> 05:50:51,540
ここで、is errorという別の状態を作成し、is errorを設定します。

2878
05:50:51,540 --> 05:50:59,620
エラーが発生した場合、解決するまで何度も保存を試したくないからだ。

2879
05:50:59,620 --> 05:51:05,060
エラーを解決するまで何度も保存を試したくないからです。

2880
05:51:05,060 --> 05:51:13,940
このフックはややこしいが、これが必要なコードだ。

2881
05:51:13,940 --> 05:51:19,380
このようなオートセーブ機能を作るために必要なコードです。

2882
05:51:19,380 --> 05:51:26,740
デバウンスされたレジューム・データが、このように自動保存されるのだ。

2883
05:51:26,740 --> 05:51:34,100
なぜなら、新しい変更を加えた後、その変更を保存しようとするからです。

2884
05:51:34,100 --> 05:51:41,380
エラーが解決されたかもしれないからだ。

2885
05:51:41,380 --> 05:51:47,860
save関数の中身を削除しよう。

2886
05:51:47,860 --> 05:51:59,300
tryブロックの中にtry
catchブロックを入れて、保存をtrueに設定し、エラーもfalseに戻す。

2887
05:51:59,300 --> 05:52:07,540
そして新しいデータを作り、それを構造化されたクローンに代入する。

2888
05:52:07,540 --> 05:52:15,540
そして、レジュームデータを保存するためにサーバーアクションを呼び出します。

2889
05:52:15,540 --> 05:52:18,020
そして、そこから何かを返します。

2890
05:52:18,020 --> 05:52:30,180
prismaのupdateまたはcreateの値を返します。

2891
05:52:30,180 --> 05:52:37,220
これは最後に保存されたデータなので、ここで受け取って変数に格納することができます。

2892
05:52:38,100 --> 05:52:45,220
更新されたレジュメはawaitに等しいので、保存されたレジュメのサーバーアクションを呼び出します。

2893
05:52:45,220 --> 05:52:53,060
括弧 中括弧 ここで新しいデータを渡します。

2894
05:52:53,060 --> 05:53:00,420
そして、ここで値を分散させたのは

2895
05:53:00,420 --> 05:53:07,460
というのも、バックエンドに同じ写真ファイルを送ることを避けたいからだ。

2896
05:53:07,460 --> 05:53:12,980
保存がトリガーされるたびに、同じ写真ファイルを何度も何度もバックエンドに送ることになる。

2897
05:53:12,980 --> 05:53:19,620
なぜなら、写真ファイルはテキストよりもサイズが大きいからです。

2898
05:53:19,620 --> 05:53:26,420
そのため、ここでは最後に保存されたデータが写真ファイルであるかどうかをチェックします。

2899
05:53:26,420 --> 05:53:31,460
が現在選択されている写真と同じであれば、写真が変更されていないことがわかる。

2900
05:53:31,460 --> 05:53:37,060
サーバーアクションに送信したくないので、次のようにします。

2901
05:53:37,060 --> 05:53:46,420
ここで括弧で囲んでいるのは、最後に保存されたデータ dot photo が新しいデータ dot
photo と等しいかどうかをチェックするためです。

2902
05:53:46,420 --> 05:54:03,380
が新しいデータと等しいかどうかをチェックします。

2903
05:54:03,380 --> 05:54:11,940
をundefinedに設定し、最後に保存された写真が現在選択されている写真と同じかどうかをチェックする。

2904
05:54:11,940 --> 05:54:18,020
もし最後に保存した写真が現在選択している写真と同じであれば、このphotoフィールドをundefinedに設定する。

2905
05:54:18,020 --> 05:54:23,780
このようにすることで、同じファイルを何度もバックエンドに送信することを避けることができます。

2906
05:54:23,780 --> 05:54:33,620
また、履歴書IDも送信します。

2907
05:54:33,620 --> 05:54:41,140
これが定義されていれば、既存の履歴書を更新する必要があることがわかります。

2908
05:54:41,140 --> 05:54:49,540
この更新されたレジュメの下にレジュメIDの状態を設定します。

2909
05:54:49,540 --> 05:54:56,980
を更新されたレジュメのidに設定します。

2910
05:54:56,980 --> 05:55:03,700
を作成し、保存のトリガーをかけると、データベースにレジュメが保存され、次に

2911
05:55:03,700 --> 05:55:08,820
を更新する必要があるからです。

2912
05:55:08,820 --> 05:55:15,380
新しいレジュメを作成すると、レジュメIDが返されます。

2913
05:55:15,380 --> 05:55:23,460
そしてその状態をサーバーのアクションに渡します。

2914
05:55:23,460 --> 05:55:29,540
そして、最後に保存したデータを、ここで作成したクローンである新しいデータに設定する。

2915
05:55:29,540 --> 05:55:34,020
を新しいデータに設定したい。

2916
05:55:37,620 --> 05:55:43,860
クローンを作成するのは、保存操作を行う前であることが重要です。

2917
05:55:43,860 --> 05:55:50,980
これは試行錯誤の末にわかったことで、クロージャと参照がJavaScriptでどのように機能するかということだ。

2918
05:55:50,980 --> 05:55:57,860
javascriptのクロージャと参照の仕組みから、試行錯誤の末にわかったことだ。

2919
05:55:57,860 --> 05:56:04,500
保存中に配列要素に変更を加えた場合、変更が正しく保存されません。

2920
05:56:04,500 --> 05:56:10,100
このバグを解決するのは非常に困難でしたが、このクローンを保存が進行しているときではなく、一番最初に作成することでこの問題を回避できることがわかりました。

2921
05:56:10,100 --> 05:56:18,660
そして、新しいレジュメを作成したら、そのレジュメを保存したい。

2922
05:56:18,660 --> 05:56:26,980
新しいレジュメを作成した場合、urlにレジュメのIDを入れ、ページを更新したときにレジュメを読み込むようにしたいのです。

2923
05:56:26,980 --> 05:56:32,820
編集できるようにするためです。

2924
05:56:32,820 --> 05:56:41,380
をurlに入れる必要があります。

2925
05:56:41,380 --> 05:56:48,740
resume id このkeyの下にレジュメのidを格納します。

2926
05:56:48,740 --> 05:56:59,540
もしこれが更新されたレジュメのidと等しくなければ、このレジュメのidをurlにプッシュする必要があります。

2927
05:56:59,540 --> 05:57:07,140
既存の検索パラメータを保持したいので、新しい検索パラメータを作成します。

2928
05:57:07,140 --> 05:57:14,180
を作成し、これを新しいurl search paramsに代入します。

2929
05:57:14,180 --> 05:57:20,580
既存の検索パラメータを渡して、新しい検索パラメータを取得します。

2930
05:57:21,300 --> 05:57:27,220
ここに更新された履歴書のIDを入れます。

2931
05:57:27,220 --> 05:57:33,380
そして最後にwindow dot historyを呼び出します。

2932
05:57:33,380 --> 05:57:40,580
を呼び出しますが、今回はプッシュ状態を呼び出さず、リプレース状態を呼び出します。

2933
05:57:40,580 --> 05:57:47,380
ブラウザのバックヒストリーに追加されるのではなく、現在のページを置き換えるのです。

2934
05:57:47,380 --> 05:57:54,740
この場合、nullに空の文字列を渡し、検索パラメータにクエスチョンマークを付けます。

2935
05:57:54,740 --> 05:58:00,740
をバックティック文字列のクエスチョンマーク、ドル記号、中括弧で囲み、ここに

2936
05:58:00,740 --> 05:58:09,380
を文字列化し、このレジュメIDをurlに入れます。

2937
05:58:09,380 --> 05:58:16,580
に入れ、他の検索パラメータは保持します。

2938
05:58:16,580 --> 05:58:23,700
urlから削除したくない他の検索パラメータは保持されます。

2939
05:58:23,700 --> 05:58:29,460
フックを作成し、useエフェクトを作成する。

2940
05:58:29,460 --> 05:58:34,420
変更を保存しようとするエフェクトを作成する。

2941
05:58:34,420 --> 05:58:39,780
レースコンディションやその他のバグを避けるために、私はこのフックを考え出すのに何日もかかった。

2942
05:58:39,780 --> 05:58:46,500
このフックを思いつくのに何日もかかったが、今はちゃんと動いている。

2943
05:58:46,500 --> 05:58:53,060
このエラーをtrueにセットすることで、現在エラーが発生していることがわかる。

2944
05:58:53,060 --> 05:58:59,700
また、デバッグのためにエラーをコンソールにロックしたい。

2945
05:58:59,700 --> 05:59:06,180
トースト・メッセージの返り値をconstにリストアする。

2946
05:59:06,180 --> 05:59:14,980
中括弧で囲んだこの構造化されていないconstの中に、dissue関数を見つけることができる。

2947
05:59:14,980 --> 05:59:21,700
このトーストを隠すために、トーストのバリアントをdestructiveに設定します。

2948
05:59:21,700 --> 05:59:27,780
そしてトーストの説明を設定します。

2949
05:59:27,780 --> 05:59:35,780
通常は文字列を設定します。

2950
05:59:35,780 --> 05:59:41,940
文字列の代わりにjsxをレンダリングすることもできる。

2951
05:59:41,940 --> 05:59:47,620
文字列の代わりに中かっこを渡して、ここにdiffを入れたい。

2952
05:59:47,620 --> 05:59:57,940
しかし、これはtsファイルなので、jsx構文をサポートしていない。

2953
05:59:57,940 --> 06:00:04,900
そうすれば、diffのようにjsx構文を使うことができる。

2954
06:00:06,420 --> 06:00:14,020
このdiffにスペースy3を追加し、ここに表示される小さなレイアウトを追加します。

2955
06:00:14,020 --> 06:00:20,900
乾杯メッセージの中に、変更を保存できませんでしたという段落を入れる。

2956
06:00:20,900 --> 06:00:29,220
そしてその下に、大文字のbでretryと表示されるボタンを設置します。

2957
06:00:32,260 --> 06:00:35,860
このボタンをクリックすると、エラー関数を渡します。

2958
06:00:35,860 --> 06:00:44,100
ここで、このトーストを非表示にして、もう一度保存を呼び出します。

2959
06:00:44,100 --> 06:00:51,060
再度保存を試み、うまくいかなければまたトースト・メッセージを表示する。

2960
06:00:51,060 --> 06:00:58,100
これでtryブロックとcatchブロックができた。

2961
06:00:58,100 --> 06:01:04,020
finallyブロックを追加しています。

2962
06:01:04,020 --> 06:01:11,700
保存関数を呼び出すところで、ifブロックに別の条件を追加します。

2963
06:01:11,700 --> 06:01:18,500
このエラーが偽の場合のみ保存を試みる。

2964
06:01:18,500 --> 06:01:24,180
このエラーがfalseに戻るまで待ちたい。

2965
06:01:25,060 --> 06:01:30,580
さて、この依存配列はさらにいくつかの値を期待している。

2966
06:01:30,580 --> 06:01:39,460
これらはすべて、useエフェクトの中で使う値です。

2967
06:01:39,460 --> 06:01:49,460
search params と toast はこれらをすべて追加します。

2968
06:01:49,460 --> 06:01:57,380
バリアントをセカンダリに設定し、すべての変更を保存します。

2969
06:01:57,380 --> 06:02:05,540
これで、履歴書エディタで

2970
06:02:05,540 --> 06:02:14,100
これで、新しいレジュメを作成するためにページを更新してみましょう。

2971
06:02:14,820 --> 06:02:20,900
新しい履歴書を作成するためにページを更新してみましょう。

2972
06:02:20,900 --> 06:02:30,740
新しいターミナルを開き、npx prismaを実行します。

2973
06:02:30,740 --> 06:02:38,900
これでプリズマスタジオが開き、データベースのすべてのテーブルとその内容を見ることができる。

2974
06:02:38,900 --> 06:02:46,980
今はデータベースが空なので、レジュメIDがありません。

2975
06:02:46,980 --> 06:02:53,460
saveが実行されると、新しいレジュメが作成され、そのレジュメがデータベースに保存されます。

2976
06:02:53,460 --> 06:03:00,020
をurlに入力してみてください。

2977
06:03:00,580 --> 06:03:08,420
保存されると、新しいレジュメIDがここに保存され、プリズマスタジオでは1つのレジュメが表示されます。

2978
06:03:08,420 --> 06:03:14,100
カラーハックとボーダースタイルはデフォルト値です。

2979
06:03:14,100 --> 06:03:21,380
名前と姓を入力したので、職種を変更するときに

2980
06:03:22,340 --> 06:03:32,820
フルスタックデベロッパーのように変更すると、その変更も保存されます。

2981
06:03:32,820 --> 06:03:38,820
まだこのIDから既存の履歴書を読み込んでいないため、まだこのページを更新すべきではありません。

2982
06:03:38,820 --> 06:03:47,300
次に、ファイルをアップロードしてみましょう。

2983
06:03:47,300 --> 06:03:54,420
この画像も自動保存されますが、エラーが発生しました。

2984
06:03:54,420 --> 06:04:01,300
この環境変数を追加するのを忘れていた。

2985
06:04:01,300 --> 06:04:08,260
もう一度変更を加えると、エラーメッセージが表示されます。

2986
06:04:08,260 --> 06:04:15,220
というエラーメッセージが表示され続け、再試行をクリックすると保存を試みますが、うまくいきません。

2987
06:04:15,220 --> 06:04:22,420
環境変数を追加する必要がある。

2988
06:04:22,420 --> 06:04:28,340
zブロブストレージをまだセットアップしていませんでした。

2989
06:04:28,340 --> 06:04:35,380
データベースの作成をクリックし、ブロブストレージが必要なので、ここをクリックします。

2990
06:04:36,660 --> 06:04:47,940
ai resume builder blobと呼びます。

2991
06:04:47,940 --> 06:04:54,500
基本的に必要なのはこの環境変数だけです。

2992
06:04:54,500 --> 06:04:59,620
をコピーして、envファイル

2993
06:05:02,180 --> 06:05:10,580
これを保存すると、バックエンドに画像をアップロードできるようになります。

2994
06:05:10,580 --> 06:05:17,300
再試行をクリックし、保存が完了したら、ブロブ・ストレージを覗いてみましょう。

2995
06:05:17,300 --> 06:05:23,940
ここに私たちの画像があるはずです。このブラウザーで、私たちが作成したこのフォルダーを使うことができます。

2996
06:05:23,940 --> 06:05:30,660
ファイル名は正しいようですが、先ほどはよくわかりませんでした。

2997
06:05:30,660 --> 06:05:38,020
ファイル名は問題ない。

2998
06:05:38,020 --> 06:05:45,940
アップロードしたファイルのURLです。

2999
06:05:45,940 --> 06:05:53,300
アクションファイルの中で重要なことがある。

3000
06:05:53,300 --> 06:05:59,380
同じ画像ファイルを何度も送信しないようにするためです。

3001
06:05:59,380 --> 06:06:08,420
同じ画像を何度も送信しないようにしたいからです。

3002
06:06:08,420 --> 06:06:14,660
なぜなら、これまた無駄が多いからだ。

3003
06:06:14,660 --> 06:06:21,140
エアフォード 金庫が作動するのを待ちます。

3004
06:06:21,140 --> 06:06:27,940
新しい画像を選択すれば、再び画像が送信されます。

3005
06:06:27,940 --> 06:06:35,540
新しい画像を追加しても自動保存されないようです。

3006
06:06:35,540 --> 06:06:41,940
これはバグなので、すぐに解決するつもりですが、他のフィールドを変更すると、自動保存が行われます。

3007
06:06:41,940 --> 06:06:48,180
自動保存は再度トリガーされますが、新しい画像は送信されません。

3008
06:06:48,180 --> 06:06:55,780
この画像はblobストレージから削除されるはずです。

3009
06:06:56,740 --> 06:07:03,940
新しい画像をアップロードすることはできますが、既存の画像を置き換えているように見えます。

3010
06:07:03,940 --> 06:07:14,500
そこで、use autosave resume hookを調べて、この問題を解決してみよう。

3011
06:07:14,500 --> 06:07:21,700
ファイルを文字列化するだけではだめなんだ。

3012
06:07:21,700 --> 06:07:27,460
デバウンスされたレジュームデータと最後に保存されたデータをコンソールにロックしてみました。

3013
06:07:27,460 --> 06:07:31,300
をコンソールにロックしました。

3014
06:07:31,300 --> 06:07:40,580
を変更すると、どちらの場合も空のオブジェクトが表示されます。

3015
06:07:40,580 --> 06:07:46,740
というのも、javascriptはファイルを文字列に変換する方法を知らないので、同じファイルを持っていると思ってしまうからです。

3016
06:07:46,740 --> 06:07:54,660
また、写真の文字列を呼び出しているここにも問題があるはずです。

3017
06:07:54,660 --> 06:08:02,580
json.stringifyを呼び出すときに、2番目のドキュメントとしてreplacerを渡すことができます。

3018
06:08:02,580 --> 06:08:09,220
を渡すことができ、空のファイル・オブジェクトをファイル

3019
06:08:09,220 --> 06:08:14,420
オブジェクトに置き換えるようなリプレーサーを作ることができる。

3020
06:08:15,940 --> 06:08:25,140
file replacerと呼ぶ関数をエクスポートしよう。

3021
06:08:25,140 --> 06:08:31,860
キーと値の2つの引数を受け取ります。

3022
06:08:31,860 --> 06:08:39,860
もし値がfileのインスタンスなら、オブジェクトを返したい。

3023
06:08:40,820 --> 06:08:47,140
のインスタンスであれば、比較に必要なすべての値を含むjavascriptオブジェクトを返したい。

3024
06:08:47,140 --> 06:08:50,340
そうでなければ、変更されていない値を返したい

3025
06:08:50,340 --> 06:08:58,340
ここでファイルを広げるだけで十分なのか、それともこれらを代入しなければならないのか、よくわからない。

3026
06:08:58,340 --> 06:09:04,820
引数の型をanyからunknownに変えてみましょう。

3027
06:09:04,820 --> 06:09:11,620
なぜならeslintが文句を言わないからだ。

3028
06:09:11,620 --> 06:09:20,660
さて、指をくわえて祈ってみよう。

3029
06:09:20,660 --> 06:09:29,380
stringify関数の第二引数にファイルリプレイサーを渡す。

3030
06:09:30,260 --> 06:09:35,540
そして、この2つのロック・ステートメントでもこれを行いたい。

3031
06:09:35,540 --> 06:09:43,540
でもこうすることで、実際に動くかどうか確認することができる。

3032
06:09:43,540 --> 06:09:49,460
ページを更新しないと、変更が反映されないかもしれません。

3033
06:09:49,460 --> 06:09:56,740
ツールを開いてください。ここでまだログを記録しています。

3034
06:09:58,100 --> 06:10:04,900
いいえ、まだうまくいきません。でも心配しないでください。

3035
06:10:04,900 --> 06:10:11,220
ファイル・リプレイサーで全部の値を広げることはできない。

3036
06:10:11,220 --> 06:10:21,220
ファイル名、サイズ、そして比較に必要なものすべてだ。

3037
06:10:21,220 --> 06:10:28,340
ファイル名、サイズ、そしてタイプ、最終更新日。

3038
06:10:28,340 --> 06:10:39,780
ファイルを比較するには、右のタイプ値ドット・タイプと、最後の更新値ドット・ラスト・モディファイを指定します。

3039
06:10:39,780 --> 06:10:45,700
これを保存し、ページをリフレッシュしてもう一度やってみよう。

3040
06:10:48,100 --> 06:10:49,700
ファイルを選択する

3041
06:10:49,700 --> 06:10:57,780
すると、適切に文字列化されたファイルが表示された。

3042
06:10:57,780 --> 06:11:07,060
自動保存フックに戻ると、保存されていないファイルに対してファイル・リプレイサーを使用しました。

3043
06:11:07,060 --> 06:11:14,900
値を変更する場合は、ここでレジュームの保存と写真の文字列への呼び出しに使用する必要がある。

3044
06:11:15,860 --> 06:11:22,500
ここで文字列を削除し、ここでも文字列を削除する。

3045
06:11:22,500 --> 06:11:30,260
をjson.stringifyにラップします。

3046
06:11:30,260 --> 06:11:37,460
そして、これらのファイルを適切に比較できるように、ここでもファイルリプレイサーを使用します。

3047
06:11:39,460 --> 06:11:47,140
もう一度このページを更新すると、今度はこの写真を更新することができるはずです。

3048
06:11:47,140 --> 06:11:54,340
保存がトリガーされるはずです。最初の写真の保存で、ブロブ・ストレージを見て、ファイルがあるかどうか確認しましょう。

3049
06:11:54,340 --> 06:12:02,500
複数の履歴書を作成したため、ファイルがたくさんありますが、問題ありません。

3050
06:12:04,660 --> 06:12:11,620
これは最後にアップロードしたもので、これを置き換えたいので、他の2つを削除しましょう。

3051
06:12:11,620 --> 06:12:19,060
新しいファイルを選択すると自動保存され

3052
06:12:19,060 --> 06:12:26,340
このファイルを削除し、代わりに新しいファイルをアップロードします。

3053
06:12:26,340 --> 06:12:36,100
ブロブ・ストレージをリフレッシュすると、新しいファイルが完璧に保存された。

3054
06:12:36,100 --> 06:12:41,620
チュートリアルを録画している間、基本的に本番で自分のコードをデバッグする方法です。

3055
06:12:41,620 --> 06:12:47,620
このような自動保存フックを作成するのは本当に難しいものです。

3056
06:12:47,620 --> 06:12:54,660
でも、今はちゃんと動くはずだと思う。

3057
06:12:54,660 --> 06:13:00,500
コンソールにロギングして、ファイルを文字列化する必要があることがわかりました。

3058
06:13:00,500 --> 06:13:06,900
ファイルを文字列化する方法をググってみたら、これが出てきたんだ。

3059
06:13:06,900 --> 06:13:12,660
また、同じ写真を何度もバックエンドに送らないことも重要だ。

3060
06:13:12,660 --> 06:13:21,060
新しい写真を選択しない限り、同じ写真を何度も送信することはありません。

3061
06:13:21,060 --> 06:13:30,740
しかし、ページを更新すると、前のデータが表示されません。

3062
06:13:30,740 --> 06:13:37,060
履歴書を読み込んでいないため、前のデータが表示されない。

3063
06:13:37,060 --> 06:13:43,460
ページを更新したときに、ページのtsxファイルにレジュメを読み込みます。

3064
06:13:43,460 --> 06:13:50,340
そこでレジュメを読み込み、レジュメエディタに渡すことができます。

3065
06:13:51,060 --> 06:13:52,740
ページファイル

3066
06:13:52,740 --> 06:14:03,380
ここで、インターフェイスページの小道具を作成します。

3067
06:14:03,380 --> 06:14:09,220
を検索パラメータから読み込む必要があるからです。

3068
06:14:09,220 --> 06:14:16,580
これはnextjs 15で変更されました。

3069
06:14:16,580 --> 06:14:25,220
プロミスにラップする必要があるということです。

3070
06:14:25,220 --> 06:14:34,340
paramsにはresume ideaが必要で、これはresume
ideaと全く同じキーでなければなりません。

3071
06:14:34,340 --> 06:14:42,020
そうでなければ、この値を見つけることができません。

3072
06:14:44,100 --> 06:14:50,340
そしてここで検索パラメータを見つけます。

3073
06:14:50,340 --> 06:14:58,340
しかし、これはとても簡単です。

3074
06:14:58,340 --> 06:15:05,700
そして、ここで再開のアイデアを見つけます。つまり、これを非同期関数にしなければなりません。

3075
06:15:05,700 --> 06:15:11,860
これはサーバー・コンポーネントであり、ここでデータをフェッチすることができるからだ。

3076
06:15:11,860 --> 06:15:20,100
履歴書IDが定義されているかどうかをチェックする。

3077
06:15:20,100 --> 06:15:27,220
もし定義されていれば、await prisma dot resume dot find
uniqueを呼び出します。

3078
06:15:27,220 --> 06:15:34,580
where句にideaとしてidを渡します。

3079
06:15:39,060 --> 06:15:42,820
また、ユーザIDもチェックする必要があります。

3080
06:15:42,820 --> 06:15:51,780
ユーザーIDもチェックする必要があります。

3081
06:15:51,780 --> 06:15:57,540
ユーザーIDを取得し、2番目のwhereフィルターとして渡します。

3082
06:15:57,540 --> 06:16:05,780
もしレジュメIDが定義されていなければ、nullをセットします。

3083
06:16:05,780 --> 06:16:12,500
レジュメが編集できないので、新しいレジュメを作成します。

3084
06:16:12,500 --> 06:16:18,420
もし未定義の場合、このページにアクセスすることはできません。

3085
06:16:18,420 --> 06:16:26,660
もしユーザーIDが未定義だったら、エラーを投げるか、nullを返すかすればいい。

3086
06:16:26,660 --> 06:16:34,900
エラーを投げるか、nullを返すかの違いはありません。

3087
06:16:35,700 --> 06:16:42,900
履歴書テーブルだけを取得します。

3088
06:16:42,900 --> 06:16:49,700
というのも、これらは別々のテーブルにあるからです。

3089
06:16:49,700 --> 06:16:58,740
を使用すると、include値としてwork
experiencesにtrueを、educationsにtrueを渡します。

3090
06:16:59,940 --> 06:17:06,180
を渡すことで、対応するテーブルからこれらの配列を取得し、履歴書に格納することができます。

3091
06:17:06,180 --> 06:17:13,300
このレジュメに入れることで、気になるデータがすべて揃うことになる。

3092
06:17:13,300 --> 06:17:18,420
このインクルードを使っているので、これを別のファイルに取り出したい。

3093
06:17:18,420 --> 06:17:26,580
libフォルダに新しいファイルを作成します。

3094
06:17:26,580 --> 06:17:39,780
をエクスポートし、このオブジェクトに割り当てます。

3095
06:17:39,780 --> 06:17:47,700
また、prismaクライアントからインポートしたprisma satisfiesで型を設定します。

3096
06:17:47,700 --> 06:17:56,340
パッケージのドット・レジューム・インクルードを使って、型の安全性とオートコンプリートを実現します。

3097
06:17:56,340 --> 06:18:05,540
そして、このインクルードから型を生成します。

3098
06:18:05,540 --> 06:18:12,100
レジューム・サーバ・データをエクスポートします。

3099
06:18:12,100 --> 06:18:18,100
エディタで使用するレジュメの値とサーバから返されるレジュメの値は微妙に異なるため、後でマッピングする必要があります。

3100
06:18:18,100 --> 06:18:26,820
そのため、職歴と学歴を含む履歴書を作成します。

3101
06:18:26,820 --> 06:18:35,860
ペイロードを角括弧で囲み、中括弧で囲みます。

3102
06:18:36,980 --> 06:18:45,460
を渡すと、職歴と学歴を含む履歴書の型が生成される。

3103
06:18:45,460 --> 06:18:52,820
を含む履歴書の型を生成します。

3104
06:18:52,820 --> 06:18:59,700
をエディターページで使用したいと思います。

3105
06:19:01,540 --> 06:19:08,740
そして、このレジュメをレジュメエディタに渡します。

3106
06:19:08,740 --> 06:19:16,660
レジュメエディタにまだ追加していませんでしたが、これから追加します。

3107
06:19:16,660 --> 06:19:27,940
ここでは、小道具が必要ですインターフェイスの履歴書エディタ小道具、これは、編集するこの履歴書を受け入れる必要があります。

3108
06:19:29,460 --> 06:19:37,940
を受け付ける必要があります。

3109
06:19:37,940 --> 06:19:48,980
propsはresume to editとします。

3110
06:19:48,980 --> 06:19:57,140
そしてそれを変更することができます。

3111
06:19:57,700 --> 06:20:03,860
問題なのは、これはレジュメの値を想定しているのですが、レジュメサーバーのデータとレジュメの値は微妙に異なっていることです。

3112
06:20:03,860 --> 06:20:11,140
の値は少し異なっています。例えば、データベースでは日付は文字列ですが、クライアントでは日付オブジェクトです。

3113
06:20:11,140 --> 06:20:18,900
クライアントでは日付オブジェクトになります。

3114
06:20:18,900 --> 06:20:26,660
関数を作成し、サーバーデータからレジューム値にデータをマッピングします。

3115
06:20:26,660 --> 06:20:37,620
この関数はレジュームサーバーデータを入力として受け取り、レジューム値を返します。

3116
06:20:37,620 --> 06:20:45,860
オブジェクトを返します。

3117
06:20:45,860 --> 06:20:54,420
idはdata.idで、これはサーバー上でも同じです。

3118
06:20:56,420 --> 06:21:03,220
タイトルはdata.titleで、ここにも違いがあります。

3119
06:21:03,220 --> 06:21:10,260
nullにすることができますが、クライアント側でフォームに入力する場合はundefinedにしかなりません。

3120
06:21:10,260 --> 06:21:18,020
このようにundefinedに戻さなければならない。

3121
06:21:18,020 --> 06:21:30,100
写真は写真のURLかundefinedです。

3122
06:21:30,100 --> 06:21:33,700
名前

3123
06:21:33,700 --> 06:21:46,340
苗字 この苗字の行を5回繰り返す

3124
06:21:48,340 --> 06:21:52,660
というのも、そうすればもう少し早く役職がわかるからだ。

3125
06:21:52,660 --> 06:21:55,380
都市名

3126
06:21:55,380 --> 06:21:59,220
国

3127
06:21:59,220 --> 06:22:04,900
電話番号 メールアドレス

3128
06:22:04,900 --> 06:22:15,060
次に、data.workExperiencesをマッピングする必要があります。

3129
06:22:15,060 --> 06:22:21,300
をオブジェクトにマッピングします。

3130
06:22:21,300 --> 06:22:28,900
位置はexperience.positionで、ここでもundefinedに戻す必要があります。

3131
06:22:28,900 --> 06:22:33,940
に戻す必要があります。

3132
06:22:33,940 --> 06:22:43,860
それから、2つの日付があります。

3133
06:22:43,860 --> 06:22:49,700
フォームに入力したいのは文字列です。

3134
06:22:49,700 --> 06:23:00,900
experience.startDateから.toISOStringを呼び出し、次に.splitを呼び出して次のように分割します。

3135
06:23:00,900 --> 06:23:08,420
tを大文字のtに分割して文字列とします。

3136
06:23:08,420 --> 06:23:14,420
時間値はこの層の後に始まるので、これを分割して重要な

3137
06:23:14,420 --> 06:23:23,060
このように最初の要素にアクセスし、この行を複製して、同じように終了日にアクセスする。

3138
06:23:23,060 --> 06:23:28,580
そして、説明のexperience.descriptionも用意する。

3139
06:23:28,580 --> 06:23:36,100
またはundefined、そしてeducationsも同じようにします。

3140
06:23:38,260 --> 06:23:41,140
data.educationsをマップする。

3141
06:23:41,140 --> 06:23:46,980
各教育を取り出し、オブジェクトを返す

3142
06:23:46,980 --> 06:23:56,900
この4行をコピーしよう。開始日と終了日は同じように見えるが、これはすべて

3143
06:23:56,900 --> 06:24:06,420
役職の代わりに学位、会社の代わりに学校です。

3144
06:24:07,540 --> 06:24:14,580
学歴の次はスキルだ。

3145
06:24:14,580 --> 06:24:20,340
data.skillは配列なので、undefinedに戻る必要はない。

3146
06:24:20,340 --> 06:24:28,260
そして、ボーダー・スタイルはdata.borderStyleである。

3147
06:24:28,260 --> 06:24:33,460
というのも、これはデフォルト値を持っているからです。

3148
06:24:36,260 --> 06:24:41,380
そして最後にsummaryだが、これもnullになることがある。

3149
06:24:41,380 --> 06:24:49,060
これは大変な作業だったが、これでサーバーのデータをレジューム値にマッピングできるようになった。

3150
06:24:49,060 --> 06:24:58,020
エディタに戻すことができます。

3151
06:24:58,020 --> 06:25:04,180
use状態のイニシャライザでresume.toEditが定義されているかチェックします。

3152
06:25:04,180 --> 06:25:11,700
mapToResumeValues関数を呼び出します。

3153
06:25:11,700 --> 06:25:18,180
これは新しいレジュメを作成することを意味し、このデータは互換性があります。

3154
06:25:18,180 --> 06:25:24,660
をロードしようとしていることを意味します。

3155
06:25:24,660 --> 06:25:30,740
しかし、次の設定ファイルでこの画像をホワイトリストに登録しなければなりません。

3156
06:25:31,780 --> 06:25:35,220
そこで、experimentalブロックの後にimagesブロックを追加する

3157
06:25:35,220 --> 06:25:42,180
中かっこをコロンにして、オブジェクトの配列を受け取るリモートパターン

3158
06:25:42,180 --> 06:25:49,460
ここで、画像を読み込むUIをホワイトリストに登録する必要があります。

3159
06:25:49,460 --> 06:25:55,460
次の画像はサーバーでリサイズされるため、計算能力が必要となり、コストがかかります。

3160
06:25:55,460 --> 06:26:01,060
また、リサイズできるのは自分の画像だけで、他人がリサイズした画像を悪用できないようにするためです。

3161
06:26:01,060 --> 06:26:07,780
自分の所有する画像だけをホワイトリストに登録する必要があります。

3162
06:26:07,780 --> 06:26:14,020
これは私たちのブロブ・ストレージの場合です。

3163
06:26:14,020 --> 06:26:24,980
プロトコルをhttpsに設定し、ホスト名はこの部分です。

3164
06:26:24,980 --> 06:26:34,340
この数字からドットコムまでがホスト名です。

3165
06:26:34,340 --> 06:26:42,740
開発サーバーを再起動する必要があるかもしれないので、npm run
devをもう一度実行してページをリフレッシュする。

3166
06:26:42,740 --> 06:26:50,100
ページを更新すると、以前と同じ画像と名前が表示される。

3167
06:26:50,100 --> 06:26:56,420
サーバーからデータを読み込んだので、データベースには1つのエントリーがあるはずです。

3168
06:26:56,420 --> 06:27:03,860
変更するときも、この1つの項目だけを変更すればいい。

3169
06:27:03,860 --> 06:27:12,500
このレジュメのアイデアを変更するのだから、この画像を完全に削除することもできるはずだ。

3170
06:27:12,500 --> 06:27:21,460
をクリックして、この画像を完全に削除することもできます。

3171
06:27:21,460 --> 06:27:28,900
blobストレージからも消えているはずです。

3172
06:27:28,900 --> 06:27:38,260
まず、ここにある画像をアップロードします。

3173
06:27:38,980 --> 06:27:44,980
保存がトリガーされ、ページを更新すると、同じ画像が表示されます。

3174
06:27:44,980 --> 06:27:53,860
には1つのファイルしかありません。

3175
06:27:53,860 --> 06:28:00,100
デバッグのために、レジュメプレビューでレジュメデータをレンダリングすることもできます。

3176
06:28:00,100 --> 06:28:04,980
レジュメプレビューコンポーネントの一番上にある

3177
06:28:05,540 --> 06:28:13,940
個人ヘッダーの上に、すべてのデータをjson形式でレンダリングします。

3178
06:28:13,940 --> 06:28:22,980
レジューム・データとNULL、そしてフォーマット用の2つのデータです。

3179
06:28:22,980 --> 06:28:33,380
そして、ここにはファイルではなく写真のURLが入っています。

3180
06:28:33,380 --> 06:28:39,140
これは文字列ではなくファイルに置き換えられるはずです。

3181
06:28:39,140 --> 06:28:45,140
これはファイルですが、正しく文字列化されていません。

3182
06:28:45,140 --> 06:28:52,180
ページを更新すると、これはまたURLになってしまう。

3183
06:28:52,180 --> 06:28:59,380
これはアンロードの警告で、変更の保存がまだ終わっていないからです。

3184
06:29:01,220 --> 06:29:08,820
そして更新すると、すべてがうまくいくように見える。

3185
06:29:08,820 --> 06:29:15,220
データをロードしている間、ロード中のインジケータを表示するローディングtsxファイルを追加することは理にかなっています。

3186
06:29:15,220 --> 06:29:20,820
データをロードしている間、ロード中のインジケータを表示します。

3187
06:29:20,820 --> 06:29:29,220
すべてのページで使用することができ、この正確な名前を持つ必要があります。

3188
06:29:29,220 --> 06:29:36,820
次回のjs初心者チュートリアルで説明します。

3189
06:29:36,820 --> 06:29:44,820
ページにデータを読み込んだときに自動的に表示されるローディングインジケーターです。

3190
06:29:44,820 --> 06:29:55,140
このアイコンをmx auto、margin yを6にして、アニメーションをつけて、ページを更新すると

3191
06:29:55,140 --> 06:30:01,060
そしてページを更新すると、このようになります。

3192
06:30:01,060 --> 06:30:06,180
ブラウザの拡張機能とか、開発中の不具合とかが原因で起こることもある。

3193
06:30:06,180 --> 06:30:12,420
このレジュメがロードされている間、ローディングインジケータが表示されます。

3194
06:30:12,420 --> 06:30:19,140
もしバグを発見されましたら、ご連絡ください。

3195
06:30:19,140 --> 06:30:25,300
次にai機能を実装して、レジュメにai機能用のエントリーを自動生成できるようにしたいと思います。

3196
06:30:25,300 --> 06:30:34,340
ai機能を実装するために、openaiのchat gbt apiを使います。

3197
06:30:34,340 --> 06:30:40,020
お金を払うと聞いただけで、パニック発作を起こすようなケチな人も多いだろう。

3198
06:30:40,020 --> 06:30:44,900
チュートリアルのこの部分は読み飛ばしても構いません。

3199
06:30:44,900 --> 06:30:50,340
このビデオにはタイムスタンプがあります。

3200
06:30:50,340 --> 06:30:55,780
aiの機能が使えなくなりますが、ここでアカウントを作成することを強くお勧めします。

3201
06:30:55,780 --> 06:31:02,500
5ドルか10ドルを入金することを強くお勧めします。

3202
06:31:02,500 --> 06:31:09,060
何千もの単語を生成するのに、ほんのわずかなセントを支払うだけです。

3203
06:31:09,060 --> 06:31:15,460
私たちの世代は何千語も必要としません。

3204
06:31:15,460 --> 06:31:22,260
openai.comの「products」の下にある「api
login」からアカウントを作成できます。

3205
06:31:22,260 --> 06:31:29,300
もしまだアカウントをお持ちでない場合は、アカウントを作成してください。

3206
06:31:29,300 --> 06:31:35,940
まだアカウントをお持ちでない場合は、アカウントを作成してください。

3207
06:31:35,940 --> 06:31:42,820
今現在はスラッシュ・セッティングの下にありますが、時々変更されます。

3208
06:31:42,820 --> 06:31:53,300
次に、ドット環境ファイルを開き、ここにopenai_api_keyという名前を書きます。

3209
06:31:53,300 --> 06:31:59,700
openaiパッケージが自動的に認識するからだ。

3210
06:32:00,260 --> 06:32:06,100
もちろん、このキーは後で削除する。

3211
06:32:06,100 --> 06:32:13,140
僕のapiキーを使おうとするな、このヘビ野郎......。

3212
06:32:13,140 --> 06:32:18,820
openai.tsを右クリックする。

3213
06:32:18,820 --> 06:32:29,860
ここでopenaiクライアントを作成する。 const openai equals new
openai 自動インポートは失敗したようだ。

3214
06:32:29,860 --> 06:32:40,900
もう一度openaiパッケージからopenaiをインポートします。

3215
06:32:40,900 --> 06:32:46,900
openaiパッケージからopenaiをインポートする。

3216
06:32:46,900 --> 06:32:54,980
そして下にデフォルトのopenaiをエクスポートします。

3217
06:32:55,780 --> 06:33:01,860
まずは履歴書のサマリーを作成します。

3218
06:33:01,860 --> 06:33:08,100
履歴書データの一部をチャットgbtに送って、このデータで作業できるようにします。

3219
06:33:08,100 --> 06:33:14,660
例えば、写真やボーダーのスタイル、16進数カラーは必要ありませんが、他の値のいくつかは必要です。

3220
06:33:14,660 --> 06:33:20,260
validation.tsファイルに新しいバリデーションスキーマを作りましょう。

3221
06:33:20,260 --> 06:33:28,660
validation.tsファイルに新しいバリデーションスキーマを作成しましょう。

3222
06:33:28,660 --> 06:33:37,780
これはz.objectで、ここにバックエンドに送信したいすべてのデータを入れます。

3223
06:33:37,780 --> 06:33:43,700
バックエンドに送りたいすべてのデータをここに入れる。

3224
06:33:43,700 --> 06:33:51,140
オプションの文字列として役職名と、職務経験、学歴、スキルも入力する。

3225
06:33:51,140 --> 06:33:58,020
このために、職務経験スキーマを広げることで、すでに持っているスキーマを渡すことができる。

3226
06:33:58,020 --> 06:34:04,180
ドットシェイプにすることで、すでに持っているスキーマを渡すことができる。

3227
06:34:04,180 --> 06:34:12,260
他には何も必要ないと思うので、いつものように型を生成しよう。

3228
06:34:13,620 --> 06:34:22,500
generate summary input c dot infer type of
generate summary schema.

3229
06:34:22,500 --> 06:34:30,500
チャットgbtへの呼び出しはバックエンドで行わなければならない。

3230
06:34:30,500 --> 06:34:37,220
キーを使うので、フロントエンドからこれを行うことはできない。

3231
06:34:37,220 --> 06:34:44,820
でサーバーアクションを使うので、メインエディターフォームのformsフォルダに入れましょう。

3232
06:34:44,820 --> 06:34:51,700
というのも、このサーバーアクションは後で要約フォームで使うからです。

3233
06:34:51,700 --> 06:34:58,340
このuse serverディレクティブを一番上に追加します。

3234
06:34:58,340 --> 06:35:11,220
エンドポイントにエクスポートした非同期関数をgenerate summaryと呼ぶことにしましょう。

3235
06:35:11,220 --> 06:35:17,540
を渡します。この型は、検証ファイルで作成した

3236
06:35:17,540 --> 06:35:24,420
aiの機能をプレミアム・ユースでのみ利用できるようにしたい。

3237
06:35:24,420 --> 06:35:29,460
フロントエンドではこの機能をブロックするが、バックエンドでもブロックしなければならない。

3238
06:35:29,460 --> 06:35:35,300
フロントエンドのバリデーションだけでは安全ではない。

3239
06:35:35,300 --> 06:35:43,460
の購読がある場合、プレミアムユーザーかどうかをチェックしたいので、非プレミアムユーザー用のToDoコメントブロックを追加しよう。

3240
06:35:43,460 --> 06:35:46,980
プレミアムユーザーは、後でリマインダーとして

3241
06:35:49,300 --> 06:35:54,980
先ほど説明したように、ここで入力のバリデーションを行い、ユーザーが実際に正しいデータを送信していることを確認する必要があります。

3242
06:35:54,980 --> 06:36:00,580
というのも、これは技術的にはパブリック・サーバーのエンドポイントだからです。

3243
06:36:00,580 --> 06:36:08,740
これは、入力をスキーマに渡すために生成サマリースキーマを作成したものです。

3244
06:36:08,740 --> 06:36:15,460
スキーマを通過させ、検証された値をここから取り出すことができる。

3245
06:36:16,180 --> 06:36:20,980
職種 職歴 学歴 スキル

3246
06:36:20,980 --> 06:36:29,300
このエンドポイントに送信したデータがスキーマに準拠していない場合は、エラーがスローされます。

3247
06:36:29,300 --> 06:36:38,020
チャットgbt apiを使用したことがあるかどうかわかりませんが、この動作は次のようになります。

3248
06:36:38,020 --> 06:36:45,140
システムメッセージの形で人間と話しているように、人間が読める形で指示を送るということだ。

3249
06:36:45,780 --> 06:36:51,700
では一貫性のあるメッセージを作ってみよう。

3250
06:36:51,700 --> 06:36:55,780
文字列にしたい。そうすれば、複数行に渡ってメッセージを書くことができ、より読みやすくなるからだ。

3251
06:36:55,780 --> 06:37:02,980
そして、このapiに何をすべきかを記述する。

3252
06:37:02,980 --> 06:37:08,660
この記述が正確であればあるほど、通常はうまくいく。

3253
06:37:08,660 --> 06:37:19,780
例えば、あなたが職務経歴書ジェネレーターだとすると、あなたのタスクは以下のようになります。

3254
06:37:19,780 --> 06:37:28,500
たとえ誤字脱字があったとしても、スペルを完璧にする必要はありません。

3255
06:37:28,500 --> 06:37:34,340
aiはそれを認識してくれるだろう。でももちろん、私はずぼらな人間ではないので、きちんとやろう。

3256
06:37:34,340 --> 06:37:46,740
あなたの仕事は、ユーザーが提供したデータをもとに、履歴書のプロフェッショナルな紹介文を書くことです。

3257
06:37:46,740 --> 06:37:53,700
私がここで使っているのと全く同じ指示を書く必要はありません。

3258
06:37:53,700 --> 06:38:03,700
aiが何をすべきかを伝えたいだけです。

3259
06:38:04,900 --> 06:38:11,860
このようにすることで、aiがsummary colonやhere is your
summaryのようなテキストを追加することを避けたい。

3260
06:38:11,860 --> 06:38:18,180
要約が欲しいだけなのです。

3261
06:38:18,180 --> 06:38:25,460
簡潔でプロフェッショナルな文章にして、だらだらとした文章にならないようにする。

3262
06:38:25,460 --> 06:38:31,700
そして実際のデータに送る必要がある。

3263
06:38:31,700 --> 06:38:36,980
システム・メッセージにすることもできるが、通常は別のメッセージにする。

3264
06:38:36,980 --> 06:38:44,180
これはユーザーを表すメッセージだから、ユーザー・メッセージを作ることができる。

3265
06:38:44,180 --> 06:38:53,220
システムメッセージの後、このユーザーメッセージを送ります。

3266
06:38:53,220 --> 06:39:00,900
プロフェッショナルな履歴書の要約を作成してください。

3267
06:39:00,900 --> 06:39:06,980
はまずこれを読み、次にこのメッセージ「プロの履歴書の要約を作成してください」を読みます。

3268
06:39:06,980 --> 06:39:12,100
というメッセージが表示されます。

3269
06:39:12,100 --> 06:39:17,540
そしてまだバックティック文字列の中にいるので、ここに職種名をコロンと入れます。

3270
06:39:17,540 --> 06:39:24,580
そして、この職種名をレンダリングしたい。

3271
06:39:25,700 --> 06:39:34,500
しかし、もし職種が未定義の場合、aiがそれを知ることができるように、not
availableをレンダリングしたい。

3272
06:39:34,500 --> 06:39:40,580
職種を送信していない。これは 「not available 」を意味すると思う。

3273
06:39:40,580 --> 06:39:46,980
次に、職歴を文字列で渡します。

3274
06:39:49,460 --> 06:39:56,420
次に、職歴を文字列にマッピングします。

3275
06:39:56,420 --> 06:40:04,020
それぞれの職歴を取り出し、それぞれの職歴に対して別のバックティック文字列をレンダリングする。

3276
06:40:04,020 --> 06:40:16,340
ここにポジションをコロンで囲み、経験ドットポジションをレンダリングする。

3277
06:40:17,140 --> 06:40:23,860
をレンダリングするが、ここでも空白になる可能性がある。

3278
06:40:23,860 --> 06:40:28,740
で位置がないことを示します。

3279
06:40:28,740 --> 06:40:35,940
経験ドット会社

3280
06:40:35,940 --> 06:40:41,460
次に、開始日をレンダリングしたい。

3281
06:40:44,180 --> 06:40:45,860
をレンダリングしたい。

3282
06:40:45,860 --> 06:40:57,780
ツアー、そして終了日を表示したい。

3283
06:40:57,780 --> 06:41:05,300
フォールバック値としてpresentを文字列で指定し、これを各仕事経験に対して行う。

3284
06:41:05,300 --> 06:41:12,100
さらに、説明を追加したいので、ポジションの下に、まだこのバックティック文字列の中にある

3285
06:41:12,900 --> 06:41:18,740
をコロンで囲み、ここに説明を書く。

3286
06:41:18,740 --> 06:41:23,940
経験 ドット 説明 またこれは未定義でもよい

3287
06:41:23,940 --> 06:41:33,140
複数あるので、1つの文字列に結合したい。

3288
06:41:33,140 --> 06:41:40,020
を呼び出した後、ドット結合を呼び出す。

3289
06:41:40,020 --> 06:41:46,340
それぞれの間に2つの空白行を入れて、文字列がくっつかないようにしたい。

3290
06:41:46,340 --> 06:41:53,380
で空行を作り、学歴も同じようにしたい。

3291
06:41:53,380 --> 06:42:00,660
仕事体験のコードをコピーして、このバックティック文字列の中に貼り付けよう。

3292
06:42:01,300 --> 06:42:10,900
これを学歴に変更し、職歴を学歴に変更する。

3293
06:42:10,900 --> 06:42:26,100
ポジションを学位に変更します。

3294
06:42:26,100 --> 06:42:34,500
未定義の終了日は現在という意味ではなく、二度と利用できないという意味です。

3295
06:42:34,500 --> 06:42:41,700
最後に、ジョインコールの下にあるスキルですが、これはもっとシンプルです。

3296
06:42:41,700 --> 06:42:48,500
これは単なる文字列の配列なので、ここに直接レンダリングすることができます。

3297
06:42:48,500 --> 06:42:55,940
カンマ区切りのリストに自動的に文字列化されます。

3298
06:42:55,940 --> 06:43:02,340
aiにとっても人間にとっても読みやすい文字列を生成するだけです。

3299
06:43:02,340 --> 06:43:07,380
そして、これが正しく見えることを確認するために、以下のようにロックしてみましょう。

3300
06:43:07,380 --> 06:43:11,940
console dot lock まずシステムメッセージをロックし

3301
06:43:14,260 --> 06:43:17,860
次にユーザーメッセージ

3302
06:43:17,860 --> 06:43:28,340
次に、openai apiを呼び出して、これらの指示を渡し、答えを返します。

3303
06:43:28,340 --> 06:43:37,380
そこで、const completion equals await
openaiを作成し、libフォルダからインポートします。

3304
06:43:38,740 --> 06:43:47,300
dot chat dot completions dot create 括弧 中括弧
使用するモデルを定義します。

3305
06:43:47,300 --> 06:43:57,220
最新のものは4oですが、もっとお金を節約したければ、3.5ターボを使うことができます。

3306
06:43:57,220 --> 06:44:04,500
一番安いのは3.5ターボで、これは本当に非常に安い。

3307
06:44:06,900 --> 06:44:14,420
そして、このメッセージ・キーでaiにメッセージを渡す必要がある。

3308
06:44:14,420 --> 06:44:23,060
オブジェクトを定義しています。

3309
06:44:23,060 --> 06:44:30,020
そして、2番目のオブジェクトとしてrole user

3310
06:44:32,260 --> 06:44:38,980
を渡し、次にユーザーメッセージを渡します。

3311
06:44:38,980 --> 06:44:44,420
aiとチャットをすることができます。

3312
06:44:44,420 --> 06:44:49,140
このチュートリアルもあります。

3313
06:44:49,140 --> 06:44:55,300
でも、ここでやっていることはもっとシンプルです。

3314
06:44:55,300 --> 06:45:01,060
しかし、チャットGbt apiを使った他のチュートリアルを見てほしい。

3315
06:45:01,780 --> 06:45:08,180
次にaiのレスポンスを取得し、この完了からエラーを投げたい。

3316
06:45:08,180 --> 06:45:15,700
const ai response equals completion dot choices
ここで最初の要素にアクセスする必要があります。

3317
06:45:15,700 --> 06:45:23,860
ドット・メッセージ ドット・コンテンツ 返ってきたテキストを文字列にします。

3318
06:45:23,860 --> 06:45:31,220
もし何か問題が発生したら、感嘆符がaiレスポンスに表示されているかどうかをチェックする必要がある。

3319
06:45:31,220 --> 06:45:38,180
aiレスポンスの生成に失敗した場合、何も返せないのでエラーを投げたい。

3320
06:45:38,180 --> 06:45:44,580
しかし、もしレスポンスが返ってきたら、それをフロントエンドに返したい。

3321
06:45:44,580 --> 06:45:49,860
そこで、それをフォームに入れることができる。

3322
06:45:49,860 --> 06:45:57,940
要約フォームでこのエンドポイントを呼び出したい。

3323
06:45:57,940 --> 06:46:04,740
このボタンをフォームフォルダ内の組織用の別のコンポーネントに置くのは理にかなっています。

3324
06:46:04,740 --> 06:46:10,980
生成サマリー・ボタンは、常にわかりやすい名前にすること

3325
06:46:10,980 --> 06:46:18,020
デフォルトの関数generate summary buttonをエクスポートします。

3326
06:46:18,020 --> 06:46:27,780
インターフェース generate summary button props
バックエンドに送信するために履歴書データが必要です。

3327
06:46:27,780 --> 06:46:34,420
バックエンドに送信するための履歴書データが必要です。

3328
06:46:34,420 --> 06:46:39,780
このサマリーが生成されたときのコールバックが必要です。

3329
06:46:39,780 --> 06:46:45,780
これはサマリーを文字列として受け取り、何も返しません。

3330
06:46:45,780 --> 06:46:50,900
これらの小道具を再構築します。

3331
06:46:55,060 --> 06:47:02,420
そしてこのコンポーネントを作成する。

3332
06:47:02,420 --> 06:47:09,540
何か問題が発生したときにエラーメッセージを表示します。

3333
06:47:09,540 --> 06:47:16,100
と初期値falseのuseステートであるset loadingが必要です。

3334
06:47:19,140 --> 06:47:23,380
そして、handle clickと呼ぶ非同期関数が必要です。

3335
06:47:23,380 --> 06:47:33,460
このボタンをクリックすると、この関数が実行される。

3336
06:47:33,460 --> 06:47:38,420
このボタンにローディング状態を持たせて、クリックするとローディングが終わるまでローディング・スピナーが表示されるようにしたい。

3337
06:47:38,420 --> 06:47:43,620
このローディング・ボタンは、複数の異なる場所に設置する予定なので、別のcファイルにまとめておこう。

3338
06:47:43,620 --> 06:47:52,180
これを別のコンポーネントにして、componentsフォルダのloading
button.tsxを右クリックしてください。

3339
06:47:52,180 --> 06:47:59,940
デフォルトのローディングボタンをエクスポートします。

3340
06:47:59,940 --> 06:48:10,740
ローディングボタンプロップスインターフェースのプロップスが必要です。

3341
06:48:10,740 --> 06:48:17,220
こうすることで、ローディングボタンは、shedcnボタンと同じpropsに加え

3342
06:48:17,220 --> 06:48:24,980
こうすることで、ローディングボタンは、shedcnボタンと同じpropsが使えるようになります。

3343
06:48:24,980 --> 06:48:31,940
このボタンがロード中かどうかを示す状態。

3344
06:48:31,940 --> 06:48:38,420
背景から子供の叫び声が聞こえても、隣には学校があるので無視しましょう。

3345
06:48:39,540 --> 06:48:47,380
ローディング・ボタン・プロップスはここでローディング状態を見つけますが、これらのボタン・プロップスも見つけます。

3346
06:48:47,380 --> 06:48:56,180
無効化されたプロップ、オプションのクラス名、そして残りのすべてのプロップも構造化解除する必要があります。

3347
06:48:56,180 --> 06:48:59,940
これらのプロップは、拡張するボタンのプロップから来ています。

3348
06:48:59,940 --> 06:49:04,420
ここでは、大文字のbボタンを返します。

3349
06:49:06,980 --> 06:49:11,140
ここで、ローディングインジケータをレンダリングしたいのですが、ローディングがtrueの場合のみです。

3350
06:49:11,140 --> 06:49:16,820
ローディングがtrueの場合、以前使用したloader2アイコンをレンダリングします。

3351
06:49:16,820 --> 06:49:23,060
をレンダリングします。

3352
06:49:23,060 --> 06:49:32,340
その隣にprops.childrenを配置します。

3353
06:49:32,340 --> 06:49:35,620
アイコンの隣に表示します。

3354
06:49:35,620 --> 06:49:47,300
ボタンのdisabledプロパティをloadingかdisabledに設定します。

3355
06:49:47,300 --> 06:49:53,140
は無効になりますが、disabledを明示的に渡すと、ボタンも無効になります。

3356
06:49:53,140 --> 06:50:01,220
もちろん、このボタンをクラス名でスタイルします。

3357
06:50:01,220 --> 06:50:06,820
flex item centerと2つのギャップです。

3358
06:50:06,820 --> 06:50:13,460
そして2番目の引数は外部から渡されたクラス名です。

3359
06:50:13,460 --> 06:50:19,300
これによってこのローディングボタンをカスタマイズすることができます。

3360
06:50:19,300 --> 06:50:26,420
残りの小道具をドットドットドット小道具で広げる必要があります。

3361
06:50:26,420 --> 06:50:32,580
ボタンをクリックすると、この美しい機能がすぐに使えるようになる。

3362
06:50:32,580 --> 06:50:38,580
要約ボタンを生成するファイルに戻り、このようなローディングボタンを返そう。

3363
06:50:38,580 --> 06:50:50,260
このインポートを使っても、アイコンが付加されたものを使っても、どちらでもこのアイコンはレンダリングされる。

3364
06:50:50,260 --> 06:50:58,260
アイコンが付加されたものを使っても、どちらでもこのアイコンはレンダリングされる。

3365
06:50:58,260 --> 06:51:05,220
その横にgenerateと表示され、括弧の中にaiと表示される。

3366
06:51:05,220 --> 06:51:13,380
このボタンのテキストで、ここでは通常のシャドボタンと同じようにボタンの小道具を渡すことができる。

3367
06:51:14,100 --> 06:51:21,060
フォームの中でこれを使うので、バリアントをアウトライン・タイプに設定することができます。

3368
06:51:21,060 --> 06:51:26,260
クリックすると、もちろん handle click 関数を呼び出します。

3369
06:51:26,260 --> 06:51:34,100
そして、ローディングの状態が必要で、それが上の使用状態です。

3370
06:51:34,100 --> 06:51:38,740
を保存しておき、ハンドルクリック関数の処理をする前に、これを要約フォームに入れましょう。

3371
06:51:39,780 --> 06:51:45,860
フォームメッセージの下にあるこの入力の隣に置きたい。

3372
06:51:45,860 --> 06:51:56,740
要約フォームでは、要約生成ボタンをレンダリングします。

3373
06:51:56,740 --> 06:52:03,700
というのも、テキストはすでにその中にあるのですが、レジュメデータが必要だからです。

3374
06:52:04,740 --> 06:52:11,140
そして、生成された要約を取得する生成された要約コールバック。

3375
06:52:11,140 --> 06:52:17,220
openaiから後ほど送られてきます。

3376
06:52:17,220 --> 06:52:26,020
form.setValuerでフォームコンポーネントのキーを渡すことができます。

3377
06:52:26,020 --> 06:52:31,780
このフォームに入力するために、サマリー・フィールドだけが用意されている。

3378
06:52:31,780 --> 06:52:37,780
サマリーの文字列をフォームに入力します。

3379
06:52:37,780 --> 06:52:47,940
この値をレジュメデータに転送します。

3380
06:52:47,940 --> 06:52:54,180
ボタンに戻り、このハンドルクリック関数でサーバーアクションを呼び出す必要があります。

3381
06:52:54,180 --> 06:53:02,260
非プレミアムユーザー用のブロックをここに追加します。

3382
06:53:02,260 --> 06:53:10,260
また、その下にtry catchブロックを追加します。

3383
06:53:10,260 --> 06:53:15,460
このエラーを通常通りコンソールにロックし、乾杯メッセージを表示します。

3384
06:53:15,460 --> 06:53:23,940
を表示したいのですが、今回は単純な文字列を説明に使います。

3385
06:53:23,940 --> 06:53:33,700
なぜなら、このボタンをもう一度クリックすればいいからだ。

3386
06:53:33,700 --> 06:53:41,460
finallyブロックではloadingをfalseに設定します。

3387
06:53:41,460 --> 06:53:46,260
そしてtryブロックの最初にtrueをセットする。

3388
06:53:48,420 --> 06:53:56,260
次に、天才的なサーバーアクションを呼び出して、aiのレスポンスを返します。

3389
06:53:56,260 --> 06:54:04,180
単にawait generate summaryを呼び出し、レジュームデータを渡すだけです。

3390
06:54:04,180 --> 06:54:12,660
もし失敗したらcatchブロックで終わり、成功したら次の行で終わる。

3391
06:54:13,380 --> 06:54:19,780
ここでsummary生成コールバックを呼び出し、aiのレスポンスを渡します。

3392
06:54:19,780 --> 06:54:28,020
そして、これをサマリーフォームに渡して、レジュメデータに入れます。

3393
06:54:28,020 --> 06:54:34,660
これを保存しておけばうまくいくはずだ。

3394
06:54:34,660 --> 06:54:42,260
職種はフルスタック開発者で、職歴をひとつ追加しよう。

3395
06:54:43,860 --> 06:54:57,540
ハンバーガーを揚げたり、トイレを掃除したりした。

3396
06:54:57,540 --> 06:55:09,540
ハンバーガーを揚げたり、トイレ掃除をしたりした。

3397
06:55:10,340 --> 06:55:17,140
1990年から2010年まで通った。

3398
06:55:17,140 --> 06:55:28,500
2010年までそこに通っていた。

3399
06:55:28,500 --> 06:55:43,380
次のjs react js cooking steak and 180 kilo
見ての通り、これはjsonを削除しよう。

3400
06:55:43,380 --> 06:55:49,300
これはデバッグのために追加したものです。

3401
06:55:50,340 --> 06:55:58,260
このプリテック全体を削除しましょう。

3402
06:55:58,260 --> 06:56:05,940
このデータをすべてai apiに送り、要約を生成します。

3403
06:56:05,940 --> 06:56:13,540
ご覧の通り、2、3秒で終わりました。

3404
06:56:13,540 --> 06:56:19,700
専属のフルスタック開発者は、多様な経歴を持ち、次のような速いペースの環境での役割を考慮しています。

3405
06:56:19,700 --> 06:56:26,500
ペースの速い環境 next jsやreact jsのようなフレームワーク。

3406
06:56:26,500 --> 06:56:35,300
ユニークな人生経験、災難の達人......ああ、そうだな。

3407
06:56:35,300 --> 06:56:42,260
新しいものを生成することもできるし、aiに渡す命令を微調整することもできる。

3408
06:56:42,260 --> 06:56:49,140
aiに渡す指示を微調整することもできる。

3409
06:56:49,140 --> 06:56:55,940
そして今、マクドナルドと私の他の仕事についても言及している。

3410
06:56:55,940 --> 06:57:03,540
aiに送ったテキストをコンソールで見てみよう。

3411
06:57:03,540 --> 06:57:11,620
これがシステムメッセージで、これがユーザーメッセージです。

3412
06:57:11,620 --> 06:57:18,340
このデータから履歴書の要約を作成してください。

3413
06:57:18,340 --> 06:57:27,140
この日付から現在に至るまでマクドナルドにて。

3414
06:57:27,140 --> 06:57:33,940
この日付からこの日付スキルまで人生の学校で、同様に正しく見えると、これが返された応答です。

3415
06:57:33,940 --> 06:57:40,580
このように、アプリにaiの機能を追加する。

3416
06:57:40,580 --> 06:57:46,500
職歴フォームにも同じことをしたい。

3417
06:57:46,500 --> 06:57:52,740
このフォームのフィールドに入力したいので、バリデーション・ファイルに入りましょう。

3418
06:57:52,740 --> 06:57:59,700
の上にある履歴書の値の下に置きたい。

3419
06:57:59,700 --> 06:58:06,100
スキーマの上に置きたいのですが、もちろん順番は関係ありません。

3420
06:58:06,100 --> 06:58:16,100
職歴スキーマを生成する これはまたZドットオブジェクトで、職歴を生成するときには

3421
06:58:16,100 --> 06:58:20,660
ユーザが自分で書いた説明をapiに送ります。

3422
06:58:20,660 --> 06:58:28,180
ここでは、zドットの文字列である説明を入力します。

3423
06:58:28,180 --> 06:58:35,860
もし空であれば、エラーメッセージが表示されます。

3424
06:58:35,860 --> 06:58:44,340
が必要だが、さらに最小の20を追加して、最小の長さを20にしたい。

3425
06:58:45,060 --> 06:58:52,980
この最小長に達しない場合は、少なくとも20文字でなければならないと表示されます。

3426
06:58:52,980 --> 06:59:00,660
もちろん、最小の長さが20になったら、最小の長さを1つに区切る必要はない。

3427
06:59:00,660 --> 06:59:06,980
フィールドを完全に空のままにすると、このようなエラーメッセージが表示されます。

3428
06:59:06,980 --> 06:59:12,980
入力された文字数が十分でない場合は、このように表示されます。

3429
06:59:12,980 --> 06:59:22,420
ユーザー・エクスペリエンスのために、この方がいいと思う。

3430
06:59:22,420 --> 06:59:35,860
入力cドットがgenerate work experienceスキーマのタイプを推測する。

3431
06:59:35,860 --> 06:59:42,660
aiはこのような職務経験フォームのすべてのデータを含む単一の職務経験を生成します。

3432
06:59:42,660 --> 06:59:51,300
このタイプも作りたい。

3433
06:59:51,300 --> 06:59:57,060
これはこれらのフォームの配列です。

3434
06:59:57,060 --> 07:00:05,700
次のようにして型をエクスポートする。

3435
07:00:06,740 --> 07:00:16,100
cドットは再び就業経験スキーマの型を推論しますが、その後でこの就業経験フィールドにアクセスすることができます。

3436
07:00:16,100 --> 07:00:23,700
フィールドにアクセスできる。

3437
07:00:23,700 --> 07:00:30,980
このスキーマにアクセスするのは、この内部オブジェクトだけの型が欲しいからだ。

3438
07:00:30,980 --> 07:00:37,460
しかし、それぞれの職務経験は未定義にすることができる。

3439
07:00:37,460 --> 07:00:43,940
経験を削除したいが、職務経験は1つにしたい。

3440
07:00:43,940 --> 07:00:51,220
この c dot infer を角括弧で囲み、その前に

3441
07:00:51,220 --> 07:00:58,260
このnullできないユーティリティ型はtypescriptから直接持ってきたものです。

3442
07:00:58,260 --> 07:01:05,780
これはtypescriptから直接持ってきたものだ。

3443
07:01:05,780 --> 07:01:14,340
もう一度最後に角括弧を追加し、ここに番号を渡します。

3444
07:01:14,340 --> 07:01:20,660
この配列のひとつの要素にアクセスする。

3445
07:01:20,660 --> 07:01:26,980
これはタイプスクリプトのマジックで、時間をかけて学ぶ必要がある。

3446
07:01:26,980 --> 07:01:32,580
このような重要なトリックは、私のチュートリアルを見て、それについていくだけで身につけることができます。

3447
07:01:32,580 --> 07:01:38,740
フォームアクションファイルに別のサーバーエンドポイントが必要です。

3448
07:01:38,740 --> 07:01:48,980
という別の非同期関数をエクスポートしましょう。

3449
07:01:48,980 --> 07:01:56,100
この関数に、説明を含むgenerate work experience入力を送信します。

3450
07:01:57,220 --> 07:02:03,700
繰り返しますが、この関数を非プレミアムユーザーのためのリマインダーブロックとして一番上に置きたいと思います。

3451
07:02:03,700 --> 07:02:10,660
次に、入力がバリデーションスキーマに準拠していることを確認するために、入力を渡す必要があります。

3452
07:02:10,660 --> 07:02:18,820
generate work experience schema dot pass to it
入力を渡します。

3453
07:02:18,820 --> 07:02:25,380
このようにして、バックエンドでこの入力が少なくとも20文字以上であることをチェックします。

3454
07:02:26,020 --> 07:02:34,020
もし20文字以上なければエラーとなり、バックティック文字列でシステムメッセージを作成します。

3455
07:02:34,020 --> 07:02:44,820
ここでもまた創造的でなければなりませんが、私はあなたが職務経歴書ジェネレーターaiであることから始めたいと思います。

3456
07:02:46,020 --> 07:02:56,900
あなたのタスクは、ユーザーの入力に基づいて、1つの職務経歴書を生成することです。

3457
07:02:56,900 --> 07:03:04,820
あなたの回答は以下の構造に従わなければなりません。

3458
07:03:06,900 --> 07:03:19,380
入力されたデータから推測できないフィールドは省略できますが、新しいフィールドは追加しないでください。

3459
07:03:19,380 --> 07:03:25,300
だから、これらのプレースホルダーをすべて説明しなければならない。

3460
07:03:25,300 --> 07:03:32,420
aiは十分賢いので、基本的に5歳の子どもでも理解できる。

3461
07:03:32,420 --> 07:03:39,700
その構造は以下のようになるはずだ。

3462
07:03:39,700 --> 07:03:46,740
返したいレスポンスがどのように見えるかをチャットgptに説明する job title

3463
07:03:46,740 --> 07:03:53,940
そして、ここにある角括弧の中の役職名。この角括弧は、このAPIでは特別な意味を持ちません。

3464
07:03:53,940 --> 07:03:59,940
aiが理解できるように、人間に説明するようにこのように書いているだけです。

3465
07:03:59,940 --> 07:04:04,340
しかし、これは特別な意味はなく、プレースホルダーを表しているだけです。

3466
07:04:04,340 --> 07:04:11,940
aiは十分に賢いので、「next the company 」を理解することができる。

3467
07:04:11,940 --> 07:04:20,900
会社名の開始日をコロンで入力してください。

3468
07:04:22,020 --> 07:04:32,420
年、月、日、そして 「only if provided 」と閉じ角括弧を追加します。

3469
07:04:32,420 --> 07:04:37,540
これはaiへの注意書きで、もし日付が指定されていない場合は追加しないようにということです。

3470
07:04:37,540 --> 07:04:46,340
では、終了日と説明も同じようにします。

3471
07:04:47,380 --> 07:04:58,420
そしてここに、箇条書きのフォーマットで最適化された説明が付け加えられる。

3472
07:04:58,420 --> 07:05:06,740
職種から推測されるかもしれません。

3473
07:05:06,740 --> 07:05:13,220
フルスタック開発者であれば、できる限り適切な説明を生成します。

3474
07:05:14,340 --> 07:05:18,500
そしてユーザーメッセージを作成する。

3475
07:05:18,500 --> 07:05:30,740
この説明文から職務経歴を入力してください。

3476
07:05:30,740 --> 07:05:36,660
そして、このバックエンドに送る説明をレンダリングします。

3477
07:05:39,380 --> 07:05:46,580
このバックエンドに送る説明をレンダリングして、ここと同じような完了を生成します。

3478
07:05:46,580 --> 07:05:55,780
aiのレスポンスを貼り付けます。

3479
07:05:55,780 --> 07:06:02,180
ここに戻ってくるのは、このデータを含むはずの文字列です。

3480
07:06:02,180 --> 07:06:10,980
オブジェクトを返したいので、最後に中括弧で囲んでそれぞれのキーの値を返し、それを

3481
07:06:10,980 --> 07:06:18,180
職歴に入れる。

3482
07:06:18,180 --> 07:06:24,820
ポジション、会社の説明、日付を返したい。

3483
07:06:24,820 --> 07:06:31,140
文字列からそれらを取り出すには正規表現を使います。

3484
07:06:31,780 --> 07:06:38,980
を使ってそれぞれのキーの値を見つけ、それを職歴に入れることができる。

3485
07:06:38,980 --> 07:06:46,500
このREGXはchat gbtを使って作成した。

3486
07:06:46,500 --> 07:06:51,780
私の経験からREGXを生成するのにとても優れています。

3487
07:06:51,780 --> 07:06:57,460
下に動画の説明があるので、そこからコピーペーストしてください。

3488
07:06:57,460 --> 07:07:04,260
aiのレスポンス文字列を受け取り、職種を検索し、それをポジションフィールドに入れます。

3489
07:07:04,260 --> 07:07:11,940
他のフィールドも同じです。このbzを保存して、新しいコンポーネントを作りましょう。

3490
07:07:11,940 --> 07:07:22,740
formsフォルダにwork experience button.tsxを生成します。

3491
07:07:24,820 --> 07:07:33,540
プロップ・インターフェースを必要とするデフォルト関数generate work experience
buttonをエクスポートする。

3492
07:07:33,540 --> 07:07:40,100
ここでは履歴書のデータを渡す必要はありません。

3493
07:07:40,100 --> 07:07:48,100
を入力するので、履歴書データを渡す必要はありません。

3494
07:07:51,140 --> 07:07:58,020
ここでは、work experienceタイプである1つのwork
experienceを取得します。

3495
07:07:58,020 --> 07:08:04,980
この関数の戻り値の型はvoidです。

3496
07:08:04,980 --> 07:08:09,540
そして、これらの小道具を再構築します。

3497
07:08:09,540 --> 07:08:12,740
これで完了だ。

3498
07:08:12,740 --> 07:08:19,940
このボタンをクリックすると、入力フィールドのあるダイアログが表示されます。

3499
07:08:19,940 --> 07:08:27,140
この説明では、もちろんshadcnを使います。

3500
07:08:27,140 --> 07:08:33,700
を参照してください。もちろん、私はあなたの手を握り、ガイドします。

3501
07:08:33,700 --> 07:08:41,620
入力ダイアログを表示」という状態を作成し

3502
07:08:42,820 --> 07:08:49,220
そしてshow input dialogueを設定し、use
stateをfalseにして初期化します。

3503
07:08:49,220 --> 07:08:56,580
次に、フラグメントを返します。

3504
07:08:56,580 --> 07:09:02,820
を配置します。

3505
07:09:05,460 --> 07:09:13,220
このボタンをクリックしたら、ダイアログを表示するためにshow input
dialogueをtrueに設定します。

3506
07:09:13,220 --> 07:09:24,020
しかし、スマートフィルとaiはプレミアムユーザー以外にはブロックされています。

3507
07:09:24,020 --> 07:09:33,780
そして、このボタンを閉じます。

3508
07:09:33,780 --> 07:09:43,540
というテキストを括弧で囲む。

3509
07:09:43,540 --> 07:09:48,100
このフラグメントの2番目の要素はダイアログです。

3510
07:09:48,100 --> 07:09:55,700
しかし、これを別のコンポーネントに入れて、機能入力ダイアログを構成します。

3511
07:09:58,740 --> 07:10:07,940
ダイアログを開くかどうかを示すブール値が必要です。

3512
07:10:07,940 --> 07:10:15,060
ダイアログが開かれたかどうかを示すブール値が必要です。

3513
07:10:15,060 --> 07:10:23,220
このダイアログの中でchatgb tierを呼び出すので、ここにもコールバックが必要です。

3514
07:10:23,780 --> 07:10:29,940
このコールバックをコピーして、同じコールバックが必要です。

3515
07:10:29,940 --> 07:10:33,780
そしてもちろん、ここでこれらのプロップを再構築します

3516
07:10:33,780 --> 07:10:45,860
このダイアログはフォームを含み、chatgbtにリクエストします。

3517
07:10:45,860 --> 07:10:51,780
つまり、エラーメッセージを表示することができます。

3518
07:10:53,700 --> 07:11:00,820
また、ここにフォームが必要なので、constフォームを作成します。

3519
07:11:00,820 --> 07:11:06,580
フォームフックを使う。

3520
07:11:06,580 --> 07:11:13,140
このようなフォームをセットアップするのはこれが最後だ。

3521
07:11:15,620 --> 07:11:22,340
リゾルバはいつものようにzotリゾルバである。

3522
07:11:22,340 --> 07:11:30,900
にgenerate work experienceスキーマを渡し、デフォルト値を設定します。

3523
07:11:30,900 --> 07:11:36,580
ここには説明フィールドがあり、デフォルトでは空文字列に設定されています。

3524
07:11:36,580 --> 07:11:43,860
次に、このフォームを送信するときの関数が必要です。

3525
07:11:45,220 --> 07:11:54,260
ここでgenerate work experienceの入力を受け取り、apiを呼び出します。

3526
07:11:54,260 --> 07:12:02,340
catchブロックを入れて、エラーをコンソールにロックする。

3527
07:12:02,340 --> 07:12:08,180
私は怠け者なので、generate summaryボタンからこれをコピーペーストします。

3528
07:12:11,780 --> 07:12:17,700
フォームにはすでにロード状態があるので、ロード状態は必要ありません。

3529
07:12:17,700 --> 07:12:25,700
サーバーアクションを呼び出す必要があるので、tryブロックの中でconst response
equals await generate work experience

3530
07:12:25,700 --> 07:12:31,940
これはアクションファイルからエクスポートした関数で、入力を渡します。

3531
07:12:31,940 --> 07:12:38,580
これはアクションファイルからエクスポートした関数です。

3532
07:12:38,580 --> 07:12:46,100
うまくいけば、完成した就業体験が返ってきます。

3533
07:12:46,100 --> 07:12:54,500
を呼び出し、レスポンスをgenerate work experienceボタンに渡します。

3534
07:12:54,500 --> 07:13:01,140
これが送信時の関数です。

3535
07:13:01,140 --> 07:13:06,980
ダイアログを返す必要があります。

3536
07:13:06,980 --> 07:13:12,900
チャットcnのドキュメントに記載されていますが、それに従ってください。

3537
07:13:12,900 --> 07:13:18,180
ダイアログを表示するopen状態を渡します。

3538
07:13:18,180 --> 07:13:24,340
そして、on open change
callbackは、例えばダイアログの外をクリックしたときにダイアログを閉じることができます。

3539
07:13:24,340 --> 07:13:28,580
ここにダイアログの内容を入れます。

3540
07:13:31,460 --> 07:13:37,220
そしてダイアログ・ヘッダーには、ダイアログのタイトル

3541
07:13:37,220 --> 07:13:45,700
ヘッダー内には、タイトルの下に

3542
07:13:45,700 --> 07:13:54,580
ダイアログの説明文には、この仕事について説明するテキストを少し記述します。

3543
07:13:56,100 --> 07:14:07,700
aiが最適化されたエントリーを生成します。

3544
07:14:07,700 --> 07:14:14,820
ダイアログヘッダーの下に、ダイアログコンテンツの中に

3545
07:14:14,820 --> 07:14:22,100
大文字のフォームを配置します。

3546
07:14:22,740 --> 07:14:28,900
そしてここに小文字のfフォームを置き、submit関数を渡します。

3547
07:14:28,900 --> 07:14:34,340
このon submit関数は今まで使っていませんでした。

3548
07:14:34,340 --> 07:14:41,220
ではこれらの値を自動的に送信していました。

3549
07:14:41,220 --> 07:14:48,020
では送信ボタンをクリックしたときに値を送信します。

3550
07:14:48,020 --> 07:14:54,980
ここでon submitハンドラーを呼び出したいのですが、これを実行するには

3551
07:14:54,980 --> 07:15:00,580
リアクトフックフォームを通して実行する必要があります。

3552
07:15:00,580 --> 07:15:08,500
というのも、react hook
formはバリデーションをトリガーして、この入力からすべての値を取得するからです。

3553
07:15:08,500 --> 07:15:14,340
関数を大文字のsで渡しますが、ここでは括弧を付けずに関数の参照を渡します。

3554
07:15:14,340 --> 07:15:23,860
を渡し、このフォームをスペースy3でスタイルして閉じます。

3555
07:15:23,860 --> 07:15:35,140
フィールドを1つ置き、自己終了タグを付けます。

3556
07:15:35,140 --> 07:15:41,700
を返します。

3557
07:15:43,620 --> 07:15:48,340
でフォームの項目を返します。

3558
07:15:48,340 --> 07:15:57,380
ここにフォームラベルを置きます。

3559
07:15:57,380 --> 07:16:01,620
次にフォームコントロール

3560
07:16:01,620 --> 07:16:07,620
ここに大文字のtのテキストエリアを配置します。

3561
07:16:10,260 --> 07:16:14,500
ここに説明を入力します。

3562
07:16:14,500 --> 07:16:21,940
そして、入力できる内容の例をプレースホルダに設定します。

3563
07:16:21,940 --> 07:16:27,460
バックティック文字列にしたいので、中括弧で囲みます。

3564
07:16:27,460 --> 07:16:38,180
二重引用符で囲み、ちょっとした説明文を書く。

3565
07:16:38,180 --> 07:16:44,260
ドット・ドット・ドットである。

3566
07:16:44,260 --> 07:16:50,100
完璧なスペルに従う必要はない。

3567
07:16:50,100 --> 07:17:05,620
私はグーグル社でソフトウェア・エンジニアとして働いていました。

3568
07:17:05,620 --> 07:17:12,740
また、これはユーザーへのちょっとした説明文であり、オートフォーカスに設定したい。

3569
07:17:12,740 --> 07:17:19,060
フォーム・コントロールの下にはフォーム・メッセージを配置します。

3570
07:17:19,060 --> 07:17:25,620
この入力にはバリデーションがあり、エラーメッセージが表示されます。

3571
07:17:25,620 --> 07:17:32,500
フォームフィールドの下に送信ボタンが必要です。

3572
07:17:32,500 --> 07:17:40,340
フォームの内部ではローディングボタンを使ってローディング状態を作り、タイプをsubmitに設定します。

3573
07:17:40,340 --> 07:17:48,900
に設定し、ローディングプロパをform dotに設定します。

3574
07:17:48,900 --> 07:17:58,340
これを閉じると、テキストが生成され、サブミット値がtrueになります。

3575
07:17:58,340 --> 07:18:03,700
submit関数が実行されている限り、この値はtrueになります。

3576
07:18:03,700 --> 07:18:12,020
すべての入力とaiを開くリクエストはこの入力ダイアログの中で処理されます。

3577
07:18:12,020 --> 07:18:19,300
このスマートフィルボタンをクリックしたときにレンダリングしたいダイアログは、このボタンの下にあります。

3578
07:18:19,300 --> 07:18:29,460
入力ダイアログを配置します。このダイアログはいくつかの小道具を必要とします。

3579
07:18:29,460 --> 07:18:38,100
ダイアログの状態を変更するコールバックが必要です。

3580
07:18:38,100 --> 07:18:44,980
生成されたワークエクスペリエンスを受け取るarrow関数を渡します。

3581
07:18:44,980 --> 07:18:52,340
を呼び出したいので、中かっこを追加します。

3582
07:18:52,340 --> 07:18:59,460
このボタンの生成されたコールバックを呼び出して、フォームに職歴を渡します。

3583
07:18:59,460 --> 07:19:06,500
ダイアログを閉じたいので、次の行でz show input dialogを呼び出します。

3584
07:19:06,500 --> 07:19:14,100
を呼び出してzをfalseに戻しています。

3585
07:19:14,100 --> 07:19:20,100
コンソールにロックして、実際に何が返ってくるか見てみましょう。

3586
07:19:20,100 --> 07:19:25,380
サーバーアクションから、aiのレスポンスをコンソールにロックしたい。

3587
07:19:25,380 --> 07:19:33,780
そして、このボタンをレイアウトに配置します。

3588
07:19:33,780 --> 07:19:40,180
見出しと職種名の間に配置します。

3589
07:19:40,180 --> 07:19:46,980
もちろん、好きな場所に設置することができます。

3590
07:19:46,980 --> 07:19:55,060
には独自のボタンがあり、最初のフォーム・フィールドのすぐ上にあります。

3591
07:19:55,060 --> 07:20:02,500
これを画面の中央に配置するために、flexとjustify centerで別のdivに囲みます。

3592
07:20:02,500 --> 07:20:07,620
そして、ここに職務経験生成ボタン

3593
07:20:08,260 --> 07:20:10,660
にコールバックを渡します。

3594
07:20:10,660 --> 07:20:18,020
このコールバックをform.setValueでフォームに渡します。

3595
07:20:18,020 --> 07:20:23,460
でフォームに渡します。

3596
07:20:23,460 --> 07:20:31,940
を渡す必要がありますが、これは配列なので、インデックスを渡す必要があることを覚えておいてください。

3597
07:20:31,940 --> 07:20:35,300
を渡す必要があるということです。

3598
07:20:36,420 --> 07:20:47,620
react-hook-formはどのフィールドに入力したいかを知る必要があるので、バックティック文字列にしています。

3599
07:20:47,620 --> 07:20:55,140
そして変数プレースホルダーをここに置き、インデックスを置きます。

3600
07:20:55,140 --> 07:21:00,660
コンマを入れ、ここにコールバックから返された職歴を入れる。

3601
07:21:01,380 --> 07:21:08,420
これで職歴がこのフィールドに入る。

3602
07:21:08,420 --> 07:21:14,580
次の職務経験には専用のボタンがあります。

3603
07:21:14,580 --> 07:21:21,940
を入力すると、入力された内容が保持されます。

3604
07:21:21,940 --> 07:21:29,940
と入力してこれを閉じ、職歴1と入力してこれを閉じても、これらのダイアログを開くことができる。

3605
07:21:30,500 --> 07:21:36,500
これらのダイアログは、それぞれ独自のダイアログをレンダリングし、そのダイアログの状態を維持しているため、入力はそのまま維持されます。

3606
07:21:36,500 --> 07:21:43,380
試してみましょう。また、20文字でない場合は、ここで入力の検証を行います。

3607
07:21:43,380 --> 07:21:49,220
このメッセージが表示され、これが完全に空であれば、必要なものが保存される。

3608
07:21:49,220 --> 07:22:00,660
2017年から現在まで、つまり現在私は開発者として働いている。

3609
07:22:00,660 --> 07:22:09,460
next.jsとreact.jsが専門です。

3610
07:22:10,580 --> 07:22:21,860
時々、トイレを掃除していると、ローディングの状態が生成され、2秒も経たないうちに

3611
07:22:21,860 --> 07:22:30,100
おそらく2秒と経たないうちに、このwork experience developer coding
and flow 2017が生成され、これらの箇条書きが追加される。

3612
07:22:30,100 --> 07:22:35,940
というのも、私たちがaiにこうするように指示したからです。

3613
07:22:35,940 --> 07:22:42,020
私たちが指示したことだから、この箇条書きが追加される。

3614
07:22:42,020 --> 07:22:48,820
清掃業務を含む施設のメンテナンス業務に携わりました。

3615
07:22:48,820 --> 07:22:54,580
履歴書を送るなら、プロフェッショナルに聞こえるようにしたいですよね。

3616
07:22:54,580 --> 07:23:04,580
aiから戻ってきたデータをコンソールで見てみましょう。

3617
07:23:05,220 --> 07:23:11,460
もちろん、これらの変更はすべて保存されます。

3618
07:23:11,460 --> 07:23:18,260
レジュメを更新すると、以前のデータが表示されます。

3619
07:23:18,260 --> 07:23:24,420
時間が発生するのは開発時だけだと思います。

3620
07:23:24,420 --> 07:23:30,820
そして次に、既存のレジュメをフェッチして、後で修正できるようにしたい。

3621
07:23:30,820 --> 07:23:39,540
履歴書を読み込んでスラッシュの履歴書ページに表示します。

3622
07:23:39,540 --> 07:23:46,340
非同期関数でデータをフェッチし、履歴書をフェッチするためには、ユーザー・アイデアが必要です。

3623
07:23:46,340 --> 07:23:57,220
いつものように、ここで店員から得たユーザー・アイデアを見つけます。

3624
07:23:57,220 --> 07:24:03,220
エラーになるか、nullを返すことになります。

3625
07:24:03,220 --> 07:24:09,220
しかし、もしユーザーのアイデアがあれば、そのユーザーの履歴書を取得したいわけです。

3626
07:24:09,220 --> 07:24:20,980
そこで、libフォルダからconst resumes equals await
prismaを作成します。

3627
07:24:22,660 --> 07:24:30,100
括弧で囲んだ中括弧で、ユーザーIDを指定します。

3628
07:24:30,100 --> 07:24:37,300
また、prismaではorder.by引数で履歴書の順番を指定することができます。

3629
07:24:37,300 --> 07:24:44,420
ここでは、最後に更新されたものから順番に並べますが、もちろんカスタマイズすることもできます。

3630
07:24:46,660 --> 07:24:54,100
また、職歴と学歴は別々のテーブルにあるので、それらを含める必要があります。

3631
07:24:54,100 --> 07:25:01,540
をinclude引数でクエリに含める必要があります。

3632
07:25:01,540 --> 07:25:07,460
を使用し、履歴書の件数を取得します。

3633
07:25:07,460 --> 07:25:13,300
履歴書モデルにはdot count関数があります。

3634
07:25:13,300 --> 07:25:20,020
このユーザーの履歴書の総数を取得することができます。

3635
07:25:20,020 --> 07:25:25,780
まずレジュメを取得し、それが終わってから件数を取得したいのです。

3636
07:25:25,780 --> 07:25:31,140
この2つの処理を同時に実行したいのです。

3637
07:25:31,140 --> 07:25:38,580
promise.all関数で実行することができる。

3638
07:25:38,580 --> 07:25:47,620
この配列から履歴書とその総数を見つけ、これを promise.all に代入する。

3639
07:25:47,620 --> 07:25:54,660
なぜなら、promise.allは複数のpromiseを並列に実行できるからである。

3640
07:25:54,660 --> 07:26:00,820
角括弧で囲んだ配列を渡す必要がある。

3641
07:26:02,980 --> 07:26:09,460
これをここに貼り付けます。これが最初のpromiseのコンマで、2番目のpromiseもプリズマクエリーです。

3642
07:26:09,460 --> 07:26:18,020
prisma dot resume dot count ですが、ここでも where
フィルタを追加しなければなりません。

3643
07:26:18,020 --> 07:26:25,860
というのも、この特定のユーザーの履歴書の総数を表示したいだけだからです。

3644
07:26:25,860 --> 07:26:32,420
並行して実行し、値を取得します。

3645
07:26:32,420 --> 07:26:43,220
非プレミアムユーザーのクォータをチェックする。非プレミアムユーザーはレジュメを1つしか作成できないからだ。

3646
07:26:43,220 --> 07:26:48,980
というのも、非プレミアムユーザーは履歴書を1枚しか作成できないからです。

3647
07:26:49,860 --> 07:26:57,940
レジュメをスペースy1のdivにレンダリングしたい。

3648
07:26:57,940 --> 07:27:10,100
テキストは3xl、フォントは太字で、履歴書とします。

3649
07:27:10,100 --> 07:27:22,420
段落タグのtotalカラムに合計数をレンダリングし、その値をレンダリングします。

3650
07:27:22,420 --> 07:27:33,540
デフォルトでは縦長のリストを表示しますが、小さな画面やそれ以上の画面では、このsmブレークポイントを使います。

3651
07:27:33,540 --> 07:27:42,580
このsmブレークポイントを利用して、tourと呼ばれるグリッドを1つではなく2つにします。

3652
07:27:42,580 --> 07:27:49,540
このグリッドには2つのカラムを表示しますが、最後のブレークポイントでは3つのカラムを表示します。

3653
07:27:49,540 --> 07:27:56,420
というのも、スペースに余裕があり、lgブレークポイントでは4列を表示したいからです。

3654
07:27:56,980 --> 07:28:03,780
これらのすべてのクラスで、幅をフルに設定し、3つのギャップを与えます。

3655
07:28:03,780 --> 07:28:15,380
そして、resumes.mapでレジュメをレンダリングします。

3656
07:28:15,380 --> 07:28:22,100
コンポーネントを返します。

3657
07:28:22,100 --> 07:28:27,140
というのも、ドロップダウンメニューや削除機能のロジックを入れるからです。

3658
07:28:27,140 --> 07:28:32,580
同じファイルに入れるのではなく、新しいファイルに入れたいのです。

3659
07:28:32,580 --> 07:28:39,700
しかし、このレジュメページのフォルダの中では、resume item.tsxと呼ぶことにします。

3660
07:28:39,700 --> 07:28:46,820
レジュメページはサーバーコンポーネントですが、レジュメアイテムはクライアントコンポーネントである必要があります。

3661
07:28:46,820 --> 07:28:54,580
このディレクティブを一番上に追加し、小道具が必要なコンポーネントをエクスポートします。

3662
07:28:54,580 --> 07:29:03,300
これはサーバから送られてくる履歴書です。

3663
07:29:03,300 --> 07:29:11,060
履歴書サーバーデータ型を作成しました。

3664
07:29:11,060 --> 07:29:17,460
職歴や学歴を含む履歴書です。

3665
07:29:17,460 --> 07:29:23,940
履歴書の値に変換することなく、常にサーバーのデータを取得します。

3666
07:29:23,940 --> 07:29:33,380
履歴書アイテムのプロップスから履歴書を取り出します。

3667
07:29:33,380 --> 07:29:40,420
を作成し、タイムスタンプで作成されたものを表示するか、更新されたものを表示するかを決定します。

3668
07:29:40,420 --> 07:29:48,180
と等しくなければ、このレジュメは更新されたことになります。

3669
07:29:48,180 --> 07:29:54,820
なぜなら、新しいレジュメを作成するとき、この2つのタイムスタンプは同じになるからです。

3670
07:29:54,820 --> 07:30:00,820
しかし、レジュメを更新すると、更新された広告のタイムスタンプは作成された広告のタイムスタンプよりも新しくなります。

3671
07:30:00,820 --> 07:30:04,100
そしてここに

3672
07:30:07,460 --> 07:30:14,660
ここにハードコードされたテキストとしてresume
itemを入れて保存し、ここにレンダリングします。

3673
07:30:14,660 --> 07:30:17,620
再開項目

3674
07:30:17,620 --> 07:30:27,220
レンダリングするにはキーが必要です。

3675
07:30:27,220 --> 07:30:35,700
そしてサーバーのデータであるレジュメそのものを渡す必要があります。

3676
07:30:35,700 --> 07:30:43,620
レジュメアイテムを終了し、スラッシュレジュメページに移動しましょう。

3677
07:30:43,620 --> 07:30:51,060
レジュメの総数は1件ですが、今はハードコーディングされたテキストしかありません。

3678
07:30:51,060 --> 07:30:57,060
外側のdivにたくさんのクラス名を追加します。

3679
07:30:57,060 --> 07:31:06,980
ボーダーを設定し、角を丸くするためにlgを丸くする ボーダーをデフォルトで透明に設定する

3680
07:31:06,980 --> 07:31:16,100
を設定し、hoverモディファイアを追加します。

3681
07:31:16,100 --> 07:31:22,660
これはボーダーをボーダーの色に設定します。

3682
07:31:22,660 --> 07:31:28,260
つまり、デフォルトではボーダーは透明なのですが、ホバーしたときに

3683
07:31:28,260 --> 07:31:33,700
このアイテムにカーソルを合わせると、ボーダーが見えるようになります。

3684
07:31:33,700 --> 07:31:41,220
このdivの中で、このアイテム全体の背景色をbg secondaryに設定します。

3685
07:31:41,220 --> 07:31:49,300
グレーがかった色で、パディングを3にして、これらのクラスをすべて追加すると、もうこのようになります。

3686
07:31:49,300 --> 07:31:55,060
この小さな灰色の四角形にカーソルを合わせると、濃い色の境界線が表示されます。

3687
07:31:55,060 --> 07:32:00,180
このdivの中に、スペースy3で別のdivを置く。

3688
07:32:00,180 --> 07:32:08,740
ここにレジュメのタイトル、説明、タイムスタンプ、そしてプレビューを入れます。

3689
07:32:08,740 --> 07:32:15,300
履歴書自体のプレビューを表示します。

3690
07:32:15,300 --> 07:32:22,980
この次のリンクのhrefはバックティック文字列です。

3691
07:32:22,980 --> 07:32:31,220
という文字列をスラッシュエディタに追加します。

3692
07:32:31,220 --> 07:32:37,700
をurl検索パラメータとして追加します。

3693
07:32:39,060 --> 07:32:46,180
そして、この履歴書のideaをresume.ideaとします。

3694
07:32:46,180 --> 07:32:56,180
これはこのアイテムのリンクである。

3695
07:32:56,180 --> 07:33:07,940
そして、このリンクにはまずこの履歴書のタイトルを入れます。

3696
07:33:07,940 --> 07:33:15,540
タイトルを設定する必要がないので、タイトルなしとします。

3697
07:33:15,540 --> 07:33:24,500
段落のフォントを半ボールドにし、1行を1行に区切ることで、タイトルが複数行にまたがらないようにします。

3698
07:33:24,500 --> 07:33:32,900
ドット・ドット・ドットを行末に追加し、タイトルの下に省略記号を追加します。

3699
07:33:32,900 --> 07:33:39,780
resume.descriptionが定義されているかどうかをチェックします。

3700
07:33:39,780 --> 07:33:47,300
次に、段落を2行でレンダリングします。

3701
07:33:47,300 --> 07:33:55,140
この段落は2行まで表示可能である。

3702
07:33:56,980 --> 07:34:01,460
そして、説明の下にタイムスタンプを表示したいので、別の段落にします。

3703
07:34:01,460 --> 07:34:11,700
テキスト xs 今回は非常に小さなテキストで、前景をミュートする。

3704
07:34:11,700 --> 07:34:22,420
であれば、更新されたと表示され、そうでなければ、作成されたと表示されます。

3705
07:34:22,420 --> 07:34:28,580
このように空白を追加しなければならない。

3706
07:34:28,580 --> 07:34:36,020
というのも、そうしないとjsxがこれを空白として認識しないからです。

3707
07:34:36,020 --> 07:34:43,700
resume.updatedのタイムスタンプとフォーマットの日付はdatefnsから来ています。

3708
07:34:43,700 --> 07:34:52,020
ここでもフォーマット文字列を第2引数として渡す必要がある。

3709
07:34:52,660 --> 07:35:00,260
小文字のdを1つ、日のコンマを1つ、そしてyを4つ。

3710
07:35:00,260 --> 07:35:05,860
hコロンmm......私のように入力してください。

3711
07:35:05,860 --> 07:35:13,860
これを保存すると、画面にはすでに「no title updated on november
12th」と表示されているはずだ。

3712
07:35:13,860 --> 07:35:20,340
この時点で、必要であれば時間を削除して日付だけを残すこともできます。

3713
07:35:20,340 --> 07:35:27,060
をクリックすると、このレジュメのエディターへのリンクが表示され、urlパラメータでレジュメIDが読み込まれます。

3714
07:35:27,060 --> 07:35:34,260
という url パラメータでレジュメIDを読み込みます。

3715
07:35:34,260 --> 07:35:41,460
そのため、このリンクの下に同じhrefで次のリンクを設置します。

3716
07:35:43,140 --> 07:35:48,020
これでエディタが表示されます。

3717
07:35:48,020 --> 07:35:56,500
を追加し、履歴書プレビューをレンダリングします。

3718
07:35:56,500 --> 07:36:06,100
これはレジュメデータを期待するものです。

3719
07:36:06,100 --> 07:36:13,380
はレジュームサーバーのデータだが、マッピング関数はユーティリティからレジュームの値をマッピングしている。

3720
07:36:13,380 --> 07:36:19,700
ファイルからレジューム値にマッピングします。

3721
07:36:19,700 --> 07:36:27,140
プレビューはこのデータをどのようにレンダリングするかを知っています。

3722
07:36:27,140 --> 07:36:33,620
レジュメエディターの小さなプレビューが表示され、その中にあるすべてのコンテンツが表示されます。

3723
07:36:33,620 --> 07:36:40,820
divの大きさに合わせて拡大縮小されます。

3724
07:36:40,820 --> 07:36:47,780
グループにカーソルを合わせると、グループ全体が表示されます。

3725
07:36:47,780 --> 07:36:54,020
このグレーの部分にカーソルを合わせると、グループクラスが追加されます。

3726
07:36:54,020 --> 07:37:02,420
また、トランジション・シャドウを追加して、トランジション・アニメーションを追加します。

3727
07:37:02,420 --> 07:37:09,300
このグレーの部分にカーソルを合わせると、プレビューの影が大きくなります。

3728
07:37:09,300 --> 07:37:16,020
タイトルを変更することもできます。

3729
07:37:16,020 --> 07:37:22,660
1秒半後に自動保存されます。

3730
07:37:22,660 --> 07:37:28,100
タイトルは説明文にも表示されます。

3731
07:37:29,940 --> 07:37:38,660
履歴書の説明文が表示されます。

3732
07:37:38,660 --> 07:37:45,380
タイムスタンプが表示されます。ここにページ分割を追加することもできます。

3733
07:37:45,380 --> 07:37:50,900
ページごとに分けることもできますが、ここでは必要ないと思うので省きました。

3734
07:37:50,900 --> 07:37:56,740
というのも、何千通もの履歴書を作成し、ページ分割する必要はないからです。

3735
07:37:56,740 --> 07:38:02,980
レジュメは数枚から数十枚はあるが、ページ分割するほどの量ではない。

3736
07:38:02,980 --> 07:38:09,140
ページネーションを追加することは可能です。私の他のチュートリアルでも説明しています。

3737
07:38:09,140 --> 07:38:14,900
のチュートリアルがあります。

3738
07:38:14,900 --> 07:38:22,180
のプレビューは、レジュメが本当に長くなってしまった場合に問題があります。

3739
07:38:22,900 --> 07:38:30,420
サマリーを何回かコピーして、もし長くなったらこのdivを大きくしましょう。

3740
07:38:30,420 --> 07:38:38,020
しかし、このプレビューも非常に長いため、このように見えるのです。

3741
07:38:38,020 --> 07:38:44,020
ある時点で変に見える。

3742
07:38:44,020 --> 07:38:49,780
その代わり、下にグラデーションをつけて、そこにもっとコンテンツがあることを示したい。

3743
07:38:49,780 --> 07:38:56,980
レジュメの項目で、レジュメのプレビューをラップするリンクに移動し、このリンクに別のクラスを追加します。

3744
07:38:56,980 --> 07:39:06,100
このリンクにrelativeクラスを追加します。

3745
07:39:06,100 --> 07:39:13,140
はみ出したコンテンツがdivを大きくしないようにする。

3746
07:39:13,940 --> 07:39:19,780
自己クローズタグでdivを囲み、グラデーションを描画します。

3747
07:39:19,780 --> 07:39:30,660
z x zero bottom zeroで絶対配置し、高さを16にします。

3748
07:39:30,660 --> 07:39:40,820
BGグラデーションを階層に設定します。BGグラデーションを階層に設定します。

3749
07:39:42,580 --> 07:39:49,140
そしてここに設定すると、自動的に複数のa4ページに分割され、透明化されます。

3750
07:39:49,140 --> 07:39:55,140
これを保存すると、このような効果が得られます。

3751
07:39:55,140 --> 07:40:01,700
これはこの履歴書の内容がページよりも長いことを示しています。

3752
07:40:01,700 --> 07:40:07,860
この方が、突然内容を切り取ってしまうよりも見栄えが良いのですが、後で履歴書を印刷するときに

3753
07:40:07,860 --> 07:40:14,100
この履歴書は自動的に複数のA4ページに分割され、内容も分割されます。

3754
07:40:14,100 --> 07:40:19,940
また、分割された内容も賢く分割されます。

3755
07:40:19,940 --> 07:40:26,500
レジュメを削除するボタンと、レジュメを印刷するボタンです。

3756
07:40:26,500 --> 07:40:32,020
履歴書の削除はもちろんデータベース操作です。

3757
07:40:32,020 --> 07:40:38,500
サーバー上で実行する必要があります。

3758
07:40:38,500 --> 07:40:45,860
フォルダに入れましょう。

3759
07:40:45,860 --> 07:40:55,380
ディレクティブを追加し、delete resumeと呼ぶ非同期関数をエクスポートします。

3760
07:40:55,380 --> 07:41:02,340
レジュメの名前を文字列で渡します。

3761
07:41:02,340 --> 07:41:08,340
もちろん、ユーザーが自分の履歴書しか削除できないようにしなければなりません。

3762
07:41:08,340 --> 07:41:13,780
そこで、await ofを呼び出して、ロックされたユーザーのアイデアを取得します。

3763
07:41:13,780 --> 07:41:22,660
ユーザーIDが未定義の場合、認証されていないことを確認する。

3764
07:41:22,660 --> 07:41:32,500
つまり、このエンドポイントを呼び出すことはできないので、「ユーザーが認証されていません」というエラーを投げます。

3765
07:41:32,500 --> 07:41:42,180
レジュメを削除する前に、画像を削除したい。

3766
07:41:42,180 --> 07:41:48,500
ファイルストレージにもう使わない画像が残ってしまうのを避けるため、レジュメを削除する代わりに

3767
07:41:48,500 --> 07:41:57,860
レジュメをすぐに削除するのではなく、まずprisma dot resume dot
findでレジュメを取得する必要があります。

3768
07:41:57,860 --> 07:42:05,540
をwhereフィルターに渡す。

3769
07:42:05,540 --> 07:42:14,020
このレジュメが見つからない場合はNULLになります。

3770
07:42:15,620 --> 07:42:18,100
それが存在しない場合は、別のエラーをスローします。

3771
07:42:18,100 --> 07:42:27,380
この場合、削除ボタンをクリックすることはできません。

3772
07:42:27,380 --> 07:42:33,220
しかし、履歴書が存在する場合、その履歴書の写真のURLをチェックします。

3773
07:42:33,220 --> 07:42:40,820
もしそうなら、削除したいので、この操作を待ちます。

3774
07:42:40,820 --> 07:42:51,860
をblobにインポートし、そこにresume dot photo urlを渡すだけです。

3775
07:42:51,860 --> 07:43:00,740
そして最後にprisma dot resume deleteでレジュメそのものを削除します。

3776
07:43:00,740 --> 07:43:08,900
最後にnext slash cacheからインポートしたrevalidate
pathを呼び出します。

3777
07:43:08,900 --> 07:43:18,420
次のスラッシュキャッシュからインポートし、スラッシュレジュメを渡します。

3778
07:43:18,420 --> 07:43:24,340
を呼び出すと、レジュメを表示するページが更新されます。

3779
07:43:24,340 --> 07:43:30,820
これにより、削除されたレジュメはユーザーの画面から消えます。

3780
07:43:30,820 --> 07:43:37,540
レジュメを削除するには、右上にメニューを追加します。

3781
07:43:37,540 --> 07:43:43,540
ボタンでドロップダウンメニューを開きます。

3782
07:43:43,540 --> 07:43:47,620
では、レジュメアイテムコンポーネントに移動してみましょう。

3783
07:43:47,620 --> 07:43:54,340
一番下にmore menuという新しいコンポーネントを作成します。

3784
07:43:54,340 --> 07:44:06,660
メニュープロップが必要な場合、レジュメのidを渡す必要があります。

3785
07:44:06,660 --> 07:44:11,060
削除したいレジュメを知るために、レジュメIDを渡す必要があります。

3786
07:44:11,060 --> 07:44:19,300
いつものようにドロップダウンメニューの設定方法はchat cnのドキュメントに記載されています。

3787
07:44:19,300 --> 07:44:30,500
に記載されているので、それに従ってください。

3788
07:44:32,900 --> 07:44:38,420
これはドロップダウンメニューのためではなく、ダイアログのためです。

3789
07:44:38,420 --> 07:44:43,620
レジュメを削除する前に確認ダイアログを表示したいからです。

3790
07:44:43,620 --> 07:44:48,740
そして、このuseステートで開いている状態を維持します。

3791
07:44:48,740 --> 07:45:00,180
その下に空のフラグメントを返し、ここにドロップを置き、バリアントをghostに設定します。

3792
07:45:00,180 --> 07:45:08,900
スタイリングのために、子プロップとしてこれを設定します。

3793
07:45:08,900 --> 07:45:19,140
このボタンにはlucid reactの縦長のアイコンが入っています。

3794
07:45:19,140 --> 07:45:27,380
そして、このボタンにいくつかのプロップを追加します。

3795
07:45:28,660 --> 07:45:34,900
このボタンにはテキストがないので、アイコンにサイズを設定します。

3796
07:45:34,900 --> 07:45:40,500
ボタンを右上に絶対配置したいので、クラスabsoluteを追加します。

3797
07:45:40,500 --> 07:45:55,540
右0.5、0.5はマージン上0.5、そして不透明度をゼロに設定し、遷移の不透明度を設定します。

3798
07:45:56,340 --> 07:46:04,100
そして、この最後の差分の上にあるグループホバーにカーソルを合わせると、ボタンが表示されます。

3799
07:46:04,100 --> 07:46:11,300
ボタンを表示するには、不透明度を100に戻します。

3800
07:46:11,300 --> 07:46:18,260
この外側の差分には相対配置を追加する必要があります。

3801
07:46:18,900 --> 07:46:28,020
ここに相対的なポジショニングを追加し、moreボタンを最後の

3802
07:46:28,020 --> 07:46:34,980
diffの閉じタグmore menuにレジュメIDを渡す。

3803
07:46:34,980 --> 07:46:43,300
このメニューはレジュメアイテムの上にカーソルを置いた時だけ表示されます。

3804
07:46:43,300 --> 07:46:48,900
レジュメアイテムの上にカーソルを置いた時だけ表示されるのですが、クリックしてもまだ何も起こりません。

3805
07:46:48,900 --> 07:46:57,380
また、このメニューの隣にはdelete trigger drop down menu
contentというテキストが表示されます。

3806
07:46:57,380 --> 07:47:03,460
そして、ここにドロップダウンメニューを1つ追加します。

3807
07:47:03,460 --> 07:47:11,380
ここでは、このゴミ箱のアイコンを4つの大きさで再び明晰なアイコンにしたい。

3808
07:47:13,220 --> 07:47:16,740
そして、その隣に削除というテキストを追加します。

3809
07:47:16,740 --> 07:47:23,940
そして、ドロップダウンメニューにクラス名のプロップを追加します。

3810
07:47:23,940 --> 07:47:28,420
リフレックス・アイテムのセンター＆ギャップ・ツールを使ってアイコンとテキストを正しく配置する。

3811
07:47:28,420 --> 07:47:34,580
そして、このボタンをクリックすると、アイテムを削除するのではなく

3812
07:47:34,580 --> 07:47:41,780
確認ダイアログを表示したいので、z show delete
confirmationと呼び、zをtrueにします。

3813
07:47:41,780 --> 07:47:48,020
をtrueにするとダイアログが表示され、ボタンがあるので、これをクリックすると削除ボタンが表示されます。

3814
07:47:48,020 --> 07:47:54,900
削除をクリックすると、削除確認ダイアログが表示されます。

3815
07:47:54,900 --> 07:48:01,300
というのも、このダイアログはここでしか使わないからです。

3816
07:48:01,300 --> 07:48:11,220
削除確認ダイアログも小道具が必要です。

3817
07:48:11,220 --> 07:48:17,380
ここでもレジュメのアイデアが必要です。

3818
07:48:17,380 --> 07:48:24,020
どのダイアログを削除しなければならないかを知るために、また開いている状態が必要です。

3819
07:48:25,300 --> 07:48:29,780
ダイアログを閉じることができるように、on open changeコールバックが必要です。

3820
07:48:29,780 --> 07:48:34,420
ここでは、新しいオープン状態を取得し、voidを返します。

3821
07:48:34,420 --> 07:48:39,220
そして、これらの小道具をここで再構築する。

3822
07:48:39,220 --> 07:48:46,980
そこで、再開のアイデアをオープンにし、オープンチェンジを行う。

3823
07:48:48,580 --> 07:48:56,420
ここでリクエストを出すが、ここではuseステートを使わず、代わりにuse
transitionを使って乾杯メッセージを出す。

3824
07:48:56,420 --> 07:49:03,700
もしエラーが発生したら、削除が保留されているときのためにローディング・ステートが必要です。

3825
07:49:03,700 --> 07:49:10,260
の代わりに、2番目の値は

3826
07:49:11,300 --> 07:49:19,220
の代わりにuse transitionを使う。

3827
07:49:19,220 --> 07:49:26,660
クライアントコンポーネントから削除サーバーアクションのようなサーバーアクションを呼び出すときのルールです。

3828
07:49:26,660 --> 07:49:33,780
クライアントコンポーネントからdeleteサーバーアクションのようなサーバーアクションを呼び出し、ページを更新するrevalidateパスがある場合、このアクションをラップする必要があります。

3829
07:49:33,780 --> 07:49:40,900
というのも、この保留中の状態にはrevalidateパスの呼び出しが含まれるからです。

3830
07:49:40,900 --> 07:49:46,980
ページが更新されるまで待ちます。

3831
07:49:46,980 --> 07:49:53,780
というのも、ページが更新される前にuse状態がトグルバックしてしまうからだ。

3832
07:49:53,780 --> 07:49:59,940
クライアントコンポーネントからrevalidate
pathでサーバーアクションを呼び出すときは、次のことを覚えておいてください。

3833
07:49:59,940 --> 07:50:05,540
トランジションにラップする必要があります。

3834
07:50:05,540 --> 07:50:11,780
を処理する handle delete という非同期関数を置いた。

3835
07:50:11,780 --> 07:50:20,100
という非同期関数を追加します。

3836
07:50:20,100 --> 07:50:27,140
トランジションの開始には、非同期のエラー関数を渡します。

3837
07:50:28,100 --> 07:50:36,100
ここで実際の削除処理を行う。もし失敗したら、いつものようにtry catchブロックを置く。

3838
07:50:36,100 --> 07:50:42,820
エラーをコンソールにロックし、トースト・メッセージを表示したい。

3839
07:50:42,820 --> 07:50:50,020
メッセージをコピーしてここに貼り付けます。

3840
07:50:50,020 --> 07:50:58,260
tryブロックの中で、サーバーのアクションファイルからawait delete
resumeを呼び出し、そこにresumeのアイデアを渡します。

3841
07:50:58,260 --> 07:51:06,660
を渡します。これが成功したら、open changeを呼び出してダイアログを自動的に閉じます。

3842
07:51:06,660 --> 07:51:13,220
を呼び出し、これをfalseに戻してダイアログを隠します。

3843
07:51:13,860 --> 07:51:20,900
そして、ダイアログそのものを返す必要があります。

3844
07:51:20,900 --> 07:51:24,420
開いた状態を渡します。

3845
07:51:24,420 --> 07:51:28,580
そしてon open changeコールバック

3846
07:51:28,580 --> 07:51:34,180
ここにダイアログの内容を入れます。

3847
07:51:34,180 --> 07:51:39,620
ダイアログのヘッダー。

3848
07:51:42,180 --> 07:51:50,820
ダイアログのタイトルには、レジュメのクエスチョンマークを削除するというタイトルが入ります。

3849
07:51:50,820 --> 07:52:03,620
これはこのレジュメを永久に削除します。

3850
07:52:03,620 --> 07:52:13,540
ダイアログヘッダーの下には、確認ボタンとキャンセルボタンを配置します。

3851
07:52:13,540 --> 07:52:21,300
フッターに配置することができます。

3852
07:52:21,300 --> 07:52:29,700
ボタンにはローディングボタンを使います。

3853
07:52:31,380 --> 07:52:36,740
ボタンをクリックすると、ハンドルの削除を呼び出します。

3854
07:52:36,740 --> 07:52:45,700
ダイアログフッターの 2 番目の要素としてキャンセルボタンを呼び出します。

3855
07:52:45,700 --> 07:52:50,740
パスの呼び出しも含まれるので、ロード中である限り、このボタンにロード状態を表示します。

3856
07:52:50,740 --> 07:52:58,180
ダイアログのフッターの2番目の要素にキャンセルボタンを追加します。

3857
07:52:58,180 --> 07:53:08,580
ダイアログフッターの2番目の要素としてキャンセルボタンを追加します。

3858
07:53:08,580 --> 07:53:15,700
ダイアログを非表示にしたいだけなのです。

3859
07:53:15,700 --> 07:53:23,140
このボタンのテキストにはキャンセルと書いてある。

3860
07:53:23,140 --> 07:53:29,780
このボタンをドロップダウンメニューに追加します。

3861
07:53:29,780 --> 07:53:39,700
このボタンをドロップダウンメニューに入れます。

3862
07:53:39,700 --> 07:53:48,420
メニューの閉じタグの下には、削除確認ダイアログを置きました。

3863
07:53:50,660 --> 07:53:56,900
開いている状態は、削除確認を表示する状態です。

3864
07:53:56,900 --> 07:54:06,580
そして、open changeコールバックでshow delete
confirmationを設定します。

3865
07:54:06,580 --> 07:54:11,380
クリックすると、この確認ダイアログが表示されます。

3866
07:54:11,380 --> 07:54:18,100
レジュメを削除することもできますが、ここでは新しいレジュメを作成します。

3867
07:54:18,740 --> 07:54:23,860
名前を付けて、画像をアップロードして、実際に画像を削除してみましょう。

3868
07:54:23,860 --> 07:54:32,260
履歴書の概要ページに戻ると、新しい履歴書が表示されています。

3869
07:54:32,260 --> 07:54:38,740
編集するために開くことができます。

3870
07:54:38,740 --> 07:54:47,220
この履歴書を削除しましょう。

3871
07:54:47,220 --> 07:54:52,740
ボタンをクリックすると、履歴書の概要ページに戻ります。

3872
07:54:52,740 --> 07:54:59,620
をロード状態にすると、ページは自動的にリフレッシュされる。

3873
07:54:59,620 --> 07:55:07,060
ストレージを覗いてみると、2つ目のファイルがなくなっている。

3874
07:55:07,060 --> 07:55:13,620
印刷機能には、最初にインストールしたreact to printパッケージを使用します。

3875
07:55:13,620 --> 07:55:20,020
これを使うと、divを簡単に印刷することができます。

3876
07:55:20,020 --> 07:55:28,100
を作成し、レジュメアイテムの上部にスクロールします。

3877
07:55:28,100 --> 07:55:36,740
content refを作成し、これをuse refで代入します。

3878
07:55:37,620 --> 07:55:46,020
の戻り値であるfnをprintするためにconst reactを作成します。

3879
07:55:46,020 --> 07:55:52,580
関数を作成します。これはuse react to printフックの戻り値です。

3880
07:55:52,580 --> 07:56:03,300
中括弧はreact to printから手動でインポートします。

3881
07:56:03,300 --> 07:56:12,660
フックを呼び出して、そのフックにレジュメのタイトルを設定します。

3882
07:56:12,660 --> 07:56:19,460
に設定することもできます。

3883
07:56:19,460 --> 07:56:25,940
例えば、このドキュメントを印刷せずにpdfとして保存する場合、ドキュメントタイトルを設定することもできます。

3884
07:56:25,940 --> 07:56:32,420
このドキュメントタイトルはデフォルトではファイル名になると思います。

3885
07:56:32,420 --> 07:56:40,660
レジュメのタイトルに設定することもできますし、未定義の場合はresumeやunnamedなどに設定することもできます。

3886
07:56:40,660 --> 07:56:47,220
そして、このコンテンツリファレンスを履歴書のコンテンツに添付します。

3887
07:56:47,220 --> 07:56:56,900
propsインターフェイスまでスクロールし、content refをプロップとして追加します。

3888
07:56:56,900 --> 07:57:05,700
オプションにし、タイプはhtml div要素のreact dot refにします。

3889
07:57:05,700 --> 07:57:13,940
オプションにすることで、レジュメプレビューを使用するすべての場所でこのrefを添付する必要がなくなります。

3890
07:57:13,940 --> 07:57:20,020
印刷機能も有効にしたいので、content refをオプションにします。

3891
07:57:20,020 --> 07:57:26,660
印刷したいコンテンツに取り付けます。

3892
07:57:26,660 --> 07:57:32,180
この内側のdivに取り付けます。

3893
07:57:32,180 --> 07:57:37,620
プロパティが適用されているので、これにcontent refを適用します。

3894
07:57:37,620 --> 07:57:49,380
さらに、ここにidを設定します。このidはresume preview contentと呼ばれます。

3895
07:57:49,380 --> 07:57:55,460
後でcssでこのdivをターゲットにできるようにするためです。

3896
07:57:55,460 --> 07:58:03,860
このファイルを保存し、レジュメアイテムに戻り、content refをレジュメアイテムに渡します。

3897
07:58:03,860 --> 07:58:09,140
レンダリングする履歴書プレビューにcontent refを渡します。

3898
07:58:09,140 --> 07:58:17,940
contentrefを渡しています。

3899
07:58:17,940 --> 07:58:24,740
を渡しているのか不思議に思うかもしれません。

3900
07:58:24,740 --> 07:58:31,140
という名前をつけていないからです。

3901
07:58:31,140 --> 07:58:36,900
コンテンツrefのように別の名前をつければ、通常のプロップと同じように渡すことができます。

3902
07:58:36,900 --> 07:58:41,940
今話したことを知らない人は無視して構わない。

3903
07:58:41,940 --> 07:58:49,060
このreact to print関数を呼び出す必要がある。

3904
07:58:49,060 --> 07:58:55,780
印刷のトリガーとなるドロップダウンメニュー「more」メニューに、もう1つの項目を追加した。

3905
07:58:55,780 --> 07:59:04,740
このアイテムの下にもう一つドロップダウンメニューを追加します。

3906
07:59:04,740 --> 07:59:15,780
フレックスアイテムのセンターと2つのギャップでクリックハンドラーを追加します。

3907
07:59:16,500 --> 07:59:25,300
これを閉じます プリンターアイコンをレンダリングし、サイズを4にして、その横にテキストを追加します

3908
07:59:25,300 --> 07:59:32,820
このアイテムをクリックしたときにコールバックをトリガーしたいので、別のプロップを追加します。

3909
07:59:32,820 --> 07:59:42,020
を追加する必要があります。

3910
07:59:42,020 --> 07:59:50,100
この関数は何も返さない空のコールバック関数です。

3911
07:59:50,100 --> 08:00:00,020
そして、moreメニューの親にこのコールバックを追加します。

3912
08:00:00,020 --> 08:00:02,980
リアクト・トゥ・プリント関数

3913
08:00:02,980 --> 08:00:10,660
これで印刷はうまくいくはずだ。

3914
08:00:10,660 --> 08:00:18,900
クリックすると印刷ウィンドウが開きます。

3915
08:00:18,900 --> 08:00:25,460
プレビューで見るレジュメのようには見えません。

3916
08:00:25,460 --> 08:00:31,940
cssを追加する必要があります。先にも書きましたが、これはtailwindのクラスではできません。

3917
08:00:31,940 --> 08:00:41,060
グローバルCSSファイルに直接記述します。

3918
08:00:41,060 --> 08:00:47,300
これを設定して、小文字で印刷する必要があります。

3919
08:00:47,300 --> 08:00:55,140
ここでは、レジュメのプレビューコンテンツの先頭にポンド記号を付けます。

3920
08:00:55,140 --> 08:01:02,420
これは、履歴書プレビューの内容に与えたアイデアです。

3921
08:01:02,420 --> 08:01:08,980
を全く同じ綴りにして、印刷するときに両方とも同じ綴りになるようにします。

3922
08:01:08,980 --> 08:01:16,180
印刷するときは、ズームを1に戻す必要があります。

3923
08:01:16,180 --> 08:01:23,300
また、感嘆符を追加する必要があります。

3924
08:01:23,300 --> 08:01:29,060
を追加しなければならない。

3925
08:01:29,060 --> 08:01:37,140
広告メディアの印刷ブロックの下には、再びこの履歴書プレビューコンテンツdivをターゲットにします。

3926
08:01:37,140 --> 08:01:45,220
フォントファミリーをinterに設定します。

3927
08:01:45,220 --> 08:01:52,180
で印刷されます。

3928
08:01:52,180 --> 08:02:00,340
そしてその下にadd pageと書いて、印刷される1ページのスタイルを設定します。

3929
08:02:00,340 --> 08:02:06,820
このようにサイズをa4に設定する。

3930
08:02:06,820 --> 08:02:16,740
そしてここではマージンを0.6センチに設定する。

3931
08:02:18,500 --> 08:02:23,700
では、これを保存してもう一度試してみよう。

3932
08:02:23,700 --> 08:02:33,780
ページサイズがa4になっていることを確認してください。

3933
08:02:33,780 --> 08:02:41,220
実際の履歴書と見比べてみましょう。

3934
08:02:41,220 --> 08:02:47,700
ページ目にも同じことが書かれています。

3935
08:02:47,700 --> 08:02:55,540
の真ん中の要素を分割しないように、この半分を削除します。

3936
08:02:55,540 --> 08:03:02,660
試しにこの部分をもう少し短くして、ページが分割されるかどうか見てみよう。

3937
08:03:02,660 --> 08:03:08,580
途中で教育が途切れてしまうかもしれない。

3938
08:03:10,180 --> 08:03:17,460
いくつの文章を削除しなければならないかわからないが、この半分を削除してみよう。

3939
08:03:17,460 --> 08:03:25,140
そして概要ページに戻ってどうなるか見てみよう。

3940
08:03:25,140 --> 08:03:32,580
ええ、見ての通り、前のページには戻りません。

3941
08:03:32,580 --> 08:03:38,980
というのも、そうしないと見た目がおかしくなってしまうからです。

3942
08:03:38,980 --> 08:03:44,100
例えば色を変更した場合、これも考慮されます。

3943
08:03:44,100 --> 08:03:47,940
ここです

3944
08:03:47,940 --> 08:03:54,580
そして、PDFとして保存することもできます。

3945
08:03:54,580 --> 08:04:04,500
保存すると、印刷する関数で設定したレジュメの名前になります。

3946
08:04:05,060 --> 08:04:15,380
これで履歴書エディタは完璧です。

3947
08:04:15,380 --> 08:04:20,340
stripeを実装して、いくつかの機能をプレミアムサブスクリプションの後ろに隠せるようにしたい。

3948
08:04:20,340 --> 08:04:25,700
そうすれば、あなたは本物のSassを構築する方法を知ることができます。

3949
08:04:25,700 --> 08:04:31,220
ストライプを実装する前に、フロントページを完成させたい。

3950
08:04:31,220 --> 08:04:37,860
今はただの退屈なプレースホルダーページだからだ。

3951
08:04:37,860 --> 08:04:46,100
このトップページのテキストを削除して、コードを書きましょう。

3952
08:04:46,100 --> 08:04:58,740
メインタグをフレックスmin-hスクリーンフレックスコールアイテムセンタージャスティファイセンターでスタイル設定します。

3953
08:04:59,780 --> 08:05:08,100
背景色をbg gray 100にハードコードすることで、明るい色や暗い色を使用しないようにします。

3954
08:05:08,100 --> 08:05:13,860
ダークテーマは実際のアプリ自体にのみ適用され、フロントページには適用されません。

3955
08:05:13,860 --> 08:05:23,540
ダークテーマは実際のアプリ自体にのみ適用され、フロントページには適用されません。

3956
08:05:23,540 --> 08:05:33,460
パディングは、テキストを黒に近いグレー900に設定します。

3957
08:05:33,460 --> 08:05:40,660
mdのブレイクポイントでテキストを開始位置に戻します。

3958
08:05:40,660 --> 08:05:49,940
mdのブレークポイントでは、フレックス行に設定し、lgのブレークポイントでは、次のようにします。

3959
08:05:49,940 --> 08:05:56,260
ギャップは12にします。ビデオを一時停止してすべて入力することもできますし、リポジトリに移動してコピーすることもできます。

3960
08:05:56,260 --> 08:06:01,380
に入ってコピーすることもできます。

3961
08:06:01,380 --> 08:06:08,580
このメインタグの中に

3962
08:06:08,580 --> 08:06:16,020
このdiffにはフロントページのテキストとロゴが含まれます。

3963
08:06:16,020 --> 08:06:23,300
最大幅は65文字で、これは読みやすいテキストに便利です。

3964
08:06:23,300 --> 08:06:30,980
また、スペースy3を追加します。

3965
08:06:30,980 --> 08:06:38,580
ここにロゴをレンダリングする次の画像を入れます。

3966
08:06:40,260 --> 08:06:44,980
広告からロゴをインポートスラッシュアセットロゴpng

3967
08:06:44,980 --> 08:06:56,900
altテキストとロゴをレンダリングし、幅と高さを150ピクセルに設定します。

3968
08:06:56,900 --> 08:07:07,940
そして、mx autoでスタイルを設定し、mdのブレイクポイントでマージンの開始をゼロに設定します。

3969
08:07:07,940 --> 08:07:15,220
msをゼロにすることで、レスポンスの良さを実現している。

3970
08:07:15,220 --> 08:07:25,060
h1の見出しを入れ、ここにマーケティングのテキストを入れます。

3971
08:07:25,060 --> 08:07:32,500
次のテキストはspanで囲む必要があるため、このように空白を追加する必要があります。

3972
08:07:32,500 --> 08:07:40,340
というのも、次のテキストはspanで折り返さなければならないからです。

3973
08:07:40,340 --> 08:07:46,580
spanをクラス名でスタイルし、濃い緑から薄い緑へのグラデーションでこのように色付けしたい。

3974
08:07:46,580 --> 08:07:54,580
濃い緑から薄い緑へと変化するグラデーションカラーでこのように色付けしたい。

3975
08:07:54,580 --> 08:08:01,380
このクラスは左から右へのグラデーションを作ります。

3976
08:08:01,380 --> 08:08:07,940
テキストを透明にします。これはクールなトリックです。

3977
08:08:07,940 --> 08:08:14,100
このグラデーション効果は背景にしか適用されません。

3978
08:08:14,100 --> 08:08:22,100
テキストに適用するには、さらに2つのクラスを追加する必要があります。

3979
08:08:22,100 --> 08:08:29,060
しかし背景はまだテキストの後ろに見えています。

3980
08:08:29,060 --> 08:08:36,820
これはクールなトリックで、このグラデーションをテキストだけに追加し、最後のクラスとしてスパンに追加します。

3981
08:08:36,820 --> 08:08:44,100
さらに、インライン・ブロック・ポジショニングを追加し、このh1タグ全体を

3982
08:08:44,100 --> 08:08:53,700
エクセル用のテキストで、フォントを大きく太くする。

3983
08:08:54,420 --> 08:09:00,740
また、文字と文字の間のスペースを狭くするために、しっかりとドラッグします。

3984
08:09:00,740 --> 08:09:07,460
見出しを大きくし、lgのブレイクポイントでテキストをさらに大きくしたい。

3985
08:09:07,460 --> 08:09:15,380
そして、スクロールマージンを追加するスクロールM20も追加する。

3986
08:09:15,380 --> 08:09:21,780
しかし、このテキストはまだ完成していない。

3987
08:09:21,780 --> 08:09:28,580
完璧なレジュメを作るには、また空白が必要です。

3988
08:09:28,580 --> 08:09:36,100
ちょっと変ですが、これは必要なものです。

3989
08:09:36,100 --> 08:09:46,660
そしてこのh1の下に段落を置きたい。

3990
08:09:46,660 --> 08:09:54,260
をハードコードする。

3991
08:09:54,260 --> 08:10:07,380
ai履歴書ビルダーはプロフェッショナルな履歴書をデザインします。

3992
08:10:07,380 --> 08:10:18,900
と表示されます。jsxはこの一重引用符を嫌うので

3993
08:10:18,900 --> 08:10:25,860
アンパサンドapos（アポストロフィの略）とセミコロンでエスケープする必要があります。

3994
08:10:25,860 --> 08:10:31,140
これで文句は言われなくなったが、シングルクォートはまだ表示されている。

3995
08:10:32,420 --> 08:10:38,980
また、このai履歴書ビルダーのテキストを太字にしたいので、これをスパンで囲みます。

3996
08:10:38,980 --> 08:10:48,180
この部分は段落タグの下の省略形で囲みます。

3997
08:10:48,180 --> 08:10:57,860
半太字ではなく、完全な太字に設定します。

3998
08:10:57,860 --> 08:11:04,180
段落タグの下にボタンのようなリンクが欲しい。

3999
08:11:04,180 --> 08:11:12,500
大文字のbボタン sの子プロップを使ってリンクをレンダリングします。

4000
08:11:12,500 --> 08:11:21,620
サイズをlgに設定し、すぐにバリアントを設定したい。

4001
08:11:21,620 --> 08:11:29,220
をレンダリングします。この次のリンクは単に/resumesを指すだけです。

4002
08:11:29,220 --> 08:11:34,980
ログインしていない場合はログイン画面が表示されます。

4003
08:11:34,980 --> 08:11:44,820
このボタンをグラデーションと同じ色にしたい。

4004
08:11:44,820 --> 08:11:50,500
この色をプレミアム会員登録のボタンにも使いたい。

4005
08:11:50,500 --> 08:11:57,860
ボタンに使いたいので、このボタン・クラスに別のバリアントとして入れましょう。

4006
08:11:57,860 --> 08:12:02,980
ファイルに入って、最初に説明したように、jcnコンポーネントのクールなところは

4007
08:12:02,980 --> 08:12:08,180
つまり、このコードを変更することができるのです。

4008
08:12:08,180 --> 08:12:16,260
たとえば、ここにはさまざまなバリアントがありますが、独自のバリアントを追加することができます。

4009
08:12:17,060 --> 08:12:23,700
そしてここに、このテキストと同じグラデーションにするプレミアムというものを追加します。

4010
08:12:23,700 --> 08:12:31,940
ここでもう一度、bgのグラデーションをrにしてみましょう。

4011
08:12:31,940 --> 08:12:40,100
そこで、まずこれらのクラスをクラス名としてここに書いてから、切り取ってここに移しましょう。

4012
08:12:40,100 --> 08:12:45,140
というのも、なぜかここではテウィンのオートコンプリートが表示されないからだ。

4013
08:12:45,140 --> 08:12:54,180
bgグラデーションをrにすると、緑600から緑400へのグラデーションになります。

4014
08:12:54,180 --> 08:13:03,140
から緑400へのグラデーションを作成します。

4015
08:13:03,140 --> 08:13:12,980
テーマを変更するには、修飾子なしでシャドウを設定します。

4016
08:13:12,980 --> 08:13:23,700
このボタンにカーソルを合わせると、緑600から緑600のスラッシュ90に変わります。

4017
08:13:23,700 --> 08:13:30,260
90は不透明度です。これでボタンが少し明るくなります。

4018
08:13:30,260 --> 08:13:37,460
さらに、このボタンにカーソルを合わせたときに、緑400からスラッシュ90に変更します。

4019
08:13:38,180 --> 08:13:45,060
これがどのように見えるかはすぐにわかるだろう。

4020
08:13:45,060 --> 08:13:52,980
このクラス名を削除して、ボタン・コンポーネントに戻り、ここに貼り付けます。

4021
08:13:52,980 --> 08:14:02,980
これで独自のボタンバリアントができました。

4022
08:14:02,980 --> 08:14:08,900
これをプレミアムバリアントに設定すると、プレミアムボタンができあがりました。

4023
08:14:08,900 --> 08:14:16,900
これはスラッシュレジュメへの単なるリンクですが、次のようなこともできます。

4024
08:14:16,900 --> 08:14:25,940
この履歴書プレビュー画像は、このトップページに置きたいので、トップページに戻り

4025
08:14:25,940 --> 08:14:33,620
このdivはまだmainタグの中にあります。

4026
08:14:33,620 --> 08:14:41,620
履歴書プレビュー画像をインポートする必要があります。

4027
08:14:41,620 --> 08:14:49,940
履歴書プレビューとキャメルケースで呼びます。

4028
08:14:51,540 --> 08:15:00,980
これをインポートして、この下にレンダリングします。

4029
08:15:00,980 --> 08:15:11,620
横幅を600にして、少し小さくします。

4030
08:15:11,620 --> 08:15:17,140
シャドウを追加し、大画面ではこれを少し回転させたい。

4031
08:15:17,700 --> 08:15:23,140
そして、これらの異なるクラスで必要なレスポンス機能はすでに実装されています。

4032
08:15:23,140 --> 08:15:34,020
そこで、この画像にshadow mdというクラスを追加し、軽い影をつけ、さらに大きな画面では

4033
08:15:34,020 --> 08:15:42,100
画面上部のLGブレークポイントでは、これを回転させたいが、任意の値を設定したい。

4034
08:15:42,100 --> 08:15:47,540
ここでも角括弧で囲むことができる。

4035
08:15:47,540 --> 08:15:54,100
カラムがあり、これらの要素を互いの下に配置します。

4036
08:15:54,100 --> 08:15:59,140
githubリポジトリにアクセスしてコピーしてください。

4037
08:15:59,140 --> 08:16:04,980
大きな画面でも完全にレスポンシブになりました。

4038
08:16:06,740 --> 08:16:14,500
中画面では回転しなくなり、超小画面ではフレックスカラムになります。

4039
08:16:14,500 --> 08:16:19,300
を追加しました。

4040
08:16:19,300 --> 08:16:25,540
たった2つの小さな変更のために、さまざまな画面サイズ修飾子を追加したのです。

4041
08:16:25,540 --> 08:16:32,900
完璧な履歴書ではなく、完璧な履歴書を作成する。

4042
08:16:32,900 --> 08:16:41,060
私は文法が得意ではないのですが、ここに追加しましょう。

4043
08:16:41,060 --> 08:16:46,900
ログインしていない場合、このボタンを押すと自動的にログインページに移動します。

4044
08:16:46,900 --> 08:16:52,340
というのも、このアプリのスラッシュ・レジュメの部分は保護されているからだ。

4045
08:16:52,340 --> 08:16:57,620
次にStripeのサブスクリプションを実装します。

4046
08:16:57,620 --> 08:17:04,340
適切なサブスクリプションに加入していない機能を使おうとしたときに、そのことを見逃さないために

4047
08:17:04,340 --> 08:17:10,820
プレミアムまたはプレミアム・プラス・サブスクリプションを購入できるダイアログを表示したい。

4048
08:17:10,820 --> 08:17:17,860
まずはこのダイアログをcomponentsフォルダに作りましょう。

4049
08:17:17,860 --> 08:17:25,060
componentsをクリックしますが、この中にpremium
slashという別のフォルダを作成します。

4050
08:17:25,940 --> 08:17:33,380
model.tsxファイルを入れます。

4051
08:17:33,380 --> 08:17:39,140
整理するために、この2つを同じフォルダに入れます。

4052
08:17:39,140 --> 08:17:44,020
ここからプレミアム・モデルをエクスポートする。

4053
08:17:44,020 --> 08:17:52,740
uiフォルダからshadcnダイアログを返します。

4054
08:17:55,380 --> 08:18:01,860
openの値をハードコードします。

4055
08:18:01,860 --> 08:18:08,500
このダイアログをメインレイアウトに入れましょう。

4056
08:18:08,500 --> 08:18:14,260
ナビバーとプレミアムモデルをレンダリングしてみましょう。

4057
08:18:14,260 --> 08:18:20,580
をレンダリングして、構築中に画面上で確認できるようにしましょう。

4058
08:18:20,580 --> 08:18:27,220
フロントページはメインレイアウトに属さないので、アプリに移動しましょう。

4059
08:18:27,220 --> 08:18:32,660
画面に表示されるはずなので、ここにダイアログのコンテンツを置いてみましょう。

4060
08:18:32,660 --> 08:18:41,140
デフォルトのダイアログより少し大きくするために、最大幅のサイズをxlに変更します。

4061
08:18:41,140 --> 08:18:49,300
保存すると、すでにダイアログが表示されています。

4062
08:18:49,940 --> 08:19:01,220
ダイアログのタイトルは履歴書ビルダーaiプレミアムです。

4063
08:19:01,220 --> 08:19:09,700
ダイアログのヘッダーの下に、まだコンテンツの中にあるスペースy6のdivを置きます。

4064
08:19:11,060 --> 08:19:18,580
で囲み、ここにプレミアム購読を申し込むと以下のような段落を入れます。

4065
08:19:18,580 --> 08:19:24,900
もちろん、これはお好みで変更できます。

4066
08:19:24,900 --> 08:19:33,860
この段落タグの下に、flexで別のdivを配置します。

4067
08:19:36,420 --> 08:19:45,140
そして、ここにもflexを使ったdivを配置します。

4068
08:19:45,140 --> 08:19:57,220
とスペースy5を入れ、左半分のdivを閉じ、右半分のdivを複製します。

4069
08:19:57,220 --> 08:20:02,420
そして両者の間に区切り線を入れたい。

4070
08:20:03,060 --> 08:20:09,060
先ほど履歴書エディタでやったのと同じように、ここにもdivを入れます。

4071
08:20:09,060 --> 08:20:18,980
にボーダーl、水平マージン6を設定します。

4072
08:20:18,980 --> 08:20:29,220
次に左のdivにh3の見出しを入れます。

4073
08:20:30,580 --> 08:20:34,580
そしてフォントを太字にします。

4074
08:20:34,580 --> 08:20:43,540
このh3見出しをコピーして、右側にも配置します。

4075
08:20:43,540 --> 08:20:51,620
プレミアム・プラスと表示されるはずですが、プレミアム・カラーであるグリーンのグラデーションでスタイリングしたいと思います。

4076
08:20:51,620 --> 08:20:59,300
トップページのテキストに追加したものと同じものをここに追加してみましょう。

4077
08:21:01,060 --> 08:21:14,020
グリーン600からグリーン400へ、またbgクリップテキストとテキスト透明化ですね。

4078
08:21:14,020 --> 08:21:21,300
そして、プレミアム・カラーができました。

4079
08:21:21,300 --> 08:21:27,940
このコードを何度も何度も繰り返すのではなく、通常はこれらのテキストを

4080
08:21:27,940 --> 08:21:36,660
コンポーネント関数の上にconst premiumを作成し、文字列の配列を代入します。

4081
08:21:36,660 --> 08:21:42,900
featuresを作成し、文字列の配列を代入します。

4082
08:21:42,900 --> 08:21:55,060
さらに、const premium plus featuresも作成します。

4083
08:21:55,780 --> 08:22:04,580
これも文字列の配列で、無限の履歴書とデザインのカスタマイズが含まれています。

4084
08:22:04,580 --> 08:22:14,820
そして、プレミアム機能の配列を左側のプレミアムh3見出しの下にマッピングします。

4085
08:22:14,820 --> 08:22:24,260
各プレミアム機能を、リスト項目は項目センターと

4086
08:22:24,260 --> 08:22:31,140
のギャップをこのようにリスト項目に反映させます。

4087
08:22:31,140 --> 08:22:41,380
配列をレンダリングするので、これらのリスト項目にキーを追加する必要があります。

4088
08:22:41,380 --> 08:22:46,340
というのも、特徴の名前は一意であるため、ここに同じ特徴が2つ存在することはないからだ。

4089
08:22:48,420 --> 08:22:54,900
リスト項目は項目センターと2つのギャップを反映させます。

4090
08:22:54,900 --> 08:23:02,740
アイコンはlucid reactのチェックマークで、サイズは4です。

4091
08:23:02,740 --> 08:23:11,940
そして色を緑500に設定し、その横に特徴的なテキストをレンダリングします。

4092
08:23:13,300 --> 08:23:21,540
さらに、このulタグのスタイルをlist insights youngにする。

4093
08:23:21,540 --> 08:23:30,580
右側のリストは不要だと思いますが、よくわからないのでそのままにしておきます。

4094
08:23:30,580 --> 08:23:38,820
このulタグを丸ごとコピーして、右側のプレミアム・プラスに貼り付けましょう。

4095
08:23:38,820 --> 08:23:47,540
もちろん、この配列をプレミアム・プラス・フィーチャーに変更すれば、プレミアム・プラス・フィーチャーが表示されます。

4096
08:23:47,540 --> 08:23:53,540
右側にプレミアム・プラス機能、そしてそれぞれの下に

4097
08:23:53,540 --> 08:24:00,020
ストライプチェックアウトに移動するボタンを設置したい。

4098
08:24:00,020 --> 08:24:07,700
uiフォルダの大文字のbボタンです。

4099
08:24:07,700 --> 08:24:16,980
右側のulの下にもボタンを追加します。

4100
08:24:16,980 --> 08:24:26,740
今回はクールなプレミアム・バリアントで、get premium plusと表示します。

4101
08:24:26,740 --> 08:24:33,460
もちろん、このダイアログを常時表示させるわけではありません。

4102
08:24:33,460 --> 08:24:39,700
メインレイアウトにハードコードするのではなく、アンロックしていないプレミアム機能を使おうとするときだけ表示させたいのです。

4103
08:24:39,700 --> 08:24:44,580
しかし、このダイアログを表示したいページはたくさんあります。

4104
08:24:44,580 --> 08:24:49,860
このダイアログ・コンポーネントをコピー・ペーストして、さまざまな場所に貼り付けることもできますが、これは

4105
08:24:49,860 --> 08:24:54,740
ダイアログを表示したり非表示にしたりするuseステートをあちこちに置かなければならない。

4106
08:24:54,740 --> 08:25:01,220
ダイアログを表示したり非表示にしたりするuseステートをあちこちに置かなければならない。

4107
08:25:01,220 --> 08:25:06,740
ダイアログをあらゆる場所からトリガーして、ステート・マネージャーを使ってレイアウトに配置する方法があればいいのですが。

4108
08:25:06,740 --> 08:25:12,020
コンテキストを使うこともできますが、コンテキストの欠点は

4109
08:25:12,020 --> 08:25:18,020
コンテキストを使うこともできますが、コンテキストの欠点は、ダイアログの状態が変わるたびに子ダイアログが再描画されることです。

4110
08:25:18,020 --> 08:25:24,500
アプリ全体を再レンダリングすることになります。

4111
08:25:24,500 --> 08:25:30,260
このチュートリアルで行うのはzustandのようなステート・マネージャーです。

4112
08:25:30,260 --> 08:25:35,860
ステート・マネージャーを使えばもっといろいろなことができる。

4113
08:25:35,860 --> 08:25:41,940
hooksフォルダに新しいフックを作りましょう。

4114
08:25:41,940 --> 08:25:49,940
ここで新規ファイルを右クリック use premium model.ts

4115
08:25:49,940 --> 08:25:57,780
この中でzustandを使います。zustandの使い方はもちろんzustandのドキュメントに書いてあります。

4116
08:25:58,500 --> 08:26:05,460
を参照してください。

4117
08:26:05,460 --> 08:26:11,460
これはtypescriptに必要なものです。

4118
08:26:11,460 --> 08:26:17,140
このフックでは、ダイアログが開いているかどうかを知りたい。

4119
08:26:17,140 --> 08:26:22,420
また、ダイアログを表示したり閉じたりする関数も必要です。

4120
08:26:22,420 --> 08:26:26,980
ここでは、set openと呼び、新しいオープン状態をブール値として渡します。

4121
08:26:26,980 --> 08:26:36,340
そして、フックの名前でconstを作成し、このcreate関数に代入します。

4122
08:26:36,340 --> 08:26:45,540
この関数はzustandからインポートする必要があります。

4123
08:26:45,540 --> 08:26:54,020
ここでは、createの後に、このプレミアムモデルの状態にタイプを設定します。

4124
08:26:54,020 --> 08:26:59,460
括弧を追加してこれを呼び出し、ここでarrow関数を渡します。

4125
08:26:59,460 --> 08:27:07,940
set関数 右矢印 括弧 中括弧 そしてここで状態オブジェクトを返す

4126
08:27:07,940 --> 08:27:14,660
ここで、falseで初期化したopenフィールドと、set openコールバックがあります。

4127
08:27:16,660 --> 08:27:23,140
これは新しいオープン状態を受け取る関数で、この関数を呼び出すと、次のように変更できる。

4128
08:27:23,140 --> 08:27:29,860
このセット関数を介して状態を設定します。

4129
08:27:29,860 --> 08:27:36,900
zustandのドキュメントに記載されている。

4130
08:27:36,900 --> 08:27:43,220
通常の使用状態との違いは、この状態をすべてのアプリで利用できるようにすることだ。

4131
08:27:43,220 --> 08:27:50,660
通常の使用状態との違いは、このフックを使う場所であればどこでも、アプリ全体でこの状態を利用できるということだ。

4132
08:27:50,660 --> 08:27:57,540
どこにいてもアクセスできる場所に保存されている。

4133
08:27:57,540 --> 08:28:04,580
プレミアム・モデル・フックを使う。

4134
08:28:04,580 --> 08:28:14,180
コンポーネントに行き、ここでこのフックを呼び出す。

4135
08:28:14,180 --> 08:28:23,220
を呼び出すと、この中にopen状態とset open関数がある。

4136
08:28:23,220 --> 08:28:30,420
この状態をハードコーディングする代わりに、フックから状態を渡す。

4137
08:28:32,100 --> 08:28:37,060
そして、オープン状態の変更コールバックで、set open stateセッターを呼び出します。

4138
08:28:37,060 --> 08:28:44,500
そして、フックを使うので、履歴書ページにあるuse client

4139
08:28:44,500 --> 08:28:52,020
ディレクティブを追加します。

4140
08:28:52,020 --> 08:28:58,020
ダイアログの表示・非表示を切り替えるために、アプリのどこからでもset
open関数を呼び出すことができます。

4141
08:28:58,020 --> 08:29:04,500
ダイアログを表示したり非表示にしたりすることができます。

4142
08:29:04,500 --> 08:29:10,020
新規レジュメ作成ボタンがありますが、このボタンを押さずに作成できるレジュメの数には限りがあります。

4143
08:29:10,020 --> 08:29:15,860
プレミアム・プラスに加入している場合、ここで制限を超えたかどうかをチェックしたい。

4144
08:29:15,860 --> 08:29:22,260
プレミアムダイアログを表示させたい。

4145
08:29:22,260 --> 08:29:28,020
これはサーバーコンポーネントですが、プレミアムダイアログのフックはクライアントコンポーネントでしか呼び出すことができません。

4146
08:29:28,020 --> 08:29:38,900
そこで、同じフォルダに新しいコンポーネントを作成します。

4147
08:29:38,900 --> 08:29:54,420
ドットtsxでこのコンポーネントをエクスポートします。

4148
08:29:54,420 --> 08:30:04,420
履歴書ボタンの小道具は、新しい履歴書を作成できるかどうかを知るために必要です。

4149
08:30:04,420 --> 08:30:09,380
このページに表示されるレジュメの数と、契約しているレジュメの数を比較します。

4150
08:30:09,380 --> 08:30:16,100
レジュメの作成が許可されているかどうかを知るために、open状態とset open関数が必要です。

4151
08:30:16,100 --> 08:30:18,340
忘れないうちに、これを作りましょう。

4152
08:30:18,340 --> 08:30:30,820
ここでは、フックのconst premium model equals use premium
modelを使います。

4153
08:30:30,820 --> 08:30:36,900
このフックをクライアント・コンポーネントにしよう。

4154
08:30:36,900 --> 08:30:43,860
このフックを使って、can createがtrueかfalseかによって

4155
08:30:43,860 --> 08:30:50,340
ダイアログを表示するボタンか、エディターページに移動するリンクを返します。

4156
08:30:50,340 --> 08:30:58,900
もしcan createがtrueなら、インポートする前に使っていたボタンを返します。

4157
08:31:00,740 --> 08:31:07,220
これは通常のリンクで、スラッシュエディタに移動します。

4158
08:31:07,220 --> 08:31:15,700
履歴書を作成できる場合は通常のリンクですが、履歴書を作成できない場合は

4159
08:31:15,700 --> 08:31:22,100
の代わりにダイアログをトリガーするために、クリックハンドラを持つ別のボタンをレンダリングします。

4160
08:31:22,100 --> 08:31:28,900
プレミアムモデルドットセットオープンと呼び、これをtrueに設定します。

4161
08:31:28,900 --> 08:31:39,140
をtrueに設定してダイアログを表示します。

4162
08:31:39,140 --> 08:31:46,820
ボタンの内容は同じです。

4163
08:31:46,820 --> 08:31:53,380
この2つのボタンの動作が異なるだけです。

4164
08:31:53,380 --> 08:32:01,380
では、このボタンを保存して、レジュメのページに貼り付けましょう。

4165
08:32:01,380 --> 08:32:11,940
レジュメ作成ボタンの前に、後でプロップが作成されることを期待するボタンがあります。

4166
08:32:11,940 --> 08:32:18,020
この値は契約内容に応じて動的に取得されます。

4167
08:32:18,020 --> 08:32:23,940
プレミアム会員なら3つまで、プレミアムプラス会員なら無制限に履歴書を作成できます。

4168
08:32:23,940 --> 08:32:30,020
今のところ、試しに合計数が3未満になるようにハードコードしてみましょう。

4169
08:32:30,020 --> 08:32:39,140
よし、これを保存して、未使用のインポートを削除しよう。

4170
08:32:39,780 --> 08:32:44,900
でもこれはドイツ語のキーボードで、よくわからない。

4171
08:32:44,900 --> 08:32:50,180
このショートカットを使って、未使用のインポートを削除することができます。

4172
08:32:50,180 --> 08:32:57,300
未使用のインポートを削除するショートカットを使ってください。

4173
08:32:57,300 --> 08:33:03,540
このボタンをクリックすると、別のレジュメが作成できるはずです。

4174
08:33:03,540 --> 08:33:10,420
このボタンをクリックすると、別の履歴書を作成できるはずです。

4175
08:33:10,420 --> 08:33:17,780
をクリックして3つ目のレジュメを作成します。

4176
08:33:17,780 --> 08:33:23,700
プレミアムダイアログが表示されます。

4177
08:33:23,700 --> 08:33:29,780
別のレジュメを作成することができます。

4178
08:33:32,820 --> 08:33:37,940
それではいよいよストライプのサブスクリプションを実装してみましょう。

4179
08:33:37,940 --> 08:33:43,540
アプリにstripeを追加するのは無料です。

4180
08:33:43,540 --> 08:33:49,780
stripe.comにアクセスしてください。

4181
08:33:49,780 --> 08:33:56,260
にアクセスしてアカウントを作成し、アカウントにログインしてテストモードが有効になっていることを確認してください。

4182
08:33:56,260 --> 08:34:02,100
テストモードでは、その名の通り、実装をテストすることができます。

4183
08:34:02,100 --> 08:34:07,700
実際の商品を購入することなく、完全なチェックアウトを行うこともできます。

4184
08:34:07,700 --> 08:34:13,460
本番モードに切り替えると、再び商品を作成し、実際の支払いを受けることができます。

4185
08:34:13,460 --> 08:34:19,140
まず最初に、apiキーが必要です。デベロッパーをクリックし、apiキーをクリックすると、このUIが表示されます。

4186
08:34:19,140 --> 08:34:24,820
Stripeがアップデートされると、このUIが変わることがあります。

4187
08:34:25,940 --> 08:34:32,260
まずこの発行可能キーをコピーして、.envファイルにコピーします。

4188
08:34:32,260 --> 08:34:42,660
.envファイルに入って、新しい環境変数を作成します。

4189
08:34:42,660 --> 08:34:51,700
アンダースコアのpublishableキーをコピーして、このキーを貼り付ける。

4190
08:34:52,420 --> 08:35:00,100
シークレットキーであるnext publicをここに追加しないのは、next
publicで.envファイルを作成するからだ。

4191
08:35:00,100 --> 08:35:05,940
を作成し、テスト・モードから公開可能なキーでテスト・モードに切り替えるからです。

4192
08:35:05,940 --> 08:35:12,180
ユーザーには秘密ですが、ストライプのシークレットキーのようにバックエンドでのみ利用可能です。

4193
08:35:12,180 --> 08:35:22,340
のようなバックエンドでのみ利用可能であるべきです。そこで、stripeのダッシュボードに戻り、シークレットキーを見つけることができます。

4194
08:35:22,420 --> 08:35:28,260
ファイルにコピーし、後でテストモードから本番モードに切り替えたときに新しいキーセットを取得します。

4195
08:35:28,260 --> 08:35:34,420
そしてstripeダッシュボードに戻り、プロダクトカタログにプロダクトを作成します。

4196
08:35:34,420 --> 08:35:39,620
将来的には少し変わっているかもしれませんが、このどこかに商品カタログがあります。

4197
08:35:39,620 --> 08:35:42,740
ここで新しい商品を追加します。

4198
08:35:45,060 --> 08:35:54,420
最初の商品はレジュメビルダー・プロ・マンスリーという商品です。

4199
08:35:54,420 --> 08:36:06,020
説明文はai履歴書ビルダーのプレミアム機能のロックを解除します。

4200
08:36:06,020 --> 08:36:12,820
説明文だけですが、画像をアップロードすることもできます。

4201
08:36:12,820 --> 08:36:20,660
もちろん、同じロゴをアップロードすることもできます。

4202
08:36:20,660 --> 08:36:26,180
別のアイコンを作成することもできます。

4203
08:36:26,180 --> 08:36:31,380
一回きりの支払いで一度だけ購入する商品を作成することもできます。

4204
08:36:31,380 --> 08:36:39,220
価格を9.99に設定します。

4205
08:36:39,220 --> 08:36:47,060
課金期間は月単位で、数量は1でよさそうです。

4206
08:36:47,060 --> 08:36:57,300
そして、ai resume builder pro plus monthlyという商品を作成します。

4207
08:36:57,300 --> 08:37:05,380
プロプラスサブスクリプションです。

4208
08:37:05,380 --> 08:37:11,460
もちろん、同じロゴをアップロードすることもできます。

4209
08:37:11,460 --> 08:37:18,820
もちろん、別のアイコンを作成することもできます。

4210
08:37:18,820 --> 08:37:26,900
この商品も追加し、各商品ごとに価格を設定します。

4211
08:37:26,900 --> 08:37:33,300
をクリックすると、商品案が表示されます。

4212
08:37:33,300 --> 08:37:39,300
この点をクリックして、価格アイデアをコピーします。

4213
08:37:39,300 --> 08:37:46,980
これをドットNのファイルにコピーし、次のアンダースコア・パブリックもコピーする。

4214
08:37:46,980 --> 08:37:56,260
フロントエンドでこの値が必要になるからだ。

4215
08:37:56,260 --> 08:38:04,100
monthlyはこのprice ideaをペーストしたものです。

4216
08:38:04,100 --> 08:38:12,820
price idea pro plus monthly をコピーしてここに貼り付けます。

4217
08:38:12,820 --> 08:38:20,740
ここに価格アイデアをコピーして貼り付けます。

4218
08:38:20,740 --> 08:38:26,500
を設定する必要があります。

4219
08:38:26,500 --> 08:38:32,180
本番モードでは異なる環境変数を取得します。

4220
08:38:32,180 --> 08:38:41,300
stripeのダッシュボードに戻り、settingsのsettings
businessに進み、ここでアカウント名を追加します。

4221
08:38:41,300 --> 08:38:46,980
アカウント名を追加する必要があります。

4222
08:38:46,980 --> 08:38:52,660
しかし、これはチェックアウトを使う前に必要なことです。

4223
08:38:52,660 --> 08:38:59,780
stripe
javascriptパッケージをインストールし、libフォルダにstripe.tsという新しいファイルを作成します。

4224
08:38:59,780 --> 08:39:09,220
ここからstripeクライアントをエクスポートします。 const stripe equals
new stripe これをインポートする必要があります。

4225
08:39:09,220 --> 08:39:19,620
を手動でインポートする必要があります。

4226
08:39:19,620 --> 08:39:28,660
で秘密鍵を渡し、ストライプの秘密鍵の名前を指定します。

4227
08:39:28,660 --> 08:39:35,460
ここで未定義になる可能性があるため、NULLでないことを示す演算子に感嘆符を付けなければならない。

4228
08:39:35,460 --> 08:39:41,060
感嘆符を付けなければならないが、これはあまりいいやり方ではない。

4229
08:39:41,060 --> 08:39:46,340
プレミアム・モードでこれらのボタンをクリックすると、チェックアウト・ページが開きます。

4230
08:39:46,340 --> 08:39:52,340
このnullでないアサーション演算子を取り除くことになるが、今はこれでいいだろう。

4231
08:39:52,340 --> 08:39:58,980
デフォルトのストライプをエクスポートして、別のファイルで使えるようにします。

4232
08:39:58,980 --> 08:40:04,900
アクションを作成する必要があります。このアクションでは、stripeクライアントを使ってチェックアウトページを作成します。

4233
08:40:04,900 --> 08:40:10,820
このチェックアウトページを開きたいのです。

4234
08:40:10,820 --> 08:40:17,140
このサーバーアクションを、このダイアログと同じファイルに入れて整理します。

4235
08:40:17,140 --> 08:40:25,700
このプレミアムフォルダを作成したのはこのためです。

4236
08:40:25,700 --> 08:40:31,620
ファイルにして、非同期関数をエクスポートします。

4237
08:40:32,820 --> 08:40:35,140
チェックアウトセッションの作成

4238
08:40:35,140 --> 08:40:44,500
を作成すべきかどうかを知るために、文字列の形で価格のアイデアを渡します。

4239
08:40:44,500 --> 08:40:48,980
プレミアムまたはプレミアム・プラス加入のチェックアウトを行う必要がある。

4240
08:40:48,980 --> 08:40:54,100
というのも、チェックアウトページを作成する前にこの決定をしなければならないからです。

4241
08:40:54,100 --> 08:40:59,060
購入したい商品をチェックアウトページに渡す必要があります。

4242
08:41:00,180 --> 08:41:05,460
そこでまず、現在ロックされているユーザーが必要です。

4243
08:41:05,460 --> 08:41:13,140
からの別のインポートであるcurrent userは、ユーザーIDを返すだけではありません。

4244
08:41:13,140 --> 08:41:18,740
を返すだけでなく、ユーザーオブジェクト全体を返します。

4245
08:41:18,740 --> 08:41:26,020
というのも、このユーザー・オブジェクトに含まれるユーザーのメールアドレスが必要だからだ。

4246
08:41:26,020 --> 08:41:32,660
というのも、この場合はロックインされていないので、新しいエラーを投げてしまうからだ。

4247
08:41:32,660 --> 08:41:42,980
以下では、libフォルダからセッションのコンセッションと等しいawait stripeを作成します。

4248
08:41:42,980 --> 08:41:53,860
dot checkout dot session dot create 括弧 中括弧
今、stripeはさまざまな方法を提供している。

4249
08:41:53,860 --> 08:41:59,460
チェックアウトを実装するには、オーバーレイを追加したり、ウェブサイトに直接何かを埋め込むことができます。

4250
08:41:59,460 --> 08:42:04,340
しかし、最も簡単な方法は、ホストされたチェックアウトを使用することです。

4251
08:42:04,340 --> 08:42:11,140
このようなページを初期化し、そこにリダイレクトしてチェックアウトを行うだけです。

4252
08:42:11,140 --> 08:42:17,140
を行い、stripeがwebhookを呼び出します。

4253
08:42:17,140 --> 08:42:24,500
このチェックアウトページを作成し、これに行アイテムを渡します。

4254
08:42:24,500 --> 08:42:31,060
オブジェクトの配列なので、角括弧で囲み、ここでは価格IDを渡します。

4255
08:42:31,060 --> 08:42:37,700
購入したい商品に対して、フロントエンドからサーバーにこの価格IDを渡します。

4256
08:42:37,700 --> 08:42:46,260
アクションに渡し、数量を1に設定します。

4257
08:42:46,900 --> 08:42:47,940
に設定します。

4258
08:42:47,940 --> 08:42:59,700
daysのurlとinnerはチェックアウト成功後にリダイレクトされる場所です。

4259
08:42:59,700 --> 08:43:05,700
の文字列を追加します。

4260
08:43:05,700 --> 08:43:13,380
これを一番下に置き、next publicと呼びます。

4261
08:43:14,740 --> 08:43:23,860
ベースURLとし、開発時にはこれをhttpコロンスラッシュスラッシュlocalhost
3000に設定します。

4262
08:43:23,860 --> 08:43:31,300
本番環境ではこれを本番用URLに設定します。

4263
08:43:31,300 --> 08:43:40,180
最初のプロセス・ドットとして変数に入れます。

4264
08:43:40,180 --> 08:43:46,420
というのも、ユーザーはメールを変更することができないからです。

4265
08:43:46,420 --> 08:43:53,380
チェックアウトに成功したら、キャンセルURLも渡すことができます。

4266
08:43:53,380 --> 08:44:00,100
チェックアウトをキャンセルした場合にリダイレクトされる場所です。

4267
08:44:00,100 --> 08:44:09,380
次に、カスタマーメールを渡します。

4268
08:44:09,380 --> 08:44:14,340
基本的にアカウントと同じメールアドレスを使うように強制します。

4269
08:44:14,340 --> 08:44:22,580
そして、ここではユーザードットのメールアドレスを渡している。

4270
08:44:22,580 --> 08:44:29,780
このメールアドレスは、基本的に店員ユーザーのプライマリメールです。

4271
08:44:29,780 --> 08:44:37,220
メールアドレスは複数持つことができますが、必要なのは最初の1つだけです。

4272
08:44:37,220 --> 08:44:46,100
中括弧で囲み、ここでメタデータを設定し、ここでユーザーIDをuser dot idに設定します。

4273
08:44:46,100 --> 08:44:53,860
これは何のためかというと、このチェックアウトセッションに店員のユーザーIDを追加するためです。

4274
08:44:53,860 --> 08:45:00,580
バックエンドで成功コールバックを受け取ったときに、どのユーザーを作成または削除しなければならないかがわかります。

4275
08:45:00,580 --> 08:45:08,020
ステータスがわかるので、カスタムテキストで利用規約を渡すことができます。

4276
08:45:08,020 --> 08:45:14,180
このイベントがどのユーザのものかはわかりません。

4277
08:45:14,180 --> 08:45:21,620
オプションで設定できるものもあります。

4278
08:45:21,620 --> 08:45:27,620
チェックボックスを追加することができます。これはオプションで、追加する必要はありません。

4279
08:45:27,620 --> 08:45:33,940
カスタムテキストに利用規約を入力することもできます。

4280
08:45:33,940 --> 08:45:42,900
そしてこれにバックティック文字列の形でメッセージを渡すことができます。

4281
08:45:42,900 --> 08:45:53,460
ai resume buildersの利用規約を読み、これをリンクにすることができます。

4282
08:45:53,460 --> 08:46:00,100
のドキュメントで説明されている。

4283
08:46:00,100 --> 08:46:08,900
基本的にはマークダウン構文です。

4284
08:46:08,900 --> 08:46:20,900
サーバーへのリンクを貼りたいので、ここにもベースURLプロセスドットnドットの次にパブリック・ベースURL

4285
08:46:20,900 --> 08:46:30,260
そしてスラッシュtosを入れると、すぐに設定するサービス利用規約のページになります。

4286
08:46:31,700 --> 08:46:38,420
ai履歴書ビルダーの利用規約を読みました。

4287
08:46:38,420 --> 08:46:46,420
これはリンクであり、利用規約を必須項目に設定することができます。

4288
08:46:46,420 --> 08:46:53,060
このチェックボックスをチェックアウトページに追加し、その下に

4289
08:46:54,420 --> 08:47:01,860
同意の収集と、利用規約を必須に設定することができます。

4290
08:47:01,860 --> 08:47:06,660
このチェックボックスは必須です。

4291
08:47:06,660 --> 08:47:14,660
これで、urlを含むチェックアウトセッションが作成されます。

4292
08:47:14,660 --> 08:47:21,460
もし未定義であれば、何かが間違っていることになります。

4293
08:47:21,460 --> 08:47:30,980
チェックアウトセッションの作成に失敗しました。

4294
08:47:30,980 --> 08:47:39,300
を返し、フロントエンドでこのセッションURLにリダイレクトします。

4295
08:47:39,300 --> 08:47:44,820
にリダイレクトします。

4296
08:47:44,820 --> 08:47:50,500
プレミアムモデルのサーバーアクションを呼び出したいので、プレミアムモデルに戻ります。

4297
08:47:51,220 --> 08:47:58,180
サーバーアクションを呼び出すので、エラーが発生します。

4298
08:47:58,180 --> 08:48:04,420
そのため、use toastフックからtoast関数を取り出します。

4299
08:48:04,420 --> 08:48:14,100
また、ローディング状態のローディングとzローディングが必要です。

4300
08:48:14,100 --> 08:48:23,860
falseで初期化し、その下に非同期関数を作成する。

4301
08:48:23,860 --> 08:48:31,940
プレミアム・ボタンが2つあるので、ここではプレミアム・ボタンまたはプレミアム・プラス・ボタンの価格を渡します。

4302
08:48:31,940 --> 08:48:38,740
プレミアム・プラス・サブスクリプション プレミアム・プラス・サブスクリプション
プレミアム・プラス・サブスクリプション プレミアム・プラス・サブスクリプション
プレミアム・プラス・サブスクリプション

4303
08:48:40,020 --> 08:48:46,260
このボタンをクリックしたときに、クリック・ハンドラーを追加します。

4304
08:48:46,260 --> 08:48:54,020
これがハンドル・プレミアム・クリック機能のトリガーとなる。

4305
08:48:54,020 --> 08:49:03,300
pro monthly process.nf.next public pro
monthly感嘆符が必要です。

4306
08:49:03,300 --> 08:49:08,340
このnon-nullアサーション演算子は後で削除しますが、今はこれでいいでしょう。

4307
08:49:09,700 --> 08:49:17,380
また、ロードがtrueの間はこのボタンを無効に設定したい。

4308
08:49:17,380 --> 08:49:23,380
これはリダイレクトされている間に起こるので、このボタンを再度クリックすることはできません。

4309
08:49:23,380 --> 08:49:33,220
disabledをコピーしてプレミアムプラスボタンに貼り付けます。

4310
08:49:33,220 --> 08:49:41,700
これでプレミアムクリックハンドラ関数が実行され、実際のチェックアウトが行われます。

4311
08:49:41,700 --> 08:49:48,260
チェックアウトを行い、ここではいつものようにtry
catchブロックを置き、潜在的なエラーをコンソールにロックします。

4312
08:49:48,260 --> 08:49:57,220
そしてまたトーストメッセージを表示する。

4313
08:49:58,500 --> 08:50:04,740
ここに貼り付けると、ボタンからクリックハンドラに渡す価格IDが表示されます。

4314
08:50:04,740 --> 08:50:15,060
そしてtryブロックの中でloadingをtrueに設定し、サーバーアクションを呼び出します。

4315
08:50:15,060 --> 08:50:22,820
リダイレクトURLはこのチェックアウトページにリダイレクトされます。

4316
08:50:22,820 --> 08:50:28,260
に、ボタンからクリックハンドラに渡した価格IDを渡します。

4317
08:50:29,220 --> 08:50:35,540
そして、window dot location dot
hrefでこのページにリダイレクトする必要があります。

4318
08:50:35,540 --> 08:50:43,780
これをリダイレクトURLに設定すると、このページにリダイレクトされます。

4319
08:50:43,780 --> 08:50:49,060
チェックアウトのリダイレクト中にユーザーがこのダイアログを閉じないようにしたい。

4320
08:50:49,060 --> 08:50:54,820
このままではダイアログを閉じてもリダイレクトされてしまうからです。

4321
08:50:54,820 --> 08:51:01,780
そのため、ここでは set open を直接渡す代わりに、error 関数を渡しています。

4322
08:51:01,780 --> 08:51:10,500
中括弧をここに追加し、loadingがfalseに等しいかどうかをチェックします。

4323
08:51:10,500 --> 08:51:18,260
の場合のみ、openをopenの状態に設定します。

4324
08:51:18,260 --> 08:51:25,220
trueの場合、バーを表示するかしないかを設定する。

4325
08:51:25,220 --> 08:51:33,060
利用規約のページを設定しよう。これは私が用意したダミーのページだ。

4326
08:51:33,060 --> 08:51:39,300
フォルダに入れ、mainフォルダには入れない。

4327
08:51:39,300 --> 08:51:44,900
appフォルダに直接入れました。

4328
08:51:44,900 --> 08:51:53,460
ナビバーをそこに表示させたいかどうかは、ここに入れるかどうかによります。

4329
08:51:53,460 --> 08:51:59,860
このページへのリンクをビデオの説明文に貼り付けます。

4330
08:51:59,860 --> 08:52:05,220
これは単なるダミーテキストであり、それ以上のものではありません。

4331
08:52:05,220 --> 08:52:10,660
本物のsoftware as a
serviceページを作り、このような法的な文章が必要な場合、実際に生成することができます。

4332
08:52:10,660 --> 08:52:16,020
chatgibitの助けを借りて本当にうまく生成することができます。

4333
08:52:16,020 --> 08:52:21,380
あなたのプロジェクトが大きくなり、よりセキュリティが必要になったら

4334
08:52:21,380 --> 08:52:26,420
このテキストを書くために弁護士を雇いたいかもしれませんが、新しいプロジェクトでは、私はこれを見つけた

4335
08:52:26,420 --> 08:52:31,860
ここでは、ページタイトルを利用規約にしている。

4336
08:52:31,860 --> 08:52:38,420
これが利用規約のページだ。

4337
08:52:38,420 --> 08:52:43,940
このファイル全体はビデオの説明にリンクされていますので、そこからコピーしてください。

4338
08:52:43,940 --> 08:52:52,260
メインフォルダのbillingにあるbillingを右クリックしてください。

4339
08:52:52,260 --> 08:52:59,940
成功スラッシュ page.tsx デフォルトのファンクションページをエクスポートします。

4340
08:53:02,660 --> 08:53:13,860
最大幅7xl mx autoのメインタグを返します。

4341
08:53:13,860 --> 08:53:24,740
py6とテキスト・センター 今のところシンボルはそのままで、ここに3xlと太字で見出しを付けます。

4342
08:53:26,180 --> 08:53:34,980
という見出しをつけ、小さな段落をつけました。

4343
08:53:34,980 --> 08:53:45,300
もちろんカスタマイズも可能です。

4344
08:53:45,300 --> 08:53:51,380
もちろん、カスタマイズすることもできます。

4345
08:53:51,380 --> 08:54:00,260
の次のリンクをレンダリングします。

4346
08:54:00,260 --> 08:54:11,220
スラッシュレジュメの次のリンクをレンダリングします。

4347
08:54:11,220 --> 08:54:17,060
チェックアウトに必要なものはすべて揃いました。

4348
08:54:17,060 --> 08:54:22,980
しかし、チェックアウトはすでにできます。

4349
08:54:22,980 --> 08:54:28,820
というのも、このダイアログをトリガーする唯一の方法だからです。

4350
08:54:28,820 --> 08:54:36,420
今のところ、このダイアログを表示させる方法はこれしかないので、後で別のボタンを追加することにします。

4351
08:54:36,420 --> 08:54:42,660
プレミアムを取得をクリックすると、プレミアムのチェックアウトにリダイレクトされるはずです。

4352
08:54:43,220 --> 08:54:51,620
999 これで間違いないようです。プレミアム・プラスも試してみましょう。

4353
08:54:51,620 --> 08:54:59,460
これはストライプがホストするチェックアウトページです。

4354
08:54:59,460 --> 08:55:11,460
ストライプのテスト用クレジットカードを使用することができます。

4355
08:55:11,460 --> 08:55:20,020
例えば11 26のように未来の日付とzbzのように3つの数字を入力します。

4356
08:55:20,020 --> 08:55:25,220
そしてあなたの名前。これは実際のチェックアウトを行うものではなく、単なるテストカードです。

4357
08:55:25,220 --> 08:55:31,780
このチェックボックスは必須です。

4358
08:55:31,780 --> 08:55:37,380
このチェックボックスがチェックされていない限り、チェックはできません。

4359
08:55:37,380 --> 08:55:43,860
Stripeのダッシュボードでこの顧客を見つけると、私のメールアドレスが表示されます。

4360
08:55:43,860 --> 08:55:50,180
このチェックボックスをクリックすると、実際のチェックアウトができます。

4361
08:55:50,180 --> 08:56:01,140
このチェックボックスをクリックすると、実際のチェックアウトができます。

4362
08:56:01,140 --> 08:56:07,220
まだアプリにプレミアムサブスクリプションを実装していませんが、この顧客はすでにストライプダッシュボードの

4363
08:56:07,780 --> 08:56:13,220
私のメールアドレスは、私がアプリにログインするために使用したメールアドレスです。

4364
08:56:13,220 --> 08:56:19,860
アプリにログインするために使用したメールアドレスです。

4365
08:56:19,860 --> 08:56:26,500
アプリで購読を有効にする方法を見つける必要があります。

4366
08:56:26,500 --> 08:56:31,860
後で新しいものを買うことができるように、ここで定期購読の解約をクリックする。

4367
08:56:31,860 --> 08:56:39,220
をクリックすると、すぐにキャンセルされます。

4368
08:56:39,220 --> 08:56:45,540
テスト用アカウントのデータをすべて削除することもできます。

4369
08:56:45,540 --> 08:56:53,860
あるいは、developersからworkbench
overviewerに行き、ここでテストデータを確認することができます。

4370
08:56:53,860 --> 08:56:59,140
そして、サブスクリプションやユーザーをすべて削除することができます。

4371
08:56:59,140 --> 08:57:04,660
を削除することができます。

4372
08:57:04,660 --> 08:57:11,300
また、クレジットカード以外の支払い方法を有効にすることもできます。

4373
08:57:11,300 --> 08:57:17,060
また、クレジットカード以外にもさまざまな支払い方法を利用することができます。

4374
08:57:17,060 --> 08:57:21,940
エラーメッセージをテストすることもできる。

4375
08:57:21,940 --> 08:57:29,300
様々な国のカードがあります。

4376
08:57:29,300 --> 08:57:36,660
エラーになるカードや他の支払い方法もありますが、最も一般的なのはこの4242カードです。

4377
08:57:36,660 --> 08:57:43,540
このカードは普通のクレジットカードで、テストモードではいつでも使えます。

4378
08:57:43,540 --> 08:57:50,020
このワークベンチを閉じることができます。

4379
08:57:50,660 --> 08:58:00,180
ビジネス、そしてブランディングと、ここでは様々なカスタマイズが可能ですが、例えば

4380
08:58:00,180 --> 08:58:06,420
ロゴやアイコンをアップロードしたり、色を変えたりすることもできる。

4381
08:58:06,420 --> 08:58:11,540
タブの種類はこちらで確認できます。

4382
08:58:11,540 --> 08:58:16,820
領収書とカスタマーポータルをカスタマイズします。

4383
08:58:17,460 --> 08:58:23,300
インボイスページの見た目など、いろいろ遊べます。

4384
08:58:23,300 --> 08:58:28,740
このチェックアウトページを独自ドメインに移したい場合は、このようにすることもできます。

4385
08:58:28,740 --> 08:58:33,060
これは有料機能です。stripeのドキュメントに説明があります。

4386
08:58:33,060 --> 08:58:40,180
そうでなければ、stripeのドメインがありますが、それも問題ありません。

4387
08:58:40,180 --> 08:58:45,700
チェックアウトを処理する前に、NULLでないアサーション演算子を取り除きたい。

4388
08:58:45,700 --> 08:58:51,140
環境変数に使用したnullでないアサーション演算子を取り除きたい。

4389
08:58:51,140 --> 08:58:58,660
これは未定義になり、コードがエラーを投げるか、もっと悪いことに誤動作してしまう。

4390
08:58:58,660 --> 08:59:04,980
型安全な環境変数を得るには、このt3 n番目のパッケージを使えばいい。

4391
08:59:04,980 --> 08:59:12,180
zotを使って環境変数を検証し、その値を型安全な方法で取得することができる。

4392
08:59:12,180 --> 08:59:18,100
必要なパッケージはすべてインストール済みです。

4393
08:59:18,100 --> 08:59:26,500
srzフォルダに直接nth.tsを置きます。

4394
08:59:26,500 --> 08:59:38,260
ここで@t3/oss/nth/nextjsからインポートし、この中にcreate
nth関数があります。

4395
08:59:39,060 --> 08:59:43,940
そしてzot import z from zotも必要です。

4396
08:59:43,940 --> 08:59:51,620
そしてnthというconstをエクスポートし、このcreate nth関数に代入します。

4397
08:59:51,620 --> 08:59:58,980
括弧 中括弧 そしてここにすべての環境変数を記述します。

4398
08:59:58,980 --> 09:00:03,860
しかし、ここに置くサーバー変数と

4399
09:00:05,220 --> 09:00:13,220
まずはpostgresのurlをここに入力し

4400
09:00:13,220 --> 09:00:21,540
zotを使って検証スキーマを割り当てます。

4401
09:00:21,540 --> 09:00:28,180
この値が空でないことを確認します。

4402
09:00:28,180 --> 09:00:33,940
基本的に、nextpackを持たない環境変数はすべてclock secretとして呼び出されます。

4403
09:00:34,660 --> 09:00:40,980
公開されているものではなく、ここにあるblobを、そしてそれぞれの後に

4404
09:00:40,980 --> 09:00:49,380
コロンで囲み、c.string.min1で検証する。

4405
09:00:49,380 --> 09:00:58,740
すべての環境変数に対してこれを行う。

4406
09:00:58,740 --> 09:01:08,420
このクロックシークレットは公開されたものではなく、openai
apiキーの読み書きトークンの塊である。

4407
09:01:08,420 --> 09:01:12,340
そしてストライプシークレットキー

4408
09:01:12,340 --> 09:01:18,660
これが文字列で、これがクライアント変数だ

4409
09:01:18,660 --> 09:01:28,340
ここに、次のパブリックな店員用公開キー、月次キー、プロプラス月次キーを入れます。

4410
09:01:29,540 --> 09:01:35,540
そして私たちのベースは、urlでデザインする他のもののために2、3回対応します。

4411
09:01:35,540 --> 09:01:42,660
デザインアップ url stripe発行可能キー

4412
09:01:42,660 --> 09:01:47,060
2つの価格ID

4413
09:01:49,380 --> 09:02:00,020
プロ月次とプロプラス月次と私たちの基本URLと私たちはまた、より具体的なバリデーションを使用することができます。

4414
09:02:00,020 --> 09:02:07,700
文字列の最小長は1ですが、urlでなければなりません。

4415
09:02:07,700 --> 09:02:14,580
というのも、ベースとなるurlはurl構造に従う必要があるからです。

4416
09:02:14,580 --> 09:02:23,540
がurlのように見えることを確認する。

4417
09:02:23,540 --> 09:02:30,100
をカーソルに割り当てなければならず、ここではこれらのパブリック環境変数をすべて手動で割り当てなければならない。

4418
09:02:30,100 --> 09:02:35,460
サーバー変数については、何らかの理由でこれを行う必要はありませんが、これもドキュメントに記載されています。

4419
09:02:35,460 --> 09:02:40,900
ドキュメントに記載されている。

4420
09:02:40,900 --> 09:02:47,860
右コピーして、対応するプロセス・ドットn番目の変数に代入する。

4421
09:02:47,860 --> 09:02:58,980
このコンマを閉じて、これを6回複製する。

4422
09:02:58,980 --> 09:03:07,380
この他の変数についても、常に最初のキーと2番目のサインアップURLを変更する。

4423
09:03:09,060 --> 09:03:15,300
発行可能なストライプキー 価格ID

4424
09:03:15,300 --> 09:03:25,300
プロ・プラス・マンスリー、そして基本URL。

4425
09:03:25,300 --> 09:03:32,020
そして今、どこでもプロセスドットnthを直接使っていますが、代わりにこのnthオブジェクトを使いたいと思います。

4426
09:03:32,900 --> 09:03:40,820
リップストライプのファイルではプロセスドットを削除し、n番目とドットnだけを残しています。

4427
09:03:40,820 --> 09:03:47,540
を残し、型安全性を確保する。

4428
09:03:47,540 --> 09:03:53,540
つまり、型安全性が得られるということだ。

4429
09:03:53,540 --> 09:03:58,980
環境変数がない場合、これをundefinedに設定する代わりにエラーを投げるからだ。

4430
09:03:59,940 --> 09:04:08,500
次に、プレミアム・アクション・ファイルでprocess dot nを呼び出す。

4431
09:04:08,500 --> 09:04:15,860
をn番目に変更し、ここでも型の安全性を確保する。

4432
09:04:15,860 --> 09:04:27,780
プレミアムモデルでもprocess dot nthを2つのボタンに呼び出しています。

4433
09:04:28,580 --> 09:04:35,300
というわけで、ここでもプロセスのドットimportドットnthを取り除き、非挿入演算子を削除する。

4434
09:04:35,300 --> 09:04:42,900
これで型安全環境変数ができた。

4435
09:04:42,900 --> 09:04:50,020
プロセス・ドットnthを呼び出した場所が他にあるか見てみよう。

4436
09:04:50,020 --> 09:04:56,900
ここではノードnをチェックするだけなので、自分で設定する必要はありません。

4437
09:04:56,900 --> 09:05:03,300
つまり、ここでは保護する必要がないのだ。

4438
09:05:03,300 --> 09:05:08,900
サブスクリプション情報をどこかに保存する必要があります。

4439
09:05:08,900 --> 09:05:15,220
別のモデルが必要なので、スキーマ・ドット・プリズマ・ファイルの一番下に追加しましょう

4440
09:05:15,220 --> 09:05:23,460
user
subscriptionというモデルです。各エントリにはいつものように一意なidが必要です。

4441
09:05:26,020 --> 09:05:31,860
サブスクリプションがどのユーザーに属しているかも知る必要があるので、ユーザーIDをここに保存します

4442
09:05:31,860 --> 09:05:38,580
に格納し、次に異なる値の束を格納します。

4443
09:05:38,580 --> 09:05:47,780
これも文字列で一意でなければなりません。

4444
09:05:47,780 --> 09:05:55,140
の値にストライプから取得したデータを記録することもできます。

4445
09:05:55,140 --> 09:06:00,980
サブスクリプションを購入すると、後でWebhookでそれらを受け取ることになります。

4446
09:06:00,980 --> 09:06:05,860
このデータの一部はデータベースに保存したい。

4447
09:06:05,860 --> 09:06:11,140
どのようなデータが返ってくるかは、stripeのドキュメントを参照してください。

4448
09:06:11,140 --> 09:06:18,660
どのようなデータが返ってくるかは、stripeのドキュメントを参照してください。

4449
09:06:18,660 --> 09:06:24,420
もちろん、コンソールにストライプから取得したデータを記録することもできる。

4450
09:06:24,420 --> 09:06:34,180
ストライプの価格も必要で、これも文字列である。

4451
09:06:34,180 --> 09:06:44,500
であるが、今回は一意ではなく、さらに2つのストライプ現在の期間終了が必要である。

4452
09:06:44,500 --> 09:06:51,460
これはサブスクリプションが更新される日付であり、キャンセルする場合はこの時点で終了します。

4453
09:06:51,460 --> 09:06:58,500
購読をキャンセルした場合も知る必要があります。

4454
09:06:58,500 --> 09:07:07,860
cancel at period end
これはブール値で、これがtrueの場合、購読はこの日付で終了します。

4455
09:07:07,860 --> 09:07:16,180
そうでなければ、次の支払期限はこの日です。

4456
09:07:16,740 --> 09:07:24,420
このテーブルの名前を変更したい。

4457
09:07:24,420 --> 09:07:32,740
もうひとつ、期間とデフォルト値でキャンセルを設定したい。

4458
09:07:32,740 --> 09:07:39,140
デフォルト値をfalseに設定し、明示的にtrueを渡した場合のみtrueに設定されます。

4459
09:07:39,140 --> 09:07:46,820
がtrueに設定されるようにする。

4460
09:07:46,820 --> 09:07:55,780
prisma db
pushで、新しいprismaクライアントと新しいテーブルをデータベースに生成します。

4461
09:07:55,780 --> 09:08:02,500
npm run devを再度実行し、新しい関数を追加します。

4462
09:08:02,500 --> 09:08:08,820
subscription.tsという名前でlibフォルダに入れよう。

4463
09:08:08,820 --> 09:08:15,540
という名前のlibフォルダに入れましょう。

4464
09:08:15,540 --> 09:08:23,860
subscriptionレベル これは関数になりますが、この関数をconstに格納します。

4465
09:08:23,860 --> 09:08:30,500
この関数はreactのキャッシュ関数にラップすることができる。

4466
09:08:30,500 --> 09:08:37,460
jsのチュートリアルで取り上げています。

4467
09:08:37,460 --> 09:08:44,740
データベースへの呼び出しは1回で済みます。

4468
09:08:44,740 --> 09:08:50,900
ページへのリクエストは1回だけです。

4469
09:08:50,900 --> 09:08:56,980
ナビバーとページの2カ所で1つのページをレンダリングするとします。

4470
09:08:58,020 --> 09:09:03,620
すると、このキャッシュ関数はこのリクエストを重複排除して、一度に1つのリクエストしかできないようにします。

4471
09:09:03,620 --> 09:09:09,540
これは絶対に必要というわけではありませんが、便利です。

4472
09:09:09,540 --> 09:09:16,820
しかし、ここでサブスクリプションオブジェクトを返す代わりに

4473
09:09:16,820 --> 09:09:22,820
サブスクリプションレベルを文字列で返したいだけです。

4474
09:09:22,820 --> 09:09:30,260
このために、サブスクリプションレベルという型をエクスポートします。

4475
09:09:30,260 --> 09:09:40,340
の3つのオプションがあります。

4476
09:09:40,340 --> 09:09:47,220
アプリ全体でこれらの値を使用し、どの機能をアンロックするかを決定します。

4477
09:09:48,180 --> 09:09:53,220
この関数はユーザーIDを必要とし、この特定のユーザーのサブスクリプションを取得します。

4478
09:09:53,220 --> 09:10:01,780
この関数はsubscription level型のプロミスを返す。

4479
09:10:01,780 --> 09:10:07,700
戻り値の型を明示的に追加することで、このarrow関数で型の安全性を確保できる。

4480
09:10:07,700 --> 09:10:13,140
を返す必要があることを確認します。

4481
09:10:13,140 --> 09:10:18,180
この関数からサブスクリプション・レベルを返さなければならないことを確認します。

4482
09:10:18,180 --> 09:10:24,340
サブスクリプションレベルを返さない分岐が発生しないようにします。

4483
09:10:24,340 --> 09:10:32,100
このモデルが利用可能でない場合は、必ず

4484
09:10:32,100 --> 09:10:41,700
テーブルを作成するためにnpx prisma db pushを実行してください。

4485
09:10:41,700 --> 09:10:50,180
サブスクリプションを見つけたいが、この期間終了値をユーザーが直接ここに入力することも可能である。

4486
09:10:50,180 --> 09:10:56,420
しかし、多くの場合、ユーザーIDはすでに持っているので、それを引数として渡します。

4487
09:10:56,420 --> 09:11:04,100
サブスクリプションが未定義の場合、我々はサブスクリプションを持っています。

4488
09:11:06,100 --> 09:11:13,700
が未定義の場合、私たちは無料プランを利用していることになります。

4489
09:11:13,700 --> 09:11:19,060
これは、何らかの理由でサブスクリプションを削除しなかったことを意味します。

4490
09:11:19,060 --> 09:11:24,180
そうでなければこの値は更新されているはずなので、2つ目の条件として

4491
09:11:24,180 --> 09:11:34,420
サブスクリプションドットストライプの現在の期間終了値が現在の日付の価格より小さいこと

4492
09:11:35,380 --> 09:11:42,020
に等しい場合は、ドットnファイルを使用する。

4493
09:11:42,020 --> 09:11:49,380
もしこれより下になったら、サブスクリプションがあるかどうかをチェックする必要がある。

4494
09:11:49,380 --> 09:11:58,820
プロ・プランかプロ・マンスリー・プランかをチェックする必要がある。

4495
09:11:59,780 --> 09:12:09,860
に等しい場合、ドットnファイルの次のパブリック・プライス・アイデア・プロ・マンスリーを使用する。

4496
09:12:09,860 --> 09:12:20,740
プロ・プランの場合、ここではプロを返し、同様にサブスクリプション・ドットストライプの価格アイデアが

4497
09:12:21,940 --> 09:12:33,380
がpro plus monthlyであればpro plusを返し、それ以下であれば他の

4498
09:12:33,380 --> 09:12:39,460
この場合、エラーをスローします。

4499
09:12:39,460 --> 09:12:50,020
無効なサブスクリプションは発生しないはずです。

4500
09:12:50,020 --> 09:12:57,620
を取得し、メインフォルダに置く単純な文字列を返します。

4501
09:12:57,620 --> 09:13:03,860
この関数を複数回呼び出すと、1つのページが自動的に重複排除されます。

4502
09:13:03,860 --> 09:13:09,700
サーバーコンポーネントでは、このデータを取得するためにこの関数を直接呼び出すことができます。

4503
09:13:09,700 --> 09:13:14,660
クライアント・コンポーネントではこの関数を使用できません。

4504
09:13:14,660 --> 09:13:21,300
バックエンドでしかできないことです。

4505
09:13:21,300 --> 09:13:27,860
クライアントコンポーネントで使用することはできません。

4506
09:13:27,860 --> 09:13:35,460
ルートレイアウトで一度だけこれを取得し、それをすべての子コンポーネントがサブスクリプションを利用できるようにするコンテキストプロバイダーに置くことです。

4507
09:13:35,460 --> 09:13:41,300
コンテキスト・プロバイダが必要です。

4508
09:13:42,180 --> 09:13:51,380
これをメインフォルダに入れ、サブスクリプション・レベル・プロバイダ.tsxと呼びます。

4509
09:13:51,380 --> 09:14:01,700
これはクライアント・コンポーネントでなければならず、同じ名前のデフォルト関数をエクスポートします。

4510
09:14:01,700 --> 09:14:08,980
ここで作成するのは、コンテキスト・プロバイダです。

4511
09:14:08,980 --> 09:14:14,420
クロック・プロバイダとテーマ・プロバイダもコンテキスト・プロバイダです。

4512
09:14:14,420 --> 09:14:20,580
コンテキスト・プロバイダについてゼロから説明するのは避けたい。

4513
09:14:20,580 --> 09:14:28,100
というconstが必要です。

4514
09:14:28,100 --> 09:14:37,140
サブスクリプションレベルのコンテキストが必要です。

4515
09:14:37,140 --> 09:14:44,820
そのため、フォールバック値としてundefinedが必要です。

4516
09:14:44,820 --> 09:14:53,380
undefinedで初期化します。

4517
09:14:53,380 --> 09:14:59,460
の外部でこのコンテキストを作成する必要があるため、undefinedフォールバック値が必要です。

4518
09:14:59,460 --> 09:15:05,460
プロバイダの外部でこのコンテキストを作成しなければならないからです。

4519
09:15:05,460 --> 09:15:14,020
フォールバック値としてundefinedが必要になります。

4520
09:15:14,020 --> 09:15:21,060
サブスクリプション・レベル・プロバイダのpropsを作成します。

4521
09:15:21,060 --> 09:15:28,340
他のコンポーネントや子コンポーネントをこれらのプロバイダにラップする方法と同じように、子コンポーネントをこのプロバイダに渡す必要があります。

4522
09:15:28,340 --> 09:15:34,420
ここでは、プロバイダの開始タグと終了タグの間に置くものはすべて、子プロバイダです。

4523
09:15:34,420 --> 09:15:41,860
子とユーザー購読で、これはreactノード型です。

4524
09:15:41,860 --> 09:15:48,820
ユーザーサブスクリプションのレベルをこのコンテキスト・プロバイダに渡します。

4525
09:15:48,820 --> 09:15:54,420
コンポーネントであるため、ここでそれを取得することはできません。

4526
09:15:54,420 --> 09:15:57,460
これらのプロップを再構築します

4527
09:16:02,740 --> 09:16:05,860
子プロップとユーザ購読レベル

4528
09:16:05,860 --> 09:16:17,220
そして、このコンテキスト・プロバイダを作成するサブスクリプション・レベルのコンテキスト・ドット・プロバイダを返します。

4529
09:16:17,220 --> 09:16:26,260
このプロバイダに渡す値をユーザーのサブスクリプション・レベルに設定します。

4530
09:16:26,260 --> 09:16:32,340
この値は子コンポーネントで利用できるようになります。

4531
09:16:32,660 --> 09:16:37,620
後でこのサブスクリプションにアクセスする必要があるときは、同じファームの一番下にある

4532
09:16:37,620 --> 09:16:45,780
コンポーネントで、サブスクリプションレベルのコンテキストを渡すコンテキストフックを使用することができます。

4533
09:16:45,780 --> 09:16:52,340
このフックにサブスクリプションレベルのコンテキストを渡します。

4534
09:16:52,340 --> 09:16:58,180
このため、このロジックをカプセル化するカスタムフックを作成するのが良い方法です。

4535
09:16:58,180 --> 09:17:05,860
フックを作成し、このロジックをカプセル化するのがよい方法です。

4536
09:17:05,860 --> 09:17:15,780
フックを作成しました。

4537
09:17:15,780 --> 09:17:23,220
にサブスクリプションレベルのコンテキストを渡します。

4538
09:17:23,220 --> 09:17:30,660
はユーザーのサブスクリプション・レベルです。

4539
09:17:30,660 --> 09:17:37,140
レイアウトにこのプロバイダを追加すると、context is equal to
undefinedというエラーメッセージが表示されます。

4540
09:17:37,140 --> 09:17:43,460
このコンテキストが未定義であるというのはどういう意味でしょうか？

4541
09:17:43,460 --> 09:17:49,140
この値はオプションではないので、渡さなければなりません。

4542
09:17:49,140 --> 09:17:55,540
このプロバイダをレイアウトに追加し忘れた場合のみ、未定義になります。

4543
09:17:55,540 --> 09:18:01,540
しかし、これは開発者のミスであり、決して起こってはならないことなので、ここでエラーをスローします。

4544
09:18:01,540 --> 09:18:11,140
このエラーは、サブスクリプション・レベルを使用する必要があると表示されます。

4545
09:18:11,860 --> 09:18:21,060
もし開発者や私たちがこのプロバイダをレイアウトに追加し忘れた場合、このエラーメッセージが表示されます。

4546
09:18:21,060 --> 09:18:28,340
をレイアウトに追加し忘れた場合、このエラーメッセージが表示されます。

4547
09:18:28,340 --> 09:18:34,740
しかし異なるのは、コンテキストが未定義であることはありえないということです。

4548
09:18:34,740 --> 09:18:40,980
このため、コンポーネントでこのフックを使用し、ユーザー購読レベルにアクセスすることができます。

4549
09:18:40,980 --> 09:18:47,700
サブスクリプション・レベルにアクセスできるようになりました。

4550
09:18:47,700 --> 09:18:54,900
と定義された値、あるいはnullのデフォルト値を得ることができます。

4551
09:18:54,900 --> 09:19:02,260
メイン・レイアウトに入り、ここでレイアウト内のデータをフェッチします。

4552
09:19:02,260 --> 09:19:09,300
非同期関数を作成します。

4553
09:19:09,300 --> 09:19:18,180
そのためには、ユーザーIDが必要です。

4554
09:19:18,180 --> 09:19:26,260
ユーザが認証されていない場合、nullを返すか、エラーを投げることができます。

4555
09:19:26,260 --> 09:19:31,380
ユーザが認証されている場合は、ユーザを取得します。

4556
09:19:32,820 --> 09:19:40,820
先ほど作成した関数 get user subscription level から取得します。

4557
09:19:40,820 --> 09:19:48,260
にユーザーIDを渡します。

4558
09:19:48,260 --> 09:19:56,340
すべての子コンポーネントに渡したいので、このdiv全体をこの購読レベルプロバイダにラップします。

4559
09:19:56,340 --> 09:20:02,820
作成したサブスクリプションに、先ほど取得したサブスクリプションを渡します。

4560
09:20:02,820 --> 09:20:07,620
サブスクリプションを何度も取得することなく、どこでも取得できるようになりました。

4561
09:20:07,620 --> 09:20:13,620
サブスクリプションは子コンポーネントでも利用できるようになります。

4562
09:20:13,620 --> 09:20:19,300
コンポーネントのコンテキストにアクセスすることができるからです。

4563
09:20:19,300 --> 09:20:26,340
レベルの関数を呼び出すだけです。

4564
09:20:26,340 --> 09:20:32,020
購読を不必要に何度も取得することなく、あらゆる場所で購読を取得することができます。

4565
09:20:32,020 --> 09:20:39,700
データベースへの重複リクエストを回避することができます。

4566
09:20:39,700 --> 09:20:45,540
サブスクリプションレベルプロバイダをルートレイアウトに入れて、どこでも利用できるようにすることもできました。

4567
09:20:45,540 --> 09:20:52,100
フロント・ページは静的にキャッシュされます。

4568
09:20:52,100 --> 09:20:57,700
フロントページは静的にキャッシュされている。

4569
09:20:57,700 --> 09:21:04,100
つまり、これらのページを事前にレンダリングしてキャッシュすることができない。

4570
09:21:04,100 --> 09:21:10,260
サブスクリプション・プロバイダーにラップすることで、アプリのメイン部分だけがこのデータをフェッチする必要があります。

4571
09:21:10,260 --> 09:21:16,420
もうひとつ、サブスクリプション・レベル・プロバイダーはクライアント・コンポーネントだ。

4572
09:21:16,420 --> 09:21:22,740
next.jsをベースにしたプロバイダーなので、アプリのすべてのページがそうなる。

4573
09:21:22,740 --> 09:21:29,060
つまり、これらのページや子コンポーネントもすべてクライアント・コンポーネントということだ。

4574
09:21:29,060 --> 09:21:34,900
サーバ・コンポーネントをクライアント・コンポーネントの子プロップに入れても、サーバ・コンポーネントであることに変わりはありません。

4575
09:21:34,900 --> 09:21:40,980
クライアント・コンポーネントにラップされていても、サーバー・コンポーネントであることに変わりはありません。

4576
09:21:40,980 --> 09:21:47,140
クライアント・コンポーネント・プロバイダーにラップされていても、サーバー・コンポーネントであることに変わりはありません。

4577
09:21:47,140 --> 09:21:53,460
next.js初心者向けチュートリアルでも説明しているnext.jsの基本だ。

4578
09:21:53,460 --> 09:21:58,740
このファイルをsubscript genではなくsubscript
genと呼びたいのですが、これはあなた次第です。

4579
09:21:58,740 --> 09:22:07,300
インポートがどこでも正しいことを確認してください。次に、パーミッションシステムを実装したいと思います。

4580
09:22:07,300 --> 09:22:12,820
もし適切なサブスクリプション・レベルを持っていない場合は、次のようにします。

4581
09:22:12,820 --> 09:22:21,780
libフォルダにpermissions.tsという新しいファイルを作成します。

4582
09:22:21,780 --> 09:22:29,380
例えば、resumeを作成することができます。

4583
09:22:29,380 --> 09:22:40,900
を作成し、サブスクリプションファイルからサブスクリプションレベルと現在のレジュームカウントを渡します。

4584
09:22:40,900 --> 09:22:47,780
この関数は購読レベルに応じてさらにレジュメを作成できるかどうかをチェックします。

4585
09:22:47,780 --> 09:22:57,780
この関数では、購読レベルに応じて、さらにレジュメを作成できるかどうかをチェックすることができます。

4586
09:22:57,780 --> 09:23:03,860
このレコードのキーは購読レベルです。

4587
09:23:03,860 --> 09:23:12,900
値は履歴書を作成できる数です。

4588
09:23:12,900 --> 09:23:23,780
無料では履歴書1通、プロでは履歴書3通、プロプラスでは無限大となります。

4589
09:23:23,780 --> 09:23:32,660
これはjavascriptで有効な値です。

4590
09:23:32,660 --> 09:23:43,620
マップを作成し、const max resumesを作成する。

4591
09:23:43,620 --> 09:23:50,980
これは、ここでif elseチェックを何個も追加するよりも整理しやすい。

4592
09:23:50,980 --> 09:23:56,900
このレコードを変更するだけです。

4593
09:23:56,900 --> 09:24:05,220
このレコードを変更するだけで、他には何もする必要はありません。

4594
09:24:05,220 --> 09:24:14,980
レジュメを作成することができます。

4595
09:24:14,980 --> 09:24:26,100
aiツールを使用できるという別の関数をエクスポートします。

4596
09:24:27,860 --> 09:24:38,500
というのも、プロとプロ・プラス・メンバーの両方がこのaiツールを使えるはずだからです。

4597
09:24:38,500 --> 09:24:45,620
このロジックを1つのファイルにまとめることで、何度も繰り返す必要がなくなります。

4598
09:24:45,620 --> 09:24:50,420
このロジックを1つのファイルにまとめることで、このようなことを何度も繰り返さずに済む。

4599
09:24:50,420 --> 09:24:57,940
サブスクリプション・レベルごとのパーミッションはプロ・プラスに等しいので、このようになります。

4600
09:24:57,940 --> 09:25:06,180
もう1つの機能はカスタマイズを使用することができます。

4601
09:25:06,180 --> 09:25:09,540
ここでも購読レベルを渡します

4602
09:25:14,180 --> 09:25:20,580
そして、プロ・プラス・メンバーだけがこれらのカスタマイズを使用できるようにします。

4603
09:25:20,580 --> 09:25:28,740
サブスクリプション・レベルはプロ・プラスに等しいので、これは無料とプロの両方でブロックされます。

4604
09:25:28,740 --> 09:25:35,940
プロとプロ・プラス・ユーザーの違いがわかるようにします。

4605
09:25:35,940 --> 09:25:41,940
この関数は現在のパーミッションをチェックするために使用します。

4606
09:25:41,940 --> 09:25:48,500
なぜなら、このキャッシュ関数にウサギを作成する機能を渡したからだ。

4607
09:25:48,500 --> 09:25:55,140
を渡すと、2つのリクエストをすることになる。

4608
09:25:55,140 --> 09:26:00,900
レジュメと総カウントを並行して取得し、それを3番目の値としてこのpromise.rに入れます。

4609
09:26:00,900 --> 09:26:11,700
関数に3つ目の値として入れる。

4610
09:26:11,700 --> 09:26:17,220
ここでもウェイトを入れる必要はなく、promise.r関数が処理する。

4611
09:26:17,220 --> 09:26:25,220
しかし、ユーザーIDをこの関数に渡す必要があります。

4612
09:26:25,220 --> 09:26:31,220
この関数はキャッシュ関数を介して重複排除される。

4613
09:26:31,220 --> 09:26:38,500
この関数をキャッシュ関数にラップしなければ、リクエストは1回で終わります。

4614
09:26:38,500 --> 09:26:44,340
このキャッシュ関数にラップしなければ、レイアウトとこのページの2つのリクエストが発生することになります。

4615
09:26:44,340 --> 09:26:49,860
そして、ここでカウントダウンをハードコーディングする代わりに

4616
09:26:49,860 --> 09:26:57,380
にサブスクリプションレベルを期待するレジューム関数を渡します。

4617
09:26:57,380 --> 09:27:05,940
と現在のレジュメの総カウント数をレジュメエディタに渡します。

4618
09:27:05,940 --> 09:27:12,340
無料アカウントで作成できるレジュメの数は1つまでなので、レジュメエディターで作成できるレジュメの数は1つになります。

4619
09:27:12,340 --> 09:27:18,260
このルールを挿入する前に他のレジュメを作成しましたが、1つ削除すると

4620
09:27:18,260 --> 09:27:24,420
しかし、1つを削除すると、3つ目の履歴書は作成できないはずです。

4621
09:27:24,420 --> 09:27:32,580
ページを更新するとレジュメエディターが表示されます。

4622
09:27:32,580 --> 09:27:38,820
無料アカウントでは5つまで履歴書を作成できるが、もちろん1つにしておきたい。

4623
09:27:38,820 --> 09:27:44,740
これを1つに戻すと、プレミアムダイアログが表示されます。

4624
09:27:44,740 --> 09:27:51,540
フロントエンドの検証だけでは十分ではありません。

4625
09:27:51,540 --> 09:27:56,900
エディターのサーバーアクションでもこのパーミッションをチェックする必要があります。

4626
09:27:56,900 --> 09:28:03,380
実際に新しいレジュメを作成するのはここです。

4627
09:28:03,380 --> 09:28:10,260
非プレミアムユーザーのコメントチェックアカウントを削除する必要があります。

4628
09:28:10,260 --> 09:28:19,540
データベースから取得する必要があります。

4629
09:28:19,540 --> 09:28:27,700
を渡しますが、ここで少し注意しなければならないことがあります。

4630
09:28:27,700 --> 09:28:34,260
を更新するときだけでなく、新しいレジュメを作成するときにもこの関数を呼び出すからです。

4631
09:28:34,260 --> 09:28:40,820
既存のレジュメを更新する場合、すでに限界に達していても保存操作をブロックしたくないからです。

4632
09:28:40,820 --> 09:28:47,700
なぜなら、新しいレジュメを作成しようとしているわけではないからです。

4633
09:28:47,700 --> 09:28:52,980
これは新しいレジュメを作成しようとしていることを意味します。

4634
09:28:52,980 --> 09:28:59,780
をチェックする必要があります。

4635
09:28:59,780 --> 09:29:14,020
プリズマドットレジュメドットカウントでユーザーidを指定します。

4636
09:29:15,140 --> 09:29:20,900
感嘆符がレジュメを作成できるかどうかをチェックします。

4637
09:29:20,900 --> 09:29:28,900
そして、ここでは購読レベルとレジューム数を渡しています。

4638
09:29:28,900 --> 09:29:36,820
レジュームを作成できない場合は、この関数を呼び出す必要がないため、別のエラーがスローされます。

4639
09:29:36,820 --> 09:29:43,780
保存しようとするとすぐにエラーがスローされます。

4640
09:29:44,340 --> 09:29:46,660
スクリプト・レベル

4641
09:29:46,660 --> 09:29:54,580
ちょっと試してみよう。

4642
09:29:54,580 --> 09:30:03,700
新規レジュームボタンをクリックしたときのダイアログを無効にしたい。

4643
09:30:03,700 --> 09:30:10,500
このリンクを常にエディタに表示し、保存しようとするとすぐに

4644
09:30:10,500 --> 09:30:15,940
バックエンドで新しいレジュメを作成することができないため、エラーが発生します。

4645
09:30:15,940 --> 09:30:24,100
というエラーが出ています。

4646
09:30:24,100 --> 09:30:30,420
これはまさに私たちが望んでいることなのですが、これをレジュメ作成可に戻してみましょう。

4647
09:30:30,420 --> 09:30:36,100
さらに、カスタマイズオプションとaiボタンを無効にしたい機能があります。

4648
09:30:36,100 --> 09:30:42,660
カスタマイズオプションとaiボタンを無効にします。

4649
09:30:42,660 --> 09:30:51,060
styleは既存のレジュメを取得するコードです。

4650
09:30:51,060 --> 09:31:00,180
にはカスタマイズがあり、ボーダースタイルか16進数カラーを渡すと真になります。

4651
09:31:00,180 --> 09:31:06,740
しかし、1つのエッジケースを覚えておく必要があります。

4652
09:31:06,740 --> 09:31:12,340
色やボーダーの半径を変更した後、購読をキャンセルして元に戻った場合です。

4653
09:31:12,340 --> 09:31:18,580
無料アカウントであれば、履歴書の変更を保存し、色やボーダーのスタイルを維持することはできるはずです。

4654
09:31:18,580 --> 09:31:24,580
しかし、新しいサブスクリプションを購入しない限り、再度変更することはできません。

4655
09:31:24,580 --> 09:31:33,140
そのため、カスタマイズした内容を括弧に割り当てる必要があります。

4656
09:31:33,140 --> 09:31:40,500
ドットのボーダースタイルが定義されているかどうかをチェックする必要があります。

4657
09:31:40,500 --> 09:31:49,620
レジュメの値のドットボーダースタイルが既存のレジュメのボーダースタイルと等しくない場合

4658
09:31:49,620 --> 09:31:55,380
というのも、購読期間終了後も既存のボーダースタイルを保持できるようにしたいからです。

4659
09:31:55,380 --> 09:32:03,140
また、16進数の色についても同じようにしたいので、2つのアンバサダーを再び括弧で囲みます。

4660
09:32:03,140 --> 09:32:12,900
履歴書のドットカラー16進数が定義されているかどうか、また履歴書のドットカラー16進数が定義されているかどうかを確認します。

4661
09:32:13,620 --> 09:32:22,020
が既存の履歴書のドットカラー16進数と等しくないかどうかをチェックします。

4662
09:32:22,020 --> 09:32:28,820
そして、これらの各部分について、カスタマイズの適用が許可されているかどうかをチェックします。

4663
09:32:28,820 --> 09:32:37,860
したがって、カスタマイズがある場合は真であり、感嘆符は、カスタマイズを使用することができます。

4664
09:32:37,860 --> 09:32:42,180
もし権限がなければ、サブスクリプション・レベルをパスしなければなりません。

4665
09:32:44,180 --> 09:32:45,940
を渡す必要があります。

4666
09:32:45,940 --> 09:32:54,660
カスタマイズはこの

4667
09:32:54,660 --> 09:33:04,740
サブスクリプション・レベルが正しければ、このアップデートを通さないようにすることができます。

4668
09:33:04,740 --> 09:33:09,940
この条件は間違っています。これは2つのエンボスではなく、2つの縦棒であるべきです。

4669
09:33:09,940 --> 09:33:18,420
論理的な 「または 」であり、これらの各部分はこのように括弧で囲む必要があります。

4670
09:33:18,420 --> 09:33:24,660
これをフロントエンドでブロックしてみよう。

4671
09:33:24,660 --> 09:33:32,500
を選んだとしても、保存できるはずです。

4672
09:33:32,500 --> 09:33:38,420
しかし、これはクライアント・コンポーネントなので、ここで購読レベルを取得することはできません。

4673
09:33:38,420 --> 09:33:44,500
エラーメッセージが表示されます。

4674
09:33:44,500 --> 09:33:50,260
しかしもちろん、ユーザーにエラーメッセージを表示させたくない。

4675
09:33:50,260 --> 09:33:55,940
このカラーピッカーボタンをクリックしたときに、エラーメッセージが表示されないようにします。

4676
09:33:55,940 --> 09:34:04,180
ダイアログを表示します。

4677
09:34:04,180 --> 09:34:11,780
ここでは、作成したフックから購読レベルを取得することができます。

4678
09:34:11,780 --> 09:34:21,700
フックからプレミアムモデルを取得します。

4679
09:34:21,700 --> 09:34:29,780
そして、このボタンをクリックしたときに、有効なサブスクリプションがあるかどうかをチェックしたい。

4680
09:34:29,780 --> 09:34:34,340
このボタンをクリックしたときに、有効なサブスクリプションがあるかどうかをチェックしたいのです。

4681
09:34:34,340 --> 09:34:44,180
そして、サブスクリプションレベルを渡す必要があるカスタマイズを使用することができます。

4682
09:34:44,180 --> 09:34:53,300
カスタマイズを使用できない場合、プレミアムモデルを表示したい。

4683
09:34:53,300 --> 09:34:59,220
set show popoverを呼び出さないようにするために、set
open関数と重要な関数も返すようにします。

4684
09:34:59,940 --> 09:35:06,900
このボタンをクリックすると、プレミアムモデルが表示されます。

4685
09:35:06,900 --> 09:35:11,940
ボーダースタイルのボタンも同じようにします。

4686
09:35:11,940 --> 09:35:17,140
カラーピッカーからこの2つのフックをコピーしよう。

4687
09:35:17,140 --> 09:35:21,060
一番上に貼り付けます

4688
09:35:21,060 --> 09:35:24,580
これらのフックをインポートする

4689
09:35:28,980 --> 09:35:35,300
そして、ハンドルのクリック関数の中で、感嘆符が使えるかどうかをチェックする必要があります。

4690
09:35:35,300 --> 09:35:41,300
がカスタマイズを使用できるかどうかをチェックする必要があります。

4691
09:35:41,300 --> 09:35:47,940
権限がない場合は、プレミアムモデルを開きたい。

4692
09:35:47,940 --> 09:35:55,780
を設定し、サマリーを生成します。

4693
09:35:55,780 --> 09:35:59,140
残りのコードを続けたい。

4694
09:35:59,140 --> 09:36:08,340
ボーダースタイルのボタンも完璧にブロックされるはずです。

4695
09:36:08,340 --> 09:36:16,020
バックエンド部分はフォームフォルダーのサーバーアクションファイルで処理されます。

4696
09:36:16,020 --> 09:36:24,660
では、ここでサマリーを生成するところまでスクロールしてみましょう。

4697
09:36:24,660 --> 09:36:30,740
ユーザーIDを取得する必要があります。

4698
09:36:30,740 --> 09:36:43,780
ユーザーIDが未定義の場合、unauthorizedというエラーを投げます。

4699
09:36:43,780 --> 09:36:50,420
もしユーザーIDが未定義の場合、unauthorizedというエラーを投げます。

4700
09:36:50,420 --> 09:36:58,100
を入力し、ユーザーIDを渡したのとまったく同じコードをコピーします。

4701
09:36:58,100 --> 09:37:06,020
感嘆符がaiツールを使用できるかどうかの権限チェックを行います。

4702
09:37:06,020 --> 09:37:13,860
再度、サブスクリプションのアップグレードエラーを発生させます。

4703
09:37:15,460 --> 09:37:22,180
この機能を使うには、好きなエラーメッセージを入力することができます。

4704
09:37:22,180 --> 09:37:28,660
認証とaiチェックをまったく同じコードにコピーして、ここにある別の関数に入れます。

4705
09:37:28,660 --> 09:37:36,900
このTo Doコメントを削除して、このフォーマットに入れて、すべてを保存します。

4706
09:37:36,900 --> 09:37:41,380
生成ボタンをクリックするとエラーが表示されます。

4707
09:37:41,620 --> 09:37:48,340
そして、ボーダースタイルのボタンから購読レベルをコピーする必要があります。

4708
09:37:48,340 --> 09:37:56,100
この2つはプレミアムダイアログを表示するためです。

4709
09:37:56,100 --> 09:38:03,380
もう一度、仕事体験の生成ボタンに入り、購読レベルが必要です。

4710
09:38:03,380 --> 09:38:09,700
とプレミアム・モデルのフックをボーダー・スタイル・ボタンからコピーしましょう。

4711
09:38:11,140 --> 09:38:16,660
ペーストしてここにインポートするのは面倒なので

4712
09:38:16,660 --> 09:38:26,900
を削除して、再度、クリック時に入力ダイアログを表示するように設定します。

4713
09:38:26,900 --> 09:38:35,620
ハンドラーを中かっこで囲み、ここでもまたこの2行をコピーして、generate
summaryに移動します。

4714
09:38:35,620 --> 09:38:41,060
しかし、どのレベルがfalseなのか、そしてプレミアムモデルを開きたいのか。

4715
09:38:41,060 --> 09:38:50,740
このボタンをクリックすると、プレミアム・モデルが表示されます。

4716
09:38:50,740 --> 09:38:58,660
ボタンをクリックすると、プレミアム・モデルが表示される。

4717
09:38:58,660 --> 09:39:05,780
これもaiの機能なので、この2行をコピーして、generate summaryボタンに移動します。

4718
09:39:05,780 --> 09:39:09,460
この2つのフックをインポートする

4719
09:39:09,460 --> 09:39:19,620
そしてまた、このチェックが必要だ。

4720
09:39:21,460 --> 09:39:28,740
もしaiツールが使えないなら、この関数をインポートしなければならない。

4721
09:39:28,740 --> 09:39:35,540
プレミアムMODを開きたいのですが、最近、イベント・デスティネーションに名前が変わりました。

4722
09:39:35,540 --> 09:39:41,300
これらのプレミアム機能は、適切なサブスクリプションを持っている場合のみ利用可能です。

4723
09:39:41,300 --> 09:39:46,740
すでにstripeで購読を購入しているが、まだフルフィルメントを実装していない。

4724
09:39:46,740 --> 09:39:53,060
ストライプチェックアウトが成功した後、定期購入を作成するコードを実装する必要があります。

4725
09:39:53,060 --> 09:39:58,580
stripeチェックアウトで購読を購入すると、自動的にユーザー購読テーブルにエントリが作成されます。

4726
09:39:58,580 --> 09:40:04,500
ユーザー購読テーブルにエントリを作成し、このユーザーがプレミアム機能にアクセスできることを確認します。

4727
09:40:04,500 --> 09:40:11,300
ウェブフックを設定することができます。ウェブフックとは、ストライプが呼び出すサーバー上のエンドポイントです。

4728
09:40:11,300 --> 09:40:17,620
Webhookを設定するために、stripeのダッシュボードにアクセスします。

4729
09:40:17,620 --> 09:40:23,300
最近イベントデスティネーションに名前が変わりました。

4730
09:40:23,300 --> 09:40:29,380
検索でイベント先かwebhookを検索して

4731
09:40:29,380 --> 09:40:36,900
もちろん、ストライプはインターネット上で利用可能な場合にのみこのウェブフックを呼び出すことができます。

4732
09:40:36,900 --> 09:40:43,220
を呼び出すことはできません。

4733
09:40:43,220 --> 09:40:48,500
というのも、送信するイベントとデータを決めなければならないからだ。

4734
09:40:48,500 --> 09:40:54,340
実際のチェックアウトをシミュレートし、ストライプが実際のチェックアウトで送信するすべてのイベントを取得したいので、次のようにします。

4735
09:40:54,340 --> 09:41:01,620
ローカルリスナーではなく本物のウェブフックを作成します。

4736
09:41:01,620 --> 09:41:07,220
現在のapiバージョンを選択し、リッスンするイベントを選択します。

4737
09:41:07,220 --> 09:41:15,460
ここでは、checkout.session.completedと入力します。

4738
09:41:15,460 --> 09:41:25,380
そして、customer.subscriptionと入力し、ここで.created .deleted

4739
09:41:26,580 --> 09:41:34,340
.updatedが必要ですが、passedやresumedは必要ありません。

4740
09:41:34,340 --> 09:41:41,700
この4つのイベントだけで十分です。

4741
09:41:41,700 --> 09:41:47,700
webhook endpoint
continueを選択し、ここでもう一度URLを入力する必要があります。

4742
09:41:47,700 --> 09:41:53,860
なぜならstripeはローカルマシンを呼び出せないからです。

4743
09:41:53,860 --> 09:42:01,300
いわゆるポートフォワーディングでパブリックURLに転送することです。

4744
09:42:01,300 --> 09:42:07,860
ターミナルを開くと、ここにportsタブがあり、ここでポートを転送できる。

4745
09:42:07,860 --> 09:42:15,060
3000 で、ここで npm run dev が実行されている。

4746
09:42:15,060 --> 09:42:23,780
アカウントにサインインする必要があります。

4747
09:42:23,780 --> 09:42:32,340
ポート可視性を設定し、インターネット上の実際のURLに設定します。

4748
09:42:32,340 --> 09:42:40,660
そうだ、ここでcontinueをクリックすれば、ウェブサイトが表示されるはずだ。

4749
09:42:40,660 --> 09:42:48,500
実際のurlで実行されています。

4750
09:42:48,500 --> 09:42:54,900
ポートビジビリティを右クリックして、publicに設定して

4751
09:42:54,900 --> 09:43:02,180
これでこのurlをstripeのウェブフックに使えるようになりました。

4752
09:43:02,180 --> 09:43:07,780
を終了したり、コンピュータを再起動したりした場合は、このポートを再度有効にする必要があります。

4753
09:43:07,780 --> 09:43:13,300
を再度公開してください。そうしないとstripeはアクセスできません。

4754
09:43:13,300 --> 09:43:21,060
このローカルアドレスをコピーして、エンドポイントのurlに貼り付けましょう。

4755
09:43:21,060 --> 09:43:30,180
に貼り付けて、ウェブフックのパスを入力します。

4756
09:43:30,180 --> 09:43:38,180
を入力し、テスト用のwebhookの説明を追加します。

4757
09:43:38,180 --> 09:43:44,180
対コードでのポートフォワーディングが何らかの理由でうまくいかない、あるいは使いたくない場合

4758
09:43:44,180 --> 09:43:49,460
同じようなサービスは他にもある。

4759
09:43:49,460 --> 09:43:57,380
サインアップ不要のlocalhost.runやsrv.us、ngrokなどがある。

4760
09:43:57,380 --> 09:44:05,860
しかし、簡単なコードを.envファイルに入れて、ここに置くだけだ。

4761
09:44:05,860 --> 09:44:12,900
.envファイルに簡単なコードを書いて、ここに書いておく。

4762
09:44:12,900 --> 09:44:20,020
ここで何かが起こるたびに、Webhookシークレットが必要になる。

4763
09:44:20,020 --> 09:44:28,100
.envファイルのsコードにある環境変数に格納する必要があります。

4764
09:44:28,100 --> 09:44:34,180
もちろん順番は関係ない。

4765
09:44:34,180 --> 09:44:43,460
この値を貼り付けて、typesave.env.tsファイルに追加します。

4766
09:44:43,460 --> 09:44:50,740
ストライプのシークレットキーを webhook のシークレットキーに複製し、これも保存します。

4767
09:44:50,740 --> 09:44:56,340
webhook自体を設定する必要があります。サーバーアクションを使うことはできません。

4768
09:44:56,340 --> 09:45:02,180
のようなサードパーティ・サービスから呼び出されるパブリック・サーバー・エンドポイントを作成することはできません。

4769
09:45:02,180 --> 09:45:08,180
stripeのようなサードパーティ・サービスから呼び出されるようなパブリック・サーバー・エンドポイントを作成することはできません。

4770
09:45:08,180 --> 09:45:14,900
ルートハンドラを作成するには、appフォルダを右クリックして、apiフォルダを作成するapi
slashを記述します。

4771
09:45:14,900 --> 09:45:22,660
stripeからwebhookを除いたもの......これがここで使用したurlです slash
api slash stripeからwebhookを除いたもの。

4772
09:45:22,660 --> 09:45:29,060
同じスラッシュであることを確認してください。

4773
09:45:29,060 --> 09:45:34,820
自分のアプリだけでなく、他のアプリからもアクセスできるサーバーエンドポイントを作成します。

4774
09:45:35,700 --> 09:45:41,940
ここでは、非同期関数をエクスポートする。

4775
09:45:41,940 --> 09:45:48,020
というのも、デフォルトのエクスポートにすることはできないからだ。

4776
09:45:48,020 --> 09:45:56,260
を書き、next.jsにpostエンドポイントを作成する。

4777
09:45:56,260 --> 09:46:03,380
リクエストを渡します。ここでは、try catchブロックをcatchブロックに入れます。

4778
09:46:03,380 --> 09:46:13,220
また、レスポンスを返す必要があるので、return new responseでレスポンスを返します。

4779
09:46:13,220 --> 09:46:20,500
には単純な文字列の内部サーバーエラーとステータスコードを入れます。

4780
09:46:20,500 --> 09:46:27,780
これはエラーのhttpステータスコードです。

4781
09:46:27,780 --> 09:46:33,220
ステータスコードを送信する必要はありません。

4782
09:46:33,220 --> 09:46:40,420
しかし、このapiルートハンドラはもう少し古いもので、通常は

4783
09:46:40,420 --> 09:46:47,700
ステータスコードの定義やレスポンスオブジェクトの返し方など、もう少しコードを書く必要がありますが

4784
09:46:47,700 --> 09:46:55,620
ペイロードを作成し、リクエストを待つ。

4785
09:46:56,580 --> 09:47:02,980
ドットテキストを待ち受ける関数です。

4786
09:47:02,980 --> 09:47:07,940
このリクエストオブジェクトにすべてのデータが送信されます。

4787
09:47:07,940 --> 09:47:17,060
次に、constシグネチャを作成します。シグネチャは、ストライプが自身を認証する方法です。

4788
09:47:17,060 --> 09:47:22,660
このWebhookを呼び出そうとしているのが悪者ではなく、実際にストライプであることを確認するためです。

4789
09:47:22,660 --> 09:47:27,060
署名はリクエストのヘッダーに含まれる。

4790
09:47:27,060 --> 09:47:36,580
リクエストのヘッダーに含まれている。

4791
09:47:36,580 --> 09:47:44,420
シグネチャがない場合、これはstripeではないことがわかる。

4792
09:47:44,420 --> 09:47:48,820
この場合、新しいエラーレスポンスを返したいので、新しいレスポンスを返します。

4793
09:47:51,300 --> 09:47:58,020
シグネチャがない場合、ステータスコードに400を渡す。

4794
09:47:58,020 --> 09:48:03,940
無効なリクエストに対するhttpステータスコードなので、これは無効なリクエストであり、拒否したい。

4795
09:48:03,940 --> 09:48:11,220
もちろんこれはstripeのドキュメントに記載されている。

4796
09:48:11,220 --> 09:48:21,220
ここでは、libフォルダからstripeをインポートします。

4797
09:48:21,220 --> 09:48:32,420
にペイロードカンマとシグネチャ、そしてドット stripe ウェブフックシークレットを渡します。

4798
09:48:32,420 --> 09:48:38,820
送信されたテキストからデータを解析し、webhookを自動的に検証し、以下のことをチェックします。

4799
09:48:38,820 --> 09:48:44,660
シークレットキーが有効であることをチェックする。

4800
09:48:44,660 --> 09:48:50,900
このイベントの内容を、私たちの購読データで以下に示します。

4801
09:48:50,900 --> 09:48:57,780
コンソールにログを記録してみよう。ここには、イベントを受信したというバックティック文字列を書きたい。

4802
09:48:57,780 --> 09:49:04,900
コロンと、ここにはイベントのドットタイプを表示します。

4803
09:49:04,900 --> 09:49:11,940
バックティック文字列の後、コンソール・ドット・ログの中に、イベント・ドット・データを記録します。

4804
09:49:12,740 --> 09:49:18,340
これはサブスクリプションのデータで、このイベントの実際の内容です。

4805
09:49:18,340 --> 09:49:25,620
このすべてをコンソールにログしたい。

4806
09:49:25,620 --> 09:49:34,580
イベント・ドット・タイプによって異なる処理を行いたいからです。

4807
09:49:34,580 --> 09:49:39,620
チェックアウトが完了したサブスクリプションが作成された、などです。

4808
09:49:39,620 --> 09:49:45,140
ロジックを別々の関数に分割します。

4809
09:49:45,140 --> 09:49:53,620
以下に、ハンドラーセッション完了という非同期関数を書きます。

4810
09:49:53,620 --> 09:50:02,180
セッションと呼ぶオブジェクトを受け取る。

4811
09:50:02,180 --> 09:50:10,420
今回、これはストライプ・タイプのドット・チェックアウト・ドット・セッションである。

4812
09:50:10,420 --> 09:50:16,260
そして、コードでこれを埋める前に、他の関数も作成する。

4813
09:50:16,260 --> 09:50:26,900
次の関数は、サブスクリプションの作成や更新を処理する非同期関数です。

4814
09:50:26,900 --> 09:50:35,460
イベントを同じ関数で処理し、ここでは文字列であるサブスクリプションIDを受け取ります。

4815
09:50:35,460 --> 09:50:41,540
コンソールにこの関数の名前のログメッセージを表示します。

4816
09:50:41,540 --> 09:50:50,500
この関数と、その下にもう一つ、購読削除を処理する非同期関数を呼び出している。

4817
09:50:52,020 --> 09:50:58,900
ここで受け取るのはサブスクリプションIDではなく、stripe dot
subscription型のオブジェクト全体です。

4818
09:50:58,900 --> 09:51:06,500
そしてここでも、とりあえずコンソールにロックしたいので、これら3つの関数を追加します。

4819
09:51:06,500 --> 09:51:13,620
そしてswitchブロックの中で、これらの異なるウェブフックイベントをリッスンします。

4820
09:51:13,620 --> 09:51:20,580
オートコンプリート caseと文字列を入力するとオートコンプリートが表示されます。

4821
09:51:20,580 --> 09:51:26,740
セッションが完了した場合はswitchを使い、そうでない場合は次のケースを実行します。

4822
09:51:26,740 --> 09:51:35,220
handle session completed
rightは、このチェックアウト・セッションに期待するもので、これを

4823
09:51:35,220 --> 09:51:41,940
イベント・ドット・データ・ドット・オブジェクトで、タイプはストライプ・チェックアウト・セッションです。

4824
09:51:41,940 --> 09:51:49,220
スイッチを使っているので、非常に重要なブレークを入れなければなりません。

4825
09:51:49,220 --> 09:51:56,020
を使用しているためです。そうしないと、次のケースも実行してしまうことになります。

4826
09:51:56,020 --> 09:52:05,540
関数を呼び出す代わりに、次のケースの下に別のケースを置きます。

4827
09:52:05,540 --> 09:52:12,500
なぜなら、どちらも同じ関数を呼び出す必要があるからです。

4828
09:52:14,340 --> 09:52:23,060
次のケースはもちろんcustomer subsubsで、ここではawait handle
subscription createdまたはupdatedを呼び出します。

4829
09:52:23,060 --> 09:52:32,740
そして、イベント・ドット・データ・ドット・オブジェクトから得られるサブスクリプションIDが必要です。

4830
09:52:32,740 --> 09:52:41,220
ストライプ・サブスクリプションというタイプです。

4831
09:52:42,980 --> 09:52:50,980
次のケースは、もちろん顧客のサブスクリプションが削除された場合です。

4832
09:52:50,980 --> 09:52:58,500
サブスクリプションが削除され、ここでイベントドットデータドットオブジェクトを渡す。

4833
09:52:58,500 --> 09:53:06,180
オブジェクトを渡します。

4834
09:53:08,500 --> 09:53:15,860
を追加します。これは、stripeでチェックアウトしたときにセッションが完了したことを示すものです。

4835
09:53:15,860 --> 09:53:25,620
で、その後ろにイベントドット型を付けます。

4836
09:53:25,620 --> 09:53:34,020
を受け取ったことがわかるからです。

4837
09:53:34,020 --> 09:53:41,220
このスイッチは適切な関数を呼び出します。

4838
09:53:41,220 --> 09:53:47,220
stripeでチェックアウトを行うと、自動的にstripeダッシュボードに顧客が作成されます。

4839
09:53:47,220 --> 09:53:53,300
が自動的に作成されます。

4840
09:53:53,300 --> 09:53:58,740
重複したユーザーを作成しないように、このユーザーのstripeカスタマーIDをどこかに保存しておく必要があります。

4841
09:53:58,740 --> 09:54:05,220
後で再利用できるようにするために、このユーザーIDをどこかに保存する必要があります。

4842
09:54:05,220 --> 09:54:12,820
スラッシュで行うチェックアウトページを作成するときに、ユーザーIDを

4843
09:54:12,820 --> 09:54:20,740
プレミアムでは、購読メタデータにユーザーIDを入れます。

4844
09:54:20,740 --> 09:54:31,700
セッション・ドット・メタデータからユーザーIDを取り出すことができます。

4845
09:54:31,700 --> 09:54:37,860
どちらの場所でもキャメルケースで綴ります。

4846
09:54:37,860 --> 09:54:43,700
メタデータはサブスクリプションオブジェクトにのみ入れられます。

4847
09:54:44,660 --> 09:54:52,180
このメタデータはこのセッションにアタッチされます。

4848
09:54:52,180 --> 09:54:58,100
このメタデータはパブリック・エラーに過ぎず、ユーザーが気にしない開発上のエラーに過ぎない。

4849
09:54:58,100 --> 09:55:04,500
というのも、このメタデータを受け取るのは、このセッション・ドット

4850
09:55:04,500 --> 09:55:11,460
メタデータ・オブジェクトで、保存呼び出し演算子を使わなければならない。

4851
09:55:11,460 --> 09:55:18,740
というのも、チェックアウトセッションにこのメタデータを追加するのを忘れてしまう可能性があるからです。

4852
09:55:18,740 --> 09:55:21,620
感嘆符ユーザID

4853
09:55:21,620 --> 09:55:26,580
がない場合、新しいエラーを投げます。

4854
09:55:26,580 --> 09:55:38,660
ユーザIDがセッションメタデータにありません。

4855
09:55:39,300 --> 09:55:44,020
しかし、これはパブリックなエラーではなく、開発用のエラーです。

4856
09:55:44,020 --> 09:55:49,220
私たち開発者だけがこのエラーを気にします。

4857
09:55:49,220 --> 09:55:56,020
ここにエラーを投げて、ここで待機することで、自動的にキャッチブロックに到達します。

4858
09:55:56,020 --> 09:56:02,580
このエラーはバックエンドでしか読めないので、ステータス500の内部サーバーエラーが表示されます。

4859
09:56:02,580 --> 09:56:08,500
このエラーはバックエンドでしか読み取れないので、公開されず、このユーザーがストライプから割り当てられた顧客IDが表示されます。

4860
09:56:08,500 --> 09:56:13,380
問題はどこに保存するかです。

4861
09:56:13,380 --> 09:56:20,660
店員のメタデータに保存するのがベターだと思います。

4862
09:56:20,660 --> 09:56:26,900
というのも、このメタデータは特定のユーザーにアタッチされるからだ。

4863
09:56:26,900 --> 09:56:32,500
なぜなら、このメタデータはバックエンドでしか読むことができないからだ。

4864
09:56:33,220 --> 09:56:38,740
ここで、ドキュメントではストライプIDを例にして、異なる値を格納することができます。

4865
09:56:38,740 --> 09:56:48,020
同じようにしたいので、このチェックの下に括弧をつけて、await clerk
clientを呼び出します。

4866
09:56:48,020 --> 09:56:55,780
これはnext.jsサーバーからのインポートで、これは関数なので、これを呼び出します。

4867
09:56:55,780 --> 09:57:04,420
.users.updateユーザー・メタデータと書く。

4868
09:57:04,420 --> 09:57:10,900
メタデータのセッションを更新する関数です。

4869
09:57:10,900 --> 09:57:18,340
ここにプライベート・メタデータのコロン（中かっこ）を入れ、ここに任意の値を入れることができる。

4870
09:57:18,340 --> 09:57:28,020
ここにはsession.customerから取得したストライプの顧客IDを入れます。

4871
09:57:28,020 --> 09:57:36,180
これはsession.customerから取得します。

4872
09:57:36,180 --> 09:57:43,220
を文字列としてアサートします。

4873
09:57:43,220 --> 09:57:50,260
を文字列としてアサートします。ユーザがチェックアウトを完了するとすぐに、stripeはこの

4874
09:57:50,260 --> 09:57:56,420
このイベントでhandle session completed関数を呼び出します。

4875
09:57:56,420 --> 09:58:03,780
この顧客IDをサーバーアクションファイルで使用します。

4876
09:58:03,780 --> 09:58:10,660
プレミアムフォルダのサーバーアクションファイルでこの顧客IDを使用したい。

4877
09:58:10,660 --> 09:58:16,180
では、stripeダッシュボードに複数の顧客を作成することは避けられません。

4878
09:58:16,180 --> 09:58:21,380
複数のチェックアウトを行う場合、これはどこにでも置くことができます。

4879
09:58:21,380 --> 09:58:28,340
顧客IDが利用可能な場合は、それを渡す必要があります。

4880
09:58:28,340 --> 09:58:37,540
stripeカスタマーIDは、この店員ユーザーのプライベートメタデータから取得します。

4881
09:58:37,540 --> 09:58:46,660
user.privateメタデータ.stripeカスタマーIDから取得します。

4882
09:58:46,660 --> 09:58:54,740
で行ったのと同じ綴りにしてください。

4883
09:58:54,740 --> 09:59:02,260
型が不明なので、文字列かundefinedになります。

4884
09:59:02,260 --> 09:59:09,380
まだストライプの顧客IDを持っていない場合、顧客のEメールの上にある必要はありません。

4885
09:59:09,380 --> 09:59:15,220
このフィールドにストライプの顧客IDを渡します。

4886
09:59:15,220 --> 09:59:21,780
しかし、顧客IDと顧客Eメールの両方を追加することはできません。

4887
09:59:21,780 --> 09:59:29,060
emailはストライプの顧客IDが定義されているかチェックします。

4888
09:59:31,140 --> 09:59:32,420
Eメールを渡します

4889
09:59:32,420 --> 09:59:39,620
このストライプの顧客IDが店員アカウントに表示されます。

4890
09:59:39,620 --> 09:59:47,540
しかし、もうひとつ重要なことがある。

4891
09:59:47,540 --> 09:59:53,860
catchブロックの上で成功レスポンスを返す必要があります return new response

4892
09:59:55,620 --> 10:00:03,620
イベントを受け取り、ステータスコードは成功を意味する200になります。

4893
10:00:03,620 --> 10:00:08,740
このルートハンドラからは、常に成功かエラーのどちらかのレスポンスを返す必要があるからです。

4894
10:00:08,740 --> 10:00:15,300
レスポンス
もうひとつ、このルートは私たちのページと同じように、デフォルトでは店員認証によってブロックされます。

4895
10:00:15,300 --> 10:00:21,460
このルートにアクセスするにはログインする必要がある。

4896
10:00:21,460 --> 10:00:28,420
もう一度チェックアウトして、postman経由でwebhookを呼び出してみます。

4897
10:00:28,420 --> 10:00:36,820
Webhookをここに追加したいので、別の文字列スラッシュアピスラッシュストライプマイナスwebhook

4898
10:00:36,820 --> 10:00:46,580
これでこのルートは公開され、stripeはこのルートに到達できるようになりました。

4899
10:00:46,580 --> 10:00:54,660
もう一度チェックアウトを試す前に、postman経由でwebhookを呼んでみたい。

4900
10:00:54,660 --> 10:01:02,820
api slash stripe webhook への post リクエストで、postman
経由で webhook を呼び出してみます。

4901
10:01:02,820 --> 10:01:09,140
postmanから呼び出すときに署名を送信していないため、署名がありません。

4902
10:01:09,140 --> 10:01:15,220
後でstripeが署名を送るので、postmanをインストールする必要はありません。

4903
10:01:15,220 --> 10:01:20,740
ここで確認したいのは、まだサブスクリプションを作成していないということです。

4904
10:01:20,740 --> 10:01:28,580
関数をロックするだけなので、まだ購読が作成されていないことを確認したい。

4905
10:01:28,580 --> 10:01:34,820
がウェブ上で利用可能であることを意味するからだ。

4906
10:01:34,820 --> 10:01:42,260
重要なのは、この公開URLを介してインターネット経由でアクセスできることです。

4907
10:01:42,260 --> 10:01:48,180
ここではこの関数をコンソールにロックするだけなので、サブスクリプションは作成されません。

4908
10:01:48,180 --> 10:01:55,860
チェックアウトを行い、ここで受け取ったデータをお見せします。

4909
10:01:55,860 --> 10:02:02,900
では、プレミアムダイアログを開いてみましょう。

4910
10:02:02,900 --> 10:02:12,100
プレミアム・プラスを選びますが、どれを選んでもかまいません。

4911
10:02:12,100 --> 10:02:22,900
これと未来の日付、乱数、名前を保存する。

4912
10:02:22,900 --> 10:02:30,020
このボタンをクリックすると、ウェブフックイベントを受信するはずです。

4913
10:02:30,020 --> 10:02:38,900
コンソールにデータがロックされる。

4914
10:02:40,340 --> 10:02:49,220
数秒後、受信したイベントが表示されます。

4915
10:02:49,220 --> 10:02:56,820
ご覧のようにたくさんのデータがあります。

4916
10:02:56,820 --> 10:03:04,980
ウェブフックでは、データベースにチェックアウトセッション完了エンジンを受け取りました。

4917
10:03:04,980 --> 10:03:11,220
stripeのダッシュボードも見てみましょう。

4918
10:03:11,220 --> 10:03:22,260
この中に購入したオブジェクトの価格IDがあるはずです。

4919
10:03:22,260 --> 10:03:28,820
このデータオブジェクトの項目は、価格のアイデアのような詳細情報です。

4920
10:03:28,820 --> 10:03:36,260
stripeのダッシュボードを見てみましょう。

4921
10:03:36,260 --> 10:03:44,340
送られたすべてのイベントのロックが表示されます。

4922
10:03:44,340 --> 10:03:49,780
最初のリトライが行われると思います。

4923
10:03:49,780 --> 10:03:56,180
顧客は2つ作成されましたが、これは数日間です。

4924
10:03:56,180 --> 10:04:01,940
バックオフと呼ばれるものですが、もちろん理想的にはストライプは常にウェブフックを呼び出せるべきです。

4925
10:04:01,940 --> 10:04:07,060
まだデータベースにサブスクリプションを作成していません。

4926
10:04:07,060 --> 10:04:15,700
まず最初に、ここで顧客のところに行き、作成された顧客を見てみましょう。

4927
10:04:15,700 --> 10:04:21,540
顧客は2人いますが、こちらはストライプを保存する前に行った最初のチェックアウトです。

4928
10:04:21,540 --> 10:04:27,780
顧客IDを記憶しているため、同じメールアドレスが2回存在します。

4929
10:04:27,780 --> 10:04:34,340
将来的には、ストライプの顧客IDを再利用することでこの問題を回避します。

4930
10:04:34,340 --> 10:04:44,100
重複しないように、この最初の顧客を削除しましょう。

4931
10:04:44,100 --> 10:04:51,620
この顧客を開くと顧客idがあり、同じ顧客idのrdn blah blah
blahが保存されているはずです。

4932
10:04:51,620 --> 10:04:59,460
コーディングとフローでフロリアンのユーザーを見てみましょう。

4933
10:04:59,460 --> 10:05:05,700
ダッシュボードでプライベートメタデータを見ると、そこにはストライプの顧客IDがある。

4934
10:05:05,700 --> 10:05:12,100
idがプライベートメタデータに保存されており、後でこれを使ってストライプの顧客を特定できます。

4935
10:05:12,660 --> 10:05:18,100
ストライプのダッシュボードに戻ってみましょう。

4936
10:05:18,100 --> 10:05:24,420
これは完璧ではないので、削除してしまいましょう。

4937
10:05:24,420 --> 10:05:32,420
すぐにまた削除して、ウェブフックに削除リクエストを送ります。

4938
10:05:32,420 --> 10:05:38,020
コンソールのハンドルでサブスクリプションが削除されたことを確認できます。

4939
10:05:38,660 --> 10:05:44,100
サブスクリプションを作成するためのWebhookを終了しましょう。

4940
10:05:44,100 --> 10:05:50,180
updated関数でログステートメントを削除して実装しましょう。

4941
10:05:50,180 --> 10:05:56,260
これらのWebhookを実装するためのさまざまなアプローチがあることを言いたい。

4942
10:05:56,260 --> 10:06:01,540
アプリで起こりうるさまざまなケースに対応できるよう、本物のZestを構築するのであれば

4943
10:06:01,540 --> 10:06:07,220
フィールドを追加したり、より多くのイベントをリッスンする必要があるかもしれません。

4944
10:06:07,220 --> 10:06:12,580
これは完璧ではない。

4945
10:06:12,580 --> 10:06:17,620
これですべてのエッジケースに対処できることを保証できるほど、stripeの経験があるわけではありません。

4946
10:06:17,620 --> 10:06:23,540
自分で改良する必要があるかもしれませんが、これで十分です。

4947
10:06:23,540 --> 10:06:28,340
この関数は、サブスクリプションが作成または更新されたときに呼び出されます。

4948
10:06:28,340 --> 10:06:35,380
この関数はサブスクリプションが作成されたり更新されたりしたときに呼び出されます。

4949
10:06:36,980 --> 10:06:42,340
サブスクリプションの更新イベントがあるはずです。

4950
10:06:42,340 --> 10:06:50,740
このようなことが起こるのは、作成されたイベントのどこかに異なるステータスがあるからです。

4951
10:06:50,740 --> 10:07:00,260
フィールドに 「incomplete 」と表示されています。

4952
10:07:00,260 --> 10:07:07,300
その直後に受け取ったupdatedイベントでは、ステータスが変更される。

4953
10:07:07,300 --> 10:07:13,940
を考慮する必要がある。

4954
10:07:13,940 --> 10:07:19,380
これらのイベントは順番に受信されないことがあります。

4955
10:07:19,380 --> 10:07:25,540
そのため、作成されたイベントより前に更新されたイベントを受信してしまう可能性があります。

4956
10:07:25,540 --> 10:07:30,420
これらのイベントを正しい順序で受け取ることを保証するものではありません。

4957
10:07:30,420 --> 10:07:38,420
サブスクリプションIDを渡しているのはこのためです。

4958
10:07:38,420 --> 10:07:44,580
このサブスクリプションには、このWebhookのすべてのデータが含まれています。

4959
10:07:44,580 --> 10:07:53,060
なぜかというと、ここでstripe apiからサブスクリプションを取得したいからです。

4960
10:07:53,860 --> 10:08:00,180
このようにして、常に最新のサブスクリプションIDを受け取れるようにする。

4961
10:08:00,180 --> 10:08:06,660
イベントを順番にフェッチするのではなく、常に最新のサブスクリプションをフェッチします。

4962
10:08:06,660 --> 10:08:12,020
ウェブフックから送られてくるデータに依存しない。

4963
10:08:12,020 --> 10:08:21,780
最新のデータを取得し、stripe dot subscriptions dot
retrieveから取得します。

4964
10:08:21,780 --> 10:08:27,780
サブスクリプションIDを渡すと、最新のデータと最新のステータスを持つサブスクリプションを取得する。

4965
10:08:27,780 --> 10:08:34,900
サブスクリプションにはステータスがあります。

4966
10:08:34,900 --> 10:08:40,420
ステータスの値はドキュメントで説明されています。

4967
10:08:40,420 --> 10:08:47,460
Webhookのコードでは、次のように有効にします。

4968
10:08:48,500 --> 10:08:57,940
ステータスがactiveに等しい場合、サブスクリプションを有効にします。

4969
10:08:57,940 --> 10:09:04,740
しかし、ステータスがtrialingに等しい場合、サブスクリプションを有効にしたい。

4970
10:09:04,740 --> 10:09:11,460
つまり、トライアル・モードが有効になっているということだ。

4971
10:09:11,460 --> 10:09:21,540
また、ステータスが 「bill 」に設定されている場合にも有効にしたい。

4972
10:09:21,540 --> 10:09:26,740
もちろん、有効化するか無効化するかはあなた次第です。

4973
10:09:26,740 --> 10:09:32,900
この場合、購読を有効化するか無効化するかはあなた次第ですが、私は有効化したままにしておくことにしました。

4974
10:09:32,900 --> 10:09:38,900
まだ請求書を支払うチャンスは残っている。

4975
10:09:38,900 --> 10:09:45,700
というのも、定期購入のステータスが次に変更されたとき、私たちはこれをあなたのユースケースに合わせて調整するからです。

4976
10:09:45,700 --> 10:09:54,740
購読が有効でない場合、ステータスを購読テーブルに格納することができます。

4977
10:09:54,740 --> 10:10:00,500
サブスクリプションが有効でない場合、データベースから削除したいだけです。

4978
10:10:00,500 --> 10:10:07,220
なぜなら、次にサブスクリプションのステータスが変更されたとき、再び更新イベントが発生するからです。

4979
10:10:07,220 --> 10:10:13,380
次にサブスクリプションのステータスが変更されると、再び更新されたイベントが発生します。

4980
10:10:13,380 --> 10:10:20,500
もしステータスが

4981
10:10:20,500 --> 10:10:27,540
ステータスが 「none
」の場合、つまり、未完了、キャンセル、またはユーザーが請求書を支払っていないことを意味します。

4982
10:10:27,540 --> 10:10:36,340
これらの異なるオプションの1つをprisma dot user subscription dot
delete menuと呼びます。

4983
10:10:37,140 --> 10:10:43,780
もしサブスクリプションが存在しなければ、deleteではなくcustomer
manyを呼び出します。

4984
10:10:43,780 --> 10:10:48,740
はエラーを投げますが、delete manyは成功します。

4985
10:10:48,740 --> 10:10:57,700
サブスクリプションがまだデータベースに存在するかわからないので、delete manyを使用します。

4986
10:10:57,700 --> 10:11:06,100
この値は一意な値なので、削除フィルタに使用することができます。

4987
10:11:07,700 --> 10:11:14,420
を文字列として使用します。

4988
10:11:14,420 --> 10:11:22,260
データベースに入れたいので、ここでprisma dot user subscription dot
absurd

4989
10:11:22,260 --> 10:11:29,140
不条理は、createとupdateが混在している。

4990
10:11:29,140 --> 10:11:34,660
の前に更新されたイベントを受け取ったことを確認する。

4991
10:11:34,660 --> 10:11:40,500
というのも、新しいサブスクリプションを作成するときとストライプを作成するときに、実際には同時にイベントを受け取るからです。

4992
10:11:40,500 --> 10:11:45,540
を別々に処理すると、createdイベントが終了する前にupdatedイベントを受け取ることになり、問題が発生します。

4993
10:11:45,540 --> 10:11:50,900
イベントを受け取ることになるからです。

4994
10:11:50,900 --> 10:11:56,340
というのも、この2つのイベントは非常に似ているからです。

4995
10:11:56,340 --> 10:12:03,060
の前にupdatedイベントを受け取ることができるので、その順番に依存することはできません。

4996
10:12:03,060 --> 10:12:11,380
を呼び出します。ここではユーザーIDをフィルターとして使います。

4997
10:12:11,380 --> 10:12:20,100
これはサブスクリプションのメタデータにあります。

4998
10:12:20,100 --> 10:12:26,740
これは2つ目のメタデータブロックなので、両方を渡す必要があります。

4999
10:12:26,740 --> 10:12:34,980
次に、createブロックを置き、新しいサブスクリプションをデータベースに作成します。

5000
10:12:34,980 --> 10:12:42,420
そして、ここに保存する必要があるすべてのデータを渡します。

5001
10:12:42,420 --> 10:12:54,980
ユーザーIDはメタデータのcustomerにあります。

5002
10:12:54,980 --> 10:13:05,540
ideaは同じスペルで、次にsubscriptionにあるsubscription
ideaをstripeしなければならない。

5003
10:13:05,540 --> 10:13:18,420
dot idea stripe customer ideaはsubscription dot
customerで、これも文字列で入力します。

5004
10:13:22,020 --> 10:13:27,700
次に、ストライプ価格のアイデア
このようにして、プレミアムまたはプリペアを購入したサブスクリプションを識別することができます。

5005
10:13:27,700 --> 10:13:35,700
またはプレミアム・プラスを特定することができる。

5006
10:13:35,700 --> 10:13:44,500
dot items dot
dataで見つけることができます。ここでは最初のオブジェクトにアクセスし、価格ドットIDを見つけます。

5007
10:13:45,700 --> 10:13:52,900
さて、ストライプの現在の期間がいつ終了するのか気になるところだが、これもこの配列の中にある。

5008
10:13:52,900 --> 10:14:00,180
というのも、ここで受信したデータはすべてロックされるからだ。

5009
10:14:00,180 --> 10:14:06,100
アイテムには価格が入っています。

5010
10:14:06,100 --> 10:14:13,300
チェックアウトには1つのアイテムしかないので、常にインデックスゼロの最初のアイテムにアクセスします。

5011
10:14:14,180 --> 10:14:21,620
この配列には現在のアンダースコア期間があります。

5012
10:14:21,620 --> 10:14:31,620
これはタイムスタンプであり、これを日付として保存したい。

5013
10:14:31,620 --> 10:14:38,660
そしてもちろん、タイプスクリプトのオートコンプリートも

5014
10:14:38,660 --> 10:14:46,260
ミリ秒を渡す必要がある。

5015
10:14:46,260 --> 10:14:56,340
ミリ秒を渡さなければならないので、これを1000倍し、最後の値は期間終了時のストライプ・キャンセルである。

5016
10:14:56,340 --> 10:15:04,260
これはまたブール値で、購読をキャンセルするときに期間終了時にキャンセルされます。

5017
10:15:04,260 --> 10:15:10,580
これはtrueに設定され、後でこの値が必要になるので、ここにも保存されます。

5018
10:15:10,580 --> 10:15:18,740
dot cancel at period end
しかし、これは不合理な操作であるため、この値もここに格納する必要があります。

5019
10:15:18,740 --> 10:15:26,260
以下のupdateブロックは、サブスクリプションを更新するときに更新したいデータで作成します。

5020
10:15:26,260 --> 10:15:32,500
ユーザーIDやその他の情報はすでに保存されているので、必要な値は少なくなります。

5021
10:15:32,500 --> 10:15:37,540
新しい価格のアイデアが必要です。

5022
10:15:37,540 --> 10:15:44,580
すでにプロプラスを実装しているため、新しい価格のアイデアと

5023
10:15:44,580 --> 10:15:51,780
この3つの値を保存します。

5024
10:15:51,780 --> 10:15:58,740
最後に、購読が削除された場合の処理を実装します。

5025
10:15:58,740 --> 10:16:04,820
これはとても簡単で、ここで使用したのと同じように、多くの削除処理を行います。

5026
10:16:04,820 --> 10:16:11,300
先ほど見たように、stripeダッシュボードから購読を削除した場合、または購読がキャンセルされた場合のどちらかを受け取ります。

5027
10:16:11,300 --> 10:16:18,820
または、購読がキャンセルされ、期間が終了した場合にも

5028
10:16:18,820 --> 10:16:24,740
を受信し、データベースからサブスクリプションを削除することができます。

5029
10:16:24,740 --> 10:16:30,340
Webhookが完了し、実際のチェックアウトと購入ができるようになりました。

5030
10:16:30,340 --> 10:16:35,860
これでWebhookは完了し、本物のチェックアウトを行い、本物のサブスクリプションを購入するための準備が整ったはずです。

5031
10:16:35,860 --> 10:16:44,260
レジュメのページに行くと、まだ有効な購読がありません。

5032
10:16:44,260 --> 10:16:47,940
まず、通常のプレミアム購読を購入します。

5033
10:16:50,180 --> 10:16:54,980
ここでも偽のカードを使ってデータを入力しなければならない。

5034
10:16:54,980 --> 10:17:08,500
購読を申し込むと、データベースに本物の購読が作成されるはずです。

5035
10:17:08,500 --> 10:17:16,180
その結果、Webhookが再びカットされ、同じイベントと宛先、その他すべての情報を受け取ることになる。

5036
10:17:16,740 --> 10:17:25,220
これでプレミアムにアクセスできるはずです。

5037
10:17:25,220 --> 10:17:33,540
データベースのサブスクリプションが見つかります。

5038
10:17:33,540 --> 10:17:41,620
期間終了時のキャンセルはfalseで、次回の支払い期限とその他の情報があります。

5039
10:17:42,180 --> 10:17:48,500
そして、プレミアム機能にアクセスできるはずです。

5040
10:17:48,500 --> 10:17:55,140
このボタンをクリックすると、履歴書エディターが表示されます。

5041
10:17:55,140 --> 10:18:01,540
このボタンをクリックすると、履歴書エディターが表示されます。

5042
10:18:01,540 --> 10:18:08,340
カスタマイズオプションもプレミアムプラスの機能です。

5043
10:18:08,340 --> 10:18:14,180
このボタンをクリックすると、ダミーページが表示されます。

5044
10:18:14,180 --> 10:18:20,740
これは通常のプレミアム・サブスクリプションの一部なので、終わりにしましょう。

5045
10:18:20,740 --> 10:18:25,940
課金ポータルを実装したい。

5046
10:18:25,940 --> 10:18:32,820
次に、現在の購読に関する情報を表示したい。

5047
10:18:32,820 --> 10:18:41,300
今はこのダミーページしかありません。

5048
10:18:41,300 --> 10:18:50,740
ページのタイトルを設定することから始めましょう。

5049
10:18:50,740 --> 10:18:54,340
そしてタイトルをbillingに設定します

5050
10:18:56,740 --> 10:19:03,220
そして、このユーザーの購読をフェッチして、いくつか表示したい。

5051
10:19:03,220 --> 10:19:07,620
ページ上の情報なので、まずこれを非同期関数にします。

5052
10:19:07,620 --> 10:19:13,780
次に、店員のユーザーIDが必要である。

5053
10:19:13,780 --> 10:19:21,300
もしユーザーIDが未定義なら、このページには用はない。

5054
10:19:21,940 --> 10:19:29,300
もしユーザーIDが定義されていれば、NULLを返すかエラーを投げる。

5055
10:19:29,300 --> 10:19:35,940
を定義した場合、そのページで現在のサブスクリプションを待ち受けるように呼び出します。

5056
10:19:35,940 --> 10:19:42,260
定期購入の名前は定期購入オブジェクトに保存されません。

5057
10:19:42,260 --> 10:19:48,580
定期購入の名前は定期購入オブジェクトに保存されず、価格IDだけが保存されます。

5058
10:19:48,580 --> 10:19:56,100
subscription equals await prisma dot user
subscription dot find unique

5059
10:19:56,100 --> 10:20:05,220
これは一意な値であるため、ユーザIDで検索することができます。

5060
10:20:05,220 --> 10:20:13,860
データベースからのサブスクリプションオブジェクトです。

5061
10:20:13,860 --> 10:20:21,540
サブスクリプションが定義されているかどうかをチェックします。

5062
10:20:21,540 --> 10:20:31,780
lib フォルダ dot prices dot retrieve から stripe
を呼び出します。

5063
10:20:31,780 --> 10:20:42,500
dot stripe price idを渡し、2番目のドキュメントとして設定オブジェクトを渡します。

5064
10:20:44,020 --> 10:20:51,940
サブスクリプションが未定義の場合、mxはこのリクエストで全情報の幅を注文します。

5065
10:20:51,940 --> 10:20:57,940
の場合、価格情報をnullに設定します。

5066
10:20:57,940 --> 10:21:07,780
では、リターンブロックを処理しましょう。メインタグをいつものように最大幅7xlでスタイルします。

5067
10:21:09,300 --> 10:21:19,460
mxは全角幅6 px 3とpy 6を指定します。

5068
10:21:19,460 --> 10:21:31,380
もう一度、ここにh1見出しを置き、テキストは3xl、フォントは太字にして、請求書とする。

5069
10:21:33,060 --> 10:21:41,060
下に商品を置きたいので、これをストライプ・ドットにキャストしなければならない。

5070
10:21:41,060 --> 10:21:49,300
というのも、その後にフォントを太字にしてスパンを表示したいからである。

5071
10:21:49,300 --> 10:22:02,260
価格情報が定義されているかどうかをチェックし、価格情報ドット・プロダクトをレンダリングしたい。

5072
10:22:02,260 --> 10:22:10,820
これをストライプのドット積にキャストし、ここで名前を見つけることができます。

5073
10:22:10,820 --> 10:22:20,340
そして、もし価格情報がnullであれば、文字列freeをレンダリングします。

5074
10:22:20,340 --> 10:22:28,020
現在のプランでは、ai履歴書ビルダープロマネーエクスポートデフォルト関数は、同じ名前を持っていません。

5075
10:22:29,540 --> 10:22:35,300
エッジを作成し、現在のサブスクリプションを変更します。

5076
10:22:35,300 --> 10:22:45,140
まだ購読していない場合は請求フォルダに入れましょう。

5077
10:22:45,140 --> 10:22:52,820
このページはサーバーコンポーネントなので、ドットtsxはクライアントコンポーネントでなければなりません。

5078
10:22:52,820 --> 10:22:57,220
同じ名前でデフォルト関数をエクスポートします。

5079
10:22:57,460 --> 10:23:05,140
はプロップを必要としませんが、ここではプレミアムモデルを表示します。

5080
10:23:05,140 --> 10:23:10,580
フックから取得したプレミアムモデルを表示します。

5081
10:23:10,580 --> 10:23:16,580
ここではシンプルなパッチを返します。

5082
10:23:16,580 --> 10:23:23,940
プレミアムモデルとして課金フォルダに入れます。

5083
10:23:25,540 --> 10:23:34,420
set open これをtrueに設定します。

5084
10:23:34,420 --> 10:23:44,980
テキストはプレミアムサブスクリプションを取得すると表示されます。

5085
10:23:44,980 --> 10:23:50,580
サブスクリプションを管理するボタンはもう少し複雑です。

5086
10:23:51,460 --> 10:23:57,940
そして、これを購読ボタン・ドットtsxの管理と呼ぶことにしよう。

5087
10:23:57,940 --> 10:24:03,140
これもクライアント・コンポーネントでなければなりません。

5088
10:24:03,140 --> 10:24:07,140
ここにエクスポートします。

5089
10:24:07,140 --> 10:24:14,420
そして、一番上のサーバーディレクティブを使用するようにリダイレクトします。

5090
10:24:15,700 --> 10:24:23,220
そして、非同期関数をエクスポートします。

5091
10:24:23,220 --> 10:24:30,660
カスタマーポータルを作成する際にも、stripe関数を呼び出す必要がありますが、これもサーバー上で行う必要があります。

5092
10:24:30,660 --> 10:24:36,900
この場合もサーバーアクションを使用することができます。

5093
10:24:38,020 --> 10:24:45,460
という非同期関数をエクスポートします。

5094
10:24:45,460 --> 10:24:55,060
という非同期関数をエクスポートします。

5095
10:24:55,060 --> 10:25:02,500
ポータルセッションを呼び出したい。

5096
10:25:03,060 --> 10:25:09,940
を取得する必要がある。

5097
10:25:09,940 --> 10:25:19,060
そうしないと、この関数を呼び出すことができません。

5098
10:25:19,060 --> 10:25:28,500
ユーザーオブジェクトが必要なのは、ストライプの顧客IDが必要だからです。

5099
10:25:28,500 --> 10:25:39,460
店員のプライベートメタデータに格納されている stripe customer id
が必要だからです。

5100
10:25:39,460 --> 10:25:49,940
metadata.stripe顧客idはスペルが正しいことを確認し、これを文字列にキャストします。

5101
10:25:50,900 --> 10:26:00,100
を文字列にキャストするか、undefinedにキャストします。

5102
10:26:00,100 --> 10:26:09,140
ドットを指定した場合、ここでエラーが発生します。

5103
10:26:09,140 --> 10:26:14,660
顧客IDがあるはずです ストライプ顧客IDが見つかりません

5104
10:26:17,060 --> 10:26:24,420
しかし、顧客IDがあれば、セッションを作成したい。

5105
10:26:24,420 --> 10:26:34,420
dot billing portal dot session dot create
括弧は中括弧である。

5106
10:26:34,420 --> 10:26:44,180
customerはストライプの顧客IDで、return urlはバックティック文字列です。

5107
10:26:45,860 --> 10:26:47,940
ここにenv

5108
10:26:47,940 --> 10:26:59,060
dot next public base url slash billing
課金ページにリダイレクトさせたい。

5109
10:26:59,060 --> 10:27:08,580
session.urlが未定義かどうかをチェックします。

5110
10:27:09,300 --> 10:27:19,460
顧客ポータルセッションの作成に失敗しました。

5111
10:27:19,460 --> 10:27:28,340
を返して、ブラウザでリダイレクトできるようにしたい。

5112
10:27:28,340 --> 10:27:34,260
関数を呼び出したい。

5113
10:27:35,540 --> 10:27:41,300
クールなローディングボタンの一つです。

5114
10:27:41,300 --> 10:27:48,180
loading set loadingで、falseで初期化します。

5115
10:27:48,180 --> 10:27:53,780
そして、非同期関数ハンドルクリックが必要です。

5116
10:27:53,780 --> 10:28:04,900
この関数をクリックするとhandleが呼び出されます。

5117
10:28:04,900 --> 10:28:13,540
clickが呼び出され、ローディング状態にはローディングの使用状態を渡します。

5118
10:28:13,540 --> 10:28:21,780
サブスクリプションの呼び出しは、プレミアムダイアログで行ったこととよく似ています。

5119
10:28:21,780 --> 10:28:30,340
関数を呼び出し、このURLにリダイレクトします。

5120
10:28:30,340 --> 10:28:36,180
このエラーブロック全体をコピーして、原稿の暗号化ボタンに戻りましょう。

5121
10:28:36,180 --> 10:28:47,140
try catchブロックをここに置いて、エラーコードをfinallyブロックに貼り付けます。

5122
10:28:47,140 --> 10:28:56,580
falseに設定し、tryブロックでloadingをtrueに設定します。

5123
10:28:56,580 --> 10:29:05,460
urlを取得します。

5124
10:29:05,460 --> 10:29:15,860
window.location.hrefでこのURLにリダイレクトします。

5125
10:29:15,860 --> 10:29:24,260
この段落の下にあるpage.tsxファイルに戻りましょう。

5126
10:29:24,260 --> 10:29:30,180
タグの下の式で、購読があるかどうかをチェックします。

5127
10:29:30,180 --> 10:29:39,460
がない場合は空のフラグメントをレンダリングします。

5128
10:29:39,460 --> 10:29:44,980
をレンダリングします。

5129
10:29:44,980 --> 10:29:52,900
もちろん、このフラグメントに購読管理ボタンを置きたい。

5130
10:29:52,900 --> 10:29:58,900
を表示させたい。

5131
10:29:58,900 --> 10:30:05,140
定期購読が終了しようとしていることをユーザーに知らせるためだ。

5132
10:30:05,140 --> 10:30:15,460
定期購読がキャンセルされたことを意味します。

5133
10:30:15,460 --> 10:30:19,940
しかし、現在の請求期間はまだ終わっていないので、購読はまだ有効です。

5134
10:30:20,980 --> 10:30:28,340
次に、クラス名のテキストが破壊された別の段落タグをレンダリングします。

5135
10:30:28,340 --> 10:30:37,140
これはshadcnの色の1つです。

5136
10:30:37,140 --> 10:30:46,100
と表示されます。

5137
10:30:47,220 --> 10:30:50,740
をレンダリングした後なので、式には日付の書式を指定します。

5138
10:30:50,740 --> 10:30:59,140
この中にformat date関数があります。

5139
10:30:59,140 --> 10:31:03,220
そして、この日付をレンダリングします。

5140
10:31:03,220 --> 10:31:13,060
日付の書式を設定するために、購読の管理ボタンを

5141
10:31:13,060 --> 10:31:21,620
を表示させたい。また、フォーマット文字列には4つの大文字のmと2つの小文字のd

5142
10:31:21,620 --> 10:31:31,380
カンマと小文字のyを4つ、これは現在の購読をキャンセルする場合にのみ表示されます。

5143
10:31:31,380 --> 10:31:39,220
そしてその直後に、このフラグメントの中に購読管理ボタンをレンダリングします。

5144
10:31:39,220 --> 10:31:45,380
これを保存すると、購読をキャンセルしていないので、このボタンだけが表示されます。

5145
10:31:45,380 --> 10:31:50,100
このボタンをクリックすると、コンソールにエラーが表示されます。

5146
10:31:50,100 --> 10:31:57,540
課金ポータルを有効にする必要があるため、コンソールにエラーが表示されます。

5147
10:31:57,540 --> 10:32:01,860
顧客ポータル設定を保存するまで、テストモードでポータルセッションを作成することはできません。

5148
10:32:01,860 --> 10:32:07,140
顧客がプランを切り替えられるようにして、プランをアップグレードしたりダウングレードしたりできるようにします。

5149
10:32:08,580 --> 10:32:14,900
そして、ここでカスタマーポータルを設定することができます。

5150
10:32:14,900 --> 10:32:21,860
ここでいくつかの設定を変更できます。例えば、キャンセルを有効にします。

5151
10:32:21,860 --> 10:32:29,060
請求期間終了時にキャンセルする。

5152
10:32:29,060 --> 10:32:36,420
プランのアップグレードやダウングレードができるようにする。

5153
10:32:36,420 --> 10:32:43,140
プロ・マンスリー、プロ・プラス・マンスリーの両方を追加し、ユーザーが切り替えられるようにします。

5154
10:32:43,140 --> 10:32:47,940
他の設定も確認できます。

5155
10:32:47,940 --> 10:32:53,060
ポータルが機能するはずです。

5156
10:32:53,060 --> 10:33:02,500
もう一度、サブスクリプションの管理をクリックします。

5157
10:33:02,500 --> 10:33:08,820
別のウェブフック・イベントの説明を受け取る。

5158
10:33:08,820 --> 10:33:15,140
サブスクリプションを更新したり、キャンセルしたり、請求書を見たりすることができます。

5159
10:33:15,140 --> 10:33:21,940
このポータルはとてもクールです。

5160
10:33:21,940 --> 10:33:30,100
支払い方法が実際に保存されます。

5161
10:33:30,100 --> 10:33:36,100
をクリックすると、別のウェブフックイベントを受信するはずです。

5162
10:33:36,100 --> 10:33:42,740
このリンクをクリックすると、データベースにあるサブスクリプションが自動的に更新されます。

5163
10:33:42,740 --> 10:33:48,980
これで、プロ・プラス月額プランが利用できるようになりました。

5164
10:33:48,980 --> 10:33:57,700
つ以上の履歴書を作成することができます。

5165
10:33:57,700 --> 10:34:02,100
プレミアム機能を利用することができます。

5166
10:34:02,100 --> 10:34:08,580
キャンセルする

5167
10:34:08,580 --> 10:34:17,300
ここに理由を書くこともできますが、その必要はありません。

5168
10:34:17,300 --> 10:34:23,380
あなたの購読は12月15日にキャンセルされます。

5169
10:34:23,380 --> 10:34:28,100
つまり、私たちはまだすべてのプレミアム機能にアクセスできるということだ。

5170
10:34:28,100 --> 10:34:33,620
しかし、この課金期間が終了すると、サブスクリプションは削除されます。

5171
10:34:33,620 --> 10:34:40,580
サブスクリプションが削除されたウェブフックイベントを受信したため、サブスクリプションは削除されます。

5172
10:34:40,580 --> 10:34:47,780
サブスクリプションを更新してください。

5173
10:34:47,780 --> 10:34:52,820
が再びアクティブになり、現在の請求書作成が終了した時点で、いくつかの重要なステップが必要になります。

5174
10:34:52,820 --> 10:34:58,340
この金額を逃すとサブスクリプションが自動的に更新されてしまう。

5175
10:34:58,340 --> 10:35:03,620
ストライプのダッシュボードをチェックすることをお勧めします。

5176
10:35:03,620 --> 10:35:08,820
クレジットカードだけでなく、様々な支払い方法を有効にすることができます。

5177
10:35:08,820 --> 10:35:15,860
この機能を見てください。

5178
10:35:15,860 --> 10:35:20,580
を本番環境にデプロイする必要があります。

5179
10:35:21,700 --> 10:35:27,460
プロジェクトをデプロイする前に、package.jsonファイルを少し変更しなければならない。

5180
10:35:27,460 --> 10:35:36,260
このlintスクリプトの下に、インストール後のスクリプトを追加しなければなりません。

5181
10:35:36,260 --> 10:35:43,540
prisma generate
これは本番環境でprismaクライアントを自動生成するために必要です。

5182
10:35:43,540 --> 10:35:47,940
これを追加しないと、後でこのプロジェクトをデプロイしようとしたときにエラーが発生します。

5183
10:35:48,500 --> 10:35:55,860
verzelはnext.jsのクリエイターである。

5184
10:35:55,860 --> 10:36:02,420
verzelはnext.jsのクリエイターなので、next.jsのプロジェクトをデプロイする最も簡単なオプションだ。

5185
10:36:02,420 --> 10:36:08,900
趣味のアカウントを使うことができ、ここにプロジェクトをアップロードするには、githubブランチにプッシュする必要がある。

5186
10:36:08,900 --> 10:36:15,620
ソース管理タブから直接vsコードでgithubリポジトリにプッシュできます。

5187
10:36:15,620 --> 10:36:22,820
公開である必要はなく、非公開でも構わないが、github上に最新のコードがすべて必要だ。

5188
10:36:22,820 --> 10:36:29,940
新規プロジェクトの追加をクリックし、このアカウントはgithubアカウントに接続する必要があります。

5189
10:36:29,940 --> 10:36:38,180
このプロジェクトが保存されているgithubアカウントに接続する必要があります。

5190
10:36:38,180 --> 10:36:44,500
.envファイルから取得した環境変数を追加します。

5191
10:36:44,500 --> 10:36:50,420
例えば、本番環境ではストライプキーが異なります。

5192
10:36:50,420 --> 10:36:58,740
.envファイルから取得した環境変数をここに追加します。

5193
10:36:58,740 --> 10:37:04,900
このプロジェクトのデプロイには1、2分かかります。

5194
10:37:04,900 --> 10:37:13,540
このプロジェクトをデプロイするのに1、2分かかるので、インストールコマンドを上書きして、npm
install

5195
10:37:13,540 --> 10:37:20,580
--legacy-peer-devsを追加します。

5196
10:37:20,580 --> 10:37:26,820
next.js15とまだ互換性がないパッケージもあるので、ここに互換性フラグを追加しなければならない。

5197
10:37:28,340 --> 10:37:34,420
これをすべて追加したら、デプロイをクリックする。

5198
10:37:34,420 --> 10:37:41,540
プロジェクトのデプロイが完了したら、本番用のフリーURLを取得します。

5199
10:37:41,540 --> 10:37:52,020
ダッシュボードに行きましょう。このドメインはヴェルツェルのサブドメインです。

5200
10:37:52,020 --> 10:38:00,900
もちろん、これを開くとウェブサイトが表示されます。

5201
10:38:00,900 --> 10:38:08,740
をクリックすると、ログインページが表示されます。

5202
10:38:08,740 --> 10:38:14,820
というのも、このURLは私たちのコード全体で使われており、重要な値だからです。

5203
10:38:14,820 --> 10:38:24,260
環境変数に移動して、ここでベースURLを本番URLに変更します。

5204
10:38:24,260 --> 10:38:34,420
末尾のスラッシュを削除して保存し、一般設定に移動します。

5205
10:38:34,420 --> 10:38:41,300
node.jsのバージョンが20以上であることを確認してください。

5206
10:38:41,300 --> 10:38:48,900
プロジェクトを再デプロイする必要がある。

5207
10:38:48,900 --> 10:38:57,380
実際にこれを止めると、アクティブになる。

5208
10:38:57,380 --> 10:39:03,140
Stripeのダッシュボードにアクセスして、Webhookのドメインを変更することができます。

5209
10:39:04,260 --> 10:39:12,900
このウェブフックを編集したいので、ドメインを変更したい。

5210
10:39:12,900 --> 10:39:21,460
ドメインを変更したいので、ここでcontinueをクリックします。

5211
10:39:21,460 --> 10:39:29,700
にリダイレクトします。

5212
10:39:29,700 --> 10:39:35,460
これは本当にクールです。

5213
10:39:35,460 --> 10:39:42,980
をアクティブにしておく必要がなくなるからだ。

5214
10:39:42,980 --> 10:39:49,540
ブラジルの本番用URLに送信します。

5215
10:39:49,540 --> 10:39:55,380
テスト・モードをオフにして、製品を作り直し、新しいウェブフックを作って、そして

5216
10:39:55,380 --> 10:40:01,460
このチュートリアルでは、テストモードにしておきます。

5217
10:40:01,460 --> 10:40:07,860
このWebhookを呼び出すことができるのは同じなので、テストモードを解除して、すべてをセットアップするだけです。

5218
10:40:07,860 --> 10:40:16,100
StripeアカウントでこのWebhookを保存します。

5219
10:40:16,100 --> 10:40:22,820
本番用URLでは、もうひとつ変更しなければならない設定があります。

5220
10:40:22,820 --> 10:40:30,580
デプロイの保護タブを開きましょう。

5221
10:40:30,580 --> 10:40:37,220
ブラジルの認証を無効にする必要があるかもしれません。

5222
10:40:37,220 --> 10:40:43,460
を呼び出すことができるかどうかはわかりませんが、まずは試してみましょう。

5223
10:40:43,460 --> 10:40:51,460
ブラジルの保護が有効かどうかを表示してくれるはずです。

5224
10:40:51,460 --> 10:40:57,380
このウェブフックを呼び出すことができたということなので、これを無効にする必要はなさそうだ。

5225
10:40:57,380 --> 10:41:02,020
しかし、認証に問題がある場合は、これを無効にする必要があるかもしれません。

5226
10:41:02,020 --> 10:41:07,220
とにかくプロジェクトを試してみよう。

5227
10:41:07,220 --> 10:41:14,580
デバッグツールであるブラジル・ツールバーがあります。

5228
10:41:14,580 --> 10:41:20,100
アプリの中で無効にすることができます。

5229
10:41:20,100 --> 10:41:29,380
新しいアカウントを作成するには、coding and flow.comに登録してください。

5230
10:41:29,380 --> 10:41:31,620
パスワード

5231
10:41:31,620 --> 10:41:42,100
この確認メール341024をもう一度送信してください。

5232
10:41:42,100 --> 10:41:49,460
レジュメはまだありません。

5233
10:41:49,460 --> 10:41:56,980
プレミアム会員になる」ボタンが表示されました。

5234
10:41:56,980 --> 10:42:03,540
ダークテーマ、ライトテーマ、すべての機能を試してみましょう。

5235
10:42:03,540 --> 10:42:14,100
この機能はすべて自動保存され、URLにはレジュメIDが入ります。

5236
10:42:14,100 --> 10:42:22,420
ページを更新し、履歴書に戻ることができます。

5237
10:42:22,420 --> 10:42:31,060
職歴を追加してみましょう。

5238
10:42:31,060 --> 10:42:35,780
プレミアム契約をしていないので、ai機能は使えません。

5239
10:42:40,740 --> 10:42:47,220
ブラブラと、いくつかのスキルと、1つのスキルツアー

5240
10:42:47,220 --> 10:42:55,780
と要約を追加すると、常に自動的に保存されます。

5241
10:42:55,780 --> 10:43:06,500
この履歴書を印刷することができます。

5242
10:43:06,500 --> 10:43:14,020
まだテストモードなので、課金ページでサブスクリプションを購入しましょう。

5243
10:43:14,020 --> 10:43:20,100
課金ページで定期購読を購入するか、新しい履歴書ボタンをクリックしてプレミアム定期購読を購入することもできます。

5244
10:43:20,100 --> 10:43:27,460
通常のプレミアムサブスクリプションから始めましょう。

5245
10:43:27,460 --> 10:43:33,460
stripeの本番モードに切り替えるときは、もちろん実際の支払い方法を使用する必要があります。

5246
10:43:33,460 --> 10:43:42,900
を使用する必要がありますが、ここではまだテストモードです。

5247
10:43:42,900 --> 10:43:48,100
ローカルホストポータルを実行する必要はありません。

5248
10:43:48,100 --> 10:43:59,460
プロジェクトがbersalで利用可能である限り、常に動作するはずです。

5249
10:43:59,460 --> 10:44:05,620
これで、月次サブスクリプションを増やすためのリクエストが作成され、別のレジュメを作成することができる。

5250
10:44:05,620 --> 10:44:11,540
aiの機能は使えるが、カスタマイズ機能は使えない。

5251
10:44:11,540 --> 10:44:23,860
2017年11月からマクドナルドでハンバーガーのフライヤーとして働いていた。

5252
10:44:25,460 --> 10:44:34,260
これがaiを開くリクエストを生成する。

5253
10:44:34,260 --> 10:44:41,940
購読の課金管理 購読の課金管理 購読の課金管理 購読の課金管理 購読の課金管理 購読の課金管理
エラーが発生しました。

5254
10:44:41,940 --> 10:44:49,540
このプロジェクトを開き、ログを見てみましょう。

5255
10:44:51,060 --> 10:44:56,740
セッションが完了したイベントです。

5256
10:44:56,740 --> 10:45:03,140
コーディングとフローで、このユーザー情報の店員ダッシュボードを見てみましょう。

5257
10:45:03,140 --> 10:45:11,140
プライベートメタデータに顧客IDがない。

5258
10:45:12,020 --> 10:45:21,460
stripe webhookはセッション完了イベントを受信しているはずです。

5259
10:45:21,460 --> 10:45:28,740
ユーザーメタデータの更新を待っていなかったからです。

5260
10:45:28,740 --> 10:45:35,060
非同期操作であるclerk clientの受信を待っていただけだからだ。

5261
10:45:35,060 --> 10:45:42,340
この操作を実際に待ち受けるには、この前にもう一つawaitを置く必要があります。

5262
10:45:42,340 --> 10:45:48,500
この変更をgithubにプッシュすると、自動的に

5263
10:45:48,500 --> 10:45:55,380
メインブランチにログインしてみましょう。

5264
10:45:55,380 --> 10:46:01,540
Berserkのビルドが完了するまで待ちます。

5265
10:46:01,540 --> 10:46:08,580
stripeから既存のサブスクリプションを削除して、また白紙の状態から始められるようにしよう。

5266
10:46:08,580 --> 10:46:15,780
customers 「の 」coding 「と 」flow "に情報があります。

5267
10:46:15,780 --> 10:46:23,300
顧客の削除をクリックして、もう一度やってみましょう。

5268
10:46:25,460 --> 10:46:29,380
これが終わったら、本番用URLに戻ります。

5269
10:46:29,380 --> 10:46:37,460
最新の変更が反映されているはずです もう一度ログインしてみましょう ログインしたままです

5270
10:46:37,460 --> 10:46:43,460
プレミアム購読を申し込む

5271
10:46:43,460 --> 10:46:51,540
支払い義務がある購読を申し込んで、さて、うまくいくか見てみましょう。

5272
10:46:54,020 --> 10:47:00,820
これが終わったら、radiusを注文し、アーティスト経由でサマリーを作成しましょう。

5273
10:47:00,820 --> 10:47:07,860
店員のユーザーを経由してサマリーも生成してみよう。

5274
10:47:07,860 --> 10:47:13,700
サーバーレス関数はこの処理が終わる前に実行を停止してしまった。

5275
10:47:13,700 --> 10:47:20,500
顧客IDをここに入力することで、課金ポータルでサブスクリプションを管理できるようになる。

5276
10:47:20,500 --> 10:47:30,500
リダイレクトされ、購読をプレミアム・プラスに更新できる。

5277
10:47:30,500 --> 10:47:41,220
プレミアムプラスに更新すると、追加機能が利用できるようになります。

5278
10:47:41,220 --> 10:47:48,740
色や枠の半径を変更するなどのカスタマイズができます。

5279
10:47:49,620 --> 10:47:54,740
aiを使って要約を作成し、これがうまく機能することを確認しましょう。

5280
10:47:54,740 --> 10:48:01,700
レジュメの削除もできるか確認してみましょう。

5281
10:48:01,700 --> 10:48:11,380
削除に失敗するとは思わなかったが、どうやらこのアプリには別のバグがあるようだ。

5282
10:48:11,380 --> 10:48:18,020
そのバグが何なのかわかったような気がする。

5283
10:48:18,580 --> 10:48:24,820
対応するレジュメを削除する場合、このバグを追加しましょう。

5284
10:48:24,820 --> 10:48:34,420
レジュメを削除した場合、そのレジュメに対応するレジュメを削除した場合、そのレジュメに対応するレジュメを削除した場合

5285
10:48:34,420 --> 10:48:41,060
つまり、履歴書を削除すると、その履歴書に属するすべての職務経歴がカスケードされます。

5286
10:48:41,060 --> 10:48:47,140
このレジュメも削除される。このバグが見つかってよかった。

5287
10:48:47,700 --> 10:48:51,300
では、職歴と学歴のテーブルにこれを追加してみよう。

5288
10:48:51,300 --> 10:48:58,020
この変更もgithubにプッシュしなければならない。

5289
10:48:58,020 --> 10:49:05,300
また、これらの変更をデータベースにプッシュする必要があると思うので、npx prisma db
pushを使ってこれを実行しよう。

5290
10:49:05,300 --> 10:49:13,060
そして、この練習プロジェクトでは、クロックとストライプの設定を開発モードにしておくことをお勧めします。

5291
10:49:13,060 --> 10:49:18,100
とストライプの設定は開発モードにしておくことをお勧めします。

5292
10:49:18,100 --> 10:49:24,020
これでレジュメを削除できるはずです。

5293
10:49:24,020 --> 10:49:33,620
これですべてうまくいくはずです。

5294
10:49:33,620 --> 10:49:39,540
フロントページに戻ります。

5295
10:49:39,540 --> 10:49:44,980
時計とストライプの設定は開発モードのままにしておくことをお勧めします。

5296
10:49:44,980 --> 10:49:50,820
というのも、本番用のプロジェクトは必要ないからです。

5297
10:49:50,820 --> 10:49:56,660
実際のZessアプリケーションを構築したいのであれば、新しい時計アプリを作成し、これをproductionモードに変更する必要があります。

5298
10:49:56,660 --> 10:50:03,780
時計のドキュメントに手順があるので、それを見ながら同様に変更してください。

5299
10:50:03,780 --> 10:50:09,860
stripeは、データベースを変更する必要がある場合、本番稼動チェックリストを提供しています。

5300
10:50:09,860 --> 10:50:17,700
新しいストライプシークレットキーが必要です。

5301
10:50:17,700 --> 10:50:23,540
ウェブフックのシークレットキーとストライプキーの交換をお忘れなく。

5302
10:50:23,540 --> 10:50:28,420
プロダクション・バリューについては、環境変数を変更する方法をすでにお見せしました。

5303
10:50:28,420 --> 10:50:33,940
環境変数を変更することができます。

5304
10:50:33,940 --> 10:50:41,140
しかし、より新しいストライプシークレットキーやウェブフックキーなどが必要になります。

5305
10:50:41,140 --> 10:50:47,540
もう一つ、プロジェクトにはオープン・クラフトがあります。

5306
10:50:47,540 --> 10:50:54,900
この画像はソーシャルメディアで見ることができます。

5307
10:50:54,900 --> 10:51:01,380
このような素晴らしいプロジェクトを立ち上げることができ、本当におめでとうございます。

5308
10:51:01,380 --> 10:51:07,060
もし参考になったのであれば、「いいね！」をお願いします。

5309
10:51:07,060 --> 10:51:11,700
チャンネル登録もお願いします。

5310
10:51:11,700 --> 10:51:17,460
今後もこのような大規模プロジェクトのチュートリアルを作っていきたいと思います。

5311
10:51:17,460 --> 10:51:24,500
私の無料メールマガジン「coding and flow.com react best
practices」に登録することもできます。

5312
10:51:24,820 --> 10:51:31,460
次回のビデオでお会いしましょう。

5313
10:51:31,460 --> 10:51:31,960
あなた

5314
10:51:33,960 --> 10:51:34,460
あなた

5315
10:51:34,460 --> 10:51:34,960
あなた

5316
10:51:36,960 --> 10:51:37,460
あなた

5317
10:51:39,460 --> 10:51:39,960
あなた

5318
10:51:39,960 --> 10:51:40,460
あなた

5319
10:51:42,460 --> 10:51:42,960
あなた

5320
10:51:44,960 --> 10:51:45,460
あなた

5321
10:51:47,460 --> 10:51:47,960
あなた

5322
10:51:49,960 --> 10:51:50,460
あなた

